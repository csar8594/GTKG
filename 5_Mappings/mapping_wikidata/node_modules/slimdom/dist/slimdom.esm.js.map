{"version":3,"file":"slimdom.esm.js","sources":["../src/mutation-observer/RegisteredObserver.ts","../src/mutation-observer/RegisteredObservers.ts","../src/mutation-observer/NotifyList.ts","../src/context/WeakRef.ts","../src/context/Context.ts","../src/util/NodeType.ts","../src/util/treeHelpers.ts","../src/util/cloneNode.ts","../src/util/errorHelpers.ts","../src/mutation-observer/MutationRecord.ts","../src/mutation-observer/queueMutationRecord.ts","../src/mixins.ts","../src/util/mutationAlgorithms.ts","../src/util/treeMutations.ts","../src/util/typeHelpers.ts","../src/Node.ts","../src/util/attrMutations.ts","../src/Attr.ts","../src/CharacterData.ts","../src/Text.ts","../src/CDATASection.ts","../src/Comment.ts","../src/DocumentType.ts","../src/util/namespaceHelpers.ts","../src/dom-parsing/NamespacePrefixMap.ts","../src/dom-parsing/serializationAlgorithms.ts","../src/Element.ts","../src/util/createElementNS.ts","../src/DOMImplementation.ts","../src/Document.ts","../src/DocumentFragment.ts","../src/ProcessingInstruction.ts","../src/Range.ts","../src/XMLDocument.ts","../src/dom-parsing/XMLSerializer.ts","../src/mutation-observer/MutationObserver.ts","../src/unsafe.ts","../src/index.ts"],"sourcesContent":["import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\r\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\r\nimport Node from '../Node';\r\n\r\n/**\r\n * A registered observer consists of an observer (a MutationObserver object) and options (a\r\n * MutationObserverInit dictionary).\r\n *\r\n * A transient registered observer is a registered observer that also consists of a source (a\r\n * registered observer).\r\n *\r\n * Transient registered observers are used to track mutations within a given node’s descendants\r\n * after node has been removed so they do not get lost when subtree is set to true on node’s parent.\r\n */\r\nexport default class RegisteredObserver {\r\n\t/**\r\n\t * The observer that is registered.\r\n\t */\r\n\tpublic observer: MutationObserver;\r\n\r\n\t/**\r\n\t * The Node that is being observed by the given observer.\r\n\t */\r\n\tpublic node: Node;\r\n\r\n\t/**\r\n\t * The options for the registered observer.\r\n\t */\r\n\tpublic options: MutationObserverInit;\r\n\r\n\t/**\r\n\t * A transient observer is an observer that has a source which is an observer.\r\n\t */\r\n\tpublic source: RegisteredObserver | null = null;\r\n\r\n\t/**\r\n\t * @param observer - The observer being registered\r\n\t * @param node     - The node being observed\r\n\t * @param options  - Options for the registration\r\n\t * @param source   - If non-null, creates a transient registered observer for the given\r\n\t *                   registered observer\r\n\t */\r\n\tconstructor(\r\n\t\tobserver: MutationObserver,\r\n\t\tnode: Node,\r\n\t\toptions: MutationObserverInit,\r\n\t\tsource?: RegisteredObserver\r\n\t) {\r\n\t\tthis.observer = observer;\r\n\t\tthis.node = node;\r\n\t\tthis.options = options;\r\n\t\tthis.source = source || null;\r\n\t\tif (source) {\r\n\t\t\tobserver._transients.push(this);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Adds the given mutationRecord to the NotifyList of the registered MutationObserver. It only\r\n\t * adds the record when it's type isn't blocked by one of the flags of this registered\r\n\t * MutationObserver options (formally the MutationObserverInit object).\r\n\t *\r\n\t * @param type                - The type of mutation record to queue\r\n\t * @param target              - The target node\r\n\t * @param data                - The data for the mutation record\r\n\t * @param interestedObservers - Array of mutation observer objects to append to\r\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\r\n\t */\r\n\tpublic collectInterestedObservers(\r\n\t\ttype: string,\r\n\t\ttarget: Node,\r\n\t\tdata: MutationRecordInit,\r\n\t\tinterestedObservers: MutationObserver[],\r\n\t\tpairedStrings: (string | null | undefined)[]\r\n\t) {\r\n\t\t// (continued from RegisteredObservers#queueMutationRecord)\r\n\r\n\t\t// 3.1. Let options be registered's options.\r\n\t\t// 3.2. If none of the following are true\r\n\t\t// node is not target and options[\"subtree\"] is false\r\n\t\tif (this.node !== target && !this.options.subtree) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// type is \"attributes\" and options[\"attributes\"] is not true\r\n\t\tif (type === 'attributes' && !this.options.attributes) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// type is \"attributes\", options[\"attributeFilter\"] exists, and options[\"attributeFilter\"]\r\n\t\t// does not contain name or namespace is non-null\r\n\t\t// (attributeFilter not implemented)\r\n\r\n\t\t// type is \"characterData\" and options[\"characterData\"] is not true\r\n\t\tif (type === 'characterData' && !this.options.characterData) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// type is \"childList\" and options[\"childList\"] is false\r\n\t\tif (type === 'childList' && !this.options.childList) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// then:\r\n\r\n\t\t// 3.2.1. Let mo be registered's observer.\r\n\t\t// 3.2.2. If interestedObservers[mo] does not exist, then set interestedObservers[mo] to\r\n\t\t// null\r\n\t\tlet index = interestedObservers.indexOf(this.observer);\r\n\t\tif (index < 0) {\r\n\t\t\tindex = interestedObservers.length;\r\n\t\t\tinterestedObservers.push(this.observer);\r\n\t\t\tpairedStrings.push(undefined);\r\n\t\t}\r\n\r\n\t\t// 3.2.3. If either type is \"attributes\" and options[\"attributeOldValue\"] is true, or type\r\n\t\t// is \"characterData\" and options[\"characterDataOldValue\"] is true, then set\r\n\t\t// interestedObservers[mo] to oldValue.\r\n\t\tif (\r\n\t\t\t(type === 'attributes' && this.options.attributeOldValue) ||\r\n\t\t\t(type === 'characterData' && this.options.characterDataOldValue)\r\n\t\t) {\r\n\t\t\tpairedStrings[index] = data.oldValue;\r\n\t\t}\r\n\t}\r\n}\r\n","import { MutationObserverInit, default as MutationObserver } from './MutationObserver';\r\nimport { MutationRecordInit } from './MutationRecord';\r\nimport RegisteredObserver from './RegisteredObserver';\r\nimport Node from '../Node';\r\n\r\n/**\r\n * Each node has an associated list of registered observers.\r\n */\r\nexport default class RegisteredObservers {\r\n\t/**\r\n\t * The node for which this RegisteredObservers lists registered MutationObserver objects.\r\n\t */\r\n\tprivate _node: Node;\r\n\r\n\tprivate _registeredObservers: RegisteredObserver[] = [];\r\n\r\n\t/**\r\n\t * @param node - Node for which this instance holds RegisteredObserver instances.\r\n\t */\r\n\tconstructor(node: Node) {\r\n\t\tthis._node = node;\r\n\t}\r\n\r\n\t/**\r\n\t * Registers a given MutationObserver with the given options.\r\n\t *\r\n\t * @param observer - Observer to create a registration for\r\n\t * @param options  - Options for the registration\r\n\t */\r\n\tpublic register(observer: MutationObserver, options: MutationObserverInit) {\r\n\t\t// (continuing from MutationObserver#observe)\r\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\r\n\t\t// observer is this:\r\n\t\tconst registeredObservers = this._registeredObservers;\r\n\t\tlet hasRegisteredObserverForObserver = false;\r\n\t\tregisteredObservers.forEach((registered) => {\r\n\t\t\tif (registered.observer !== observer) {\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\r\n\t\t\thasRegisteredObserverForObserver = true;\r\n\r\n\t\t\t// 7.1. For each node of this's node list, remove all transient registered\r\n\t\t\t// observers whose source is registered from node's registered observer list.\r\n\t\t\tremoveTransientRegisteredObserversForSource(registered);\r\n\r\n\t\t\t// 7.2. Set registered’s options to options.\r\n\t\t\tregistered.options = options;\r\n\t\t});\r\n\r\n\t\t// 8. Otherwise:\r\n\t\tif (!hasRegisteredObserverForObserver) {\r\n\t\t\t// 8.1. Append a new registered observer whose observer is this and\r\n\t\t\t// options is options to target's registered observer list.\r\n\t\t\tthis._registeredObservers.push(new RegisteredObserver(observer, this._node, options));\r\n\t\t\t// 8.2. Append target to this's node list.\r\n\t\t\tobserver._nodes.push(this._node);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the given transient registered observer.\r\n\t *\r\n\t * Transient registered observers never have a corresponding entry in the observer's list of\r\n\t * nodes. They are guaranteed to be present in the array, as MutationObserver#_transients and\r\n\t * RegisteredObservers#_registeredObservers are kept in sync.\r\n\t *\r\n\t * @param transientRegisteredObserver - The registered observer to remove\r\n\t */\r\n\tpublic removeTransientRegisteredObserver(\r\n\t\ttransientRegisteredObserver: RegisteredObserver\r\n\t): void {\r\n\t\tthis._registeredObservers.splice(\r\n\t\t\tthis._registeredObservers.indexOf(transientRegisteredObserver),\r\n\t\t\t1\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Remove any registered observer on the associated node for which observer is the observer.\r\n\t *\r\n\t * As this only occurs for all nodes at once, it is the caller's responsibility to remove the\r\n\t * associated node from the observer's list of nodes.\r\n\t *\r\n\t * @param observer - Observer for which to remove the registration\r\n\t */\r\n\tpublic removeForObserver(observer: MutationObserver): void {\r\n\t\t// Filter the array in-place\r\n\t\tlet write = 0;\r\n\t\tfor (let read = 0, l = this._registeredObservers.length; read < l; ++read) {\r\n\t\t\tconst registered = this._registeredObservers[read];\r\n\t\t\tif (registered.observer === observer) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tif (read !== write) {\r\n\t\t\t\tthis._registeredObservers[write] = registered;\r\n\t\t\t}\r\n\t\t\t++write;\r\n\t\t}\r\n\t\tthis._registeredObservers.length = write;\r\n\t}\r\n\r\n\t/**\r\n\t * Determines interested observers for the given record.\r\n\t *\r\n\t * @param type                - The type of mutation record to queue\r\n\t * @param target              - The target node\r\n\t * @param data                - The data for the mutation record\r\n\t * @param interestedObservers - Array of mutation observer objects to append to\r\n\t * @param pairedStrings       - Paired strings for the mutation observer objects\r\n\t */\r\n\tpublic collectInterestedObservers(\r\n\t\ttype: string,\r\n\t\ttarget: Node,\r\n\t\tdata: MutationRecordInit,\r\n\t\tinterestedObservers: MutationObserver[],\r\n\t\tpairedStrings: (string | null | undefined)[]\r\n\t) {\r\n\t\t// (continuing from queueMutationRecord)\r\n\t\t// 3. ...and then for each registered of node's registered observer list:\r\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\r\n\t\t\tregisteredObserver.collectInterestedObservers(\r\n\t\t\t\ttype,\r\n\t\t\t\ttarget,\r\n\t\t\t\tdata,\r\n\t\t\t\tinterestedObservers,\r\n\t\t\t\tpairedStrings\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Append transient registered observers for any registered observers whose options' subtree is\r\n\t * true.\r\n\t *\r\n\t * @param node - Node to append the transient registered observers to\r\n\t */\r\n\tpublic appendTransientRegisteredObservers(node: Node): void {\r\n\t\tthis._registeredObservers.forEach((registeredObserver) => {\r\n\t\t\tif (registeredObserver.options.subtree) {\r\n\t\t\t\tnode._registeredObservers.registerTransient(registeredObserver);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Appends a transient registered observer for the given registered observer.\r\n\t *\r\n\t * @param source - The source registered observer\r\n\t */\r\n\tpublic registerTransient(source: RegisteredObserver): void {\r\n\t\tthis._registeredObservers.push(\r\n\t\t\tnew RegisteredObserver(source.observer, this._node, source.options, source)\r\n\t\t);\r\n\t\t// Note that node is not added to the transient observer's observer's list of nodes.\r\n\t}\r\n}\r\n\r\n/**\r\n * Removes all transient registered observers whose observer is observer.\r\n *\r\n * @param observer - The mutation observer object to remove transient registered observers for\r\n */\r\nexport function removeTransientRegisteredObserversForObserver(observer: MutationObserver): void {\r\n\tobserver._transients.forEach((transientRegisteredObserver) => {\r\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\r\n\t\t\ttransientRegisteredObserver\r\n\t\t);\r\n\t});\r\n\tobserver._transients.length = 0;\r\n}\r\n\r\n/**\r\n * Removes all transient registered observer whose source is source.\r\n *\r\n * @param source - The registered observer to remove transient registered observers for\r\n */\r\nexport function removeTransientRegisteredObserversForSource(source: RegisteredObserver): void {\r\n\tfor (let i = source.observer._transients.length - 1; i >= 0; --i) {\r\n\t\tconst transientRegisteredObserver = source.observer._transients[i];\r\n\t\tif (transientRegisteredObserver.source !== source) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\ttransientRegisteredObserver.node._registeredObservers.removeTransientRegisteredObserver(\r\n\t\t\ttransientRegisteredObserver\r\n\t\t);\r\n\t\tsource.observer._transients.splice(i, 1);\r\n\t}\r\n}\r\n","import { default as MutationObserver } from './MutationObserver';\r\nimport MutationRecord from './MutationRecord';\r\nimport { removeTransientRegisteredObserversForObserver } from './RegisteredObservers';\r\n\r\ntype AnyCallback = (...args: any[]) => void;\r\ndeclare const queueMicrotask: undefined | ((callback: AnyCallback) => void);\r\n\r\n/* istanbul ignore next */\r\nfunction queueMicrotaskWithAppropriateApi(\r\n\tcallback: AnyCallback,\r\n\tthisArg: NotifySet,\r\n\t...args: any[]\r\n): void {\r\n\tif (typeof queueMicrotask === 'function') {\r\n\t\tqueueMicrotask(() => callback.apply(thisArg, args));\r\n\t\treturn;\r\n\t}\r\n\r\n\t// Fall back to Promise.then callbacks - these run as microtasks, but handle errors differently\r\n\tPromise.resolve().then(() => callback.apply(thisArg, args));\r\n}\r\n\r\n/**\r\n * Tracks MutationObserver instances which have a non-empty record queue and schedules their\r\n * callbacks to be called.\r\n */\r\nexport default class NotifySet {\r\n\tprivate _notifySet: Set<MutationObserver> = new Set();\r\n\tprivate _mutationObserverMicrotaskQueued: boolean = false;\r\n\r\n\t/**\r\n\t * Appends a given MutationRecord to the recordQueue of the given MutationObserver and schedules\r\n\t * it for reporting.\r\n\t *\r\n\t * @param observer - The observer for which to enqueue the record\r\n\t * @param record   - The record to enqueue\r\n\t */\r\n\tappendRecord(observer: MutationObserver, record: MutationRecord) {\r\n\t\tobserver._recordQueue.push(record);\r\n\t\tthis._notifySet.add(observer);\r\n\t}\r\n\r\n\t/**\r\n\t * To queue a mutation observer microtask, run these steps:\r\n\t */\r\n\tpublic queueMutationObserverMicrotask() {\r\n\t\t// 1. If the surrounding agent's mutation observer microtask queued is true, then return.\r\n\t\tif (this._mutationObserverMicrotaskQueued) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 2. Set the surrounding agent's mutation observer microtask queued to true.\r\n\t\tthis._mutationObserverMicrotaskQueued = true;\r\n\r\n\t\t// 3. Queue a microtask to notify mutation observers.\r\n\t\tqueueMicrotaskWithAppropriateApi(() => {\r\n\t\t\tthis._notifyMutationObservers();\r\n\t\t}, this);\r\n\t}\r\n\r\n\t/**\r\n\t * To notify mutation observers, run these steps:\r\n\t */\r\n\tprivate _notifyMutationObservers() {\r\n\t\t// 1. Set the surrounding agent's mutation observer microtask queued to false.\r\n\t\tthis._mutationObserverMicrotaskQueued = false;\r\n\r\n\t\t// 2. Let notifySet be a clone of the surrounding agent's mutation observers\r\n\t\tconst notifySet = Array.from(this._notifySet);\r\n\t\t// Clear the notify set - for efficiency this set only tracks observers that have a\r\n\t\t// non-empty queue\r\n\t\tthis._notifySet.clear();\r\n\r\n\t\t// 3. Let signalSet be a clone of the surrounding agent's signal slots.\r\n\t\t// 4. Empty the surrounding agent's signal slots.\r\n\t\t// (shadow dom not implemented)\r\n\r\n\t\t// 5. For each mo of notifySet:\r\n\t\t// [HTML]\r\n\t\tnotifySet.forEach((mo) => {\r\n\t\t\tqueueMicrotaskWithAppropriateApi(\r\n\t\t\t\t(mo: MutationObserver) => {\r\n\t\t\t\t\t// 5.1. Let records be a clone of mo’s record queue.\r\n\t\t\t\t\t// 5.2. Empty mo’s record queue.\r\n\t\t\t\t\tconst records = mo.takeRecords();\r\n\r\n\t\t\t\t\t// 5.3. For each node of mo's node list, remove all transient registered\r\n\t\t\t\t\t// observers whose observer is mo from node's registered observer list.\r\n\t\t\t\t\tremoveTransientRegisteredObserversForObserver(mo);\r\n\r\n\t\t\t\t\t// 5.4. If records is not empty, then invoke mo’s callback with « records, mo »,\r\n\t\t\t\t\t// and mo. If this throws an exception, catch it, and report the exception.\r\n\t\t\t\t\t// (A try/catch is not necessary here, as this microtask does nothing else and\r\n\t\t\t\t\t// letting the exception through will likely cause the environment to report it)\r\n\t\t\t\t\tif (records.length > 0) {\r\n\t\t\t\t\t\tmo._callback(records, mo);\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\t\t\tthis,\r\n\t\t\t\tmo\r\n\t\t\t);\r\n\t\t});\r\n\r\n\t\t// 6. For each slot of signalSet, fire an event named slotchange, with its bubbles attribute\r\n\t\t// set to true, at slot.\r\n\t\t// (shadow dom not implemented)\r\n\t}\r\n}\r\n","// TODO: remove when interface is included in dom.d.ts typings\r\nexport interface WeakRef<T> {\r\n\tderef(): T | undefined;\r\n}\r\ninterface WeakRefConstructor<T> {\r\n\tnew (target: T): WeakRef<T>;\r\n}\r\ndeclare var WeakRef: WeakRefConstructor<any>;\r\n\r\nclass FakeWeakRef<T> implements WeakRef<T> {\r\n\tprivate _target: T;\r\n\r\n\tconstructor(target: T) {\r\n\t\tthis._target = target;\r\n\t}\r\n\r\n\tpublic deref(): T {\r\n\t\treturn this._target;\r\n\t}\r\n}\r\n\r\nexport function createWeakRef<T>(target: T): WeakRef<T> {\r\n\tif (typeof WeakRef === 'function') {\r\n\t\treturn new WeakRef(target);\r\n\t}\r\n\r\n\treturn new FakeWeakRef(target);\r\n}\r\n","import Attr from '../Attr';\r\nimport CDATASection from '../CDATASection';\r\nimport Comment from '../Comment';\r\nimport Document from '../Document';\r\nimport DocumentFragment from '../DocumentFragment';\r\nimport DocumentType from '../DocumentType';\r\nimport DOMImplementation from '../DOMImplementation';\r\nimport Element from '../Element';\r\nimport Node from '../Node';\r\nimport ProcessingInstruction from '../ProcessingInstruction';\r\nimport Range from '../Range';\r\nimport Text from '../Text';\r\nimport XMLDocument from '../XMLDocument';\r\n\r\nimport NotifySet from '../mutation-observer/NotifyList';\r\n\r\nimport { createWeakRef, WeakRef } from './WeakRef';\r\n\r\nexport type AttrConstructor = new (\r\n\tnamespace: string | null,\r\n\tprefix: string | null,\r\n\tlocalName: string,\r\n\tvalue: string,\r\n\telement: Element | null\r\n) => Attr;\r\nexport type CDATASectionConstructor = new (data: string) => CDATASection;\r\nexport type CommentConstructor = new (data: string) => Comment;\r\nexport type DocumentConstructor = new () => Document;\r\nexport type DocumentFragmentConstructor = new () => DocumentFragment;\r\nexport type DocumentTypeConstructor = new (\r\n\tname: string,\r\n\tpublicId?: string,\r\n\tsystemId?: string\r\n) => DocumentType;\r\nexport type DOMImplementationConstructor = new (document: Document) => DOMImplementation;\r\nexport type ElementConstructor = new (\r\n\tnamespace: string | null,\r\n\tprefix: string | null,\r\n\tlocalName: string\r\n) => Element;\r\nexport type ProcessingInstructionConstructor = new (\r\n\ttarget: string,\r\n\tdata: string\r\n) => ProcessingInstruction;\r\nexport type RangeConstructor = new () => Range;\r\nexport type TextConstructor = new (data: string) => Text;\r\nexport type XMLDocumentConstructor = new () => XMLDocument;\r\n\r\nexport interface Context {\r\n\tdocument: Document;\r\n\r\n\t_notifySet: NotifySet;\r\n\r\n\tAttr: AttrConstructor;\r\n\tCDATASection: CDATASectionConstructor;\r\n\tComment: CommentConstructor;\r\n\tDocument: DocumentConstructor;\r\n\tDocumentFragment: DocumentFragmentConstructor;\r\n\tDocumentType: DocumentTypeConstructor;\r\n\tDOMImplementation: DOMImplementationConstructor;\r\n\tElement: ElementConstructor;\r\n\tProcessingInstruction: ProcessingInstructionConstructor;\r\n\tRange: RangeConstructor;\r\n\tText: TextConstructor;\r\n\tXMLDocument: XMLDocumentConstructor;\r\n\r\n\tforEachRange(cb: (range: Range) => void): void;\r\n\taddRange(range: Range): void;\r\n\tremoveRange(range: Range): void;\r\n}\r\n\r\n/**\r\n * The DefaultContext is comparable to the global object in that it tracks its associated document.\r\n * It also serves as a way to inject the constructors for the constructable types, avoiding cyclic\r\n * dependencies.\r\n */\r\nexport class DefaultContext implements Context {\r\n\tpublic document!: Document;\r\n\r\n\t/**\r\n\t * The NotifyList instance is shared between all MutationObserver objects. It holds references\r\n\t * to all MutationObserver instances that have collected records, and is responsible for\r\n\t * invoking their callbacks when control returns to the event loop.\r\n\t */\r\n\tpublic _notifySet: NotifySet = new NotifySet();\r\n\r\n\tpublic Attr!: AttrConstructor;\r\n\tpublic CDATASection!: CDATASectionConstructor;\r\n\tpublic Comment!: CommentConstructor;\r\n\tpublic Document!: DocumentConstructor;\r\n\tpublic DocumentFragment!: DocumentFragmentConstructor;\r\n\tpublic DocumentType!: DocumentTypeConstructor;\r\n\tpublic DOMImplementation!: DOMImplementationConstructor;\r\n\tpublic Element!: ElementConstructor;\r\n\tpublic ProcessingInstruction!: ProcessingInstructionConstructor;\r\n\tpublic Range!: RangeConstructor;\r\n\tpublic Text!: TextConstructor;\r\n\tpublic XMLDocument!: XMLDocumentConstructor;\r\n\r\n\tprivate _ranges: WeakRef<Range>[] = [];\r\n\r\n\tpublic forEachRange(cb: (range: Range) => void): void {\r\n\t\tlet numRanges = this._ranges.length;\r\n\t\tfor (let i = numRanges - 1; i >= 0; --i) {\r\n\t\t\tconst r = this._ranges[i].deref();\r\n\t\t\t// Safari / webkit has a bug where deref can return null instead of undefined\r\n\t\t\tif (r === undefined || r === null) {\r\n\t\t\t\t// Weak ref lost, remove\r\n\t\t\t\tthis._ranges[i] = this._ranges[numRanges - 1];\r\n\t\t\t\tthis._ranges.pop();\r\n\t\t\t\tnumRanges -= 1;\r\n\t\t\t} else {\r\n\t\t\t\tcb(r);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tpublic addRange(range: Range): void {\r\n\t\tthis._ranges.push(createWeakRef(range));\r\n\t}\r\n\r\n\tpublic removeRange(range: Range): void {\r\n\t\tlet numRanges = this._ranges.length;\r\n\t\tfor (let i = numRanges - 1; i >= 0; --i) {\r\n\t\t\tconst r = this._ranges[i].deref();\r\n\t\t\t// Safari / webkit has a bug where deref can return null instead of undefined\r\n\t\t\tif (r === undefined || r === null || r === range) {\r\n\t\t\t\tthis._ranges[i] = this._ranges[numRanges - 1];\r\n\t\t\t\tthis._ranges.pop();\r\n\t\t\t\tnumRanges -= 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// TODO: make it possible to create multiple contexts by binding constructors to each instance\r\nexport const defaultContext = new DefaultContext();\r\n\r\nexport function getContext(instance: Node | Range): Context {\r\n\treturn defaultContext;\r\n}\r\n","import Attr from '../Attr';\r\nimport CharacterData from '../CharacterData';\r\nimport Node from '../Node';\r\nimport Text from '../Text';\r\n\r\nexport const enum NodeType {\r\n\tELEMENT_NODE = 1,\r\n\tATTRIBUTE_NODE = 2,\r\n\tTEXT_NODE = 3,\r\n\tCDATA_SECTION_NODE = 4,\r\n\tENTITY_REFERENCE_NODE = 5, // legacy\r\n\tENTITY_NODE = 6, // legacy\r\n\tPROCESSING_INSTRUCTION_NODE = 7,\r\n\tCOMMENT_NODE = 8,\r\n\tDOCUMENT_NODE = 9,\r\n\tDOCUMENT_TYPE_NODE = 10,\r\n\tDOCUMENT_FRAGMENT_NODE = 11,\r\n\tNOTATION_NODE = 12, // legacy\r\n}\r\n\r\n/**\r\n * Checks whether the given node's nodeType is one of the specified values\r\n *\r\n * @param node  - The node to test\r\n * @param types - Possible nodeTypes for node\r\n *\r\n * @returns Whether node.nodeType is one of the specified values\r\n */\r\nexport function isNodeOfType(node: Node, ...types: NodeType[]): boolean {\r\n\treturn types.some((t) => node.nodeType === t);\r\n}\r\n\r\n/**\r\n * Checks whether node implements Attr\r\n *\r\n * @param node - The node to test\r\n *\r\n * @returns Whether node is an Attr\r\n */\r\nexport function isAttrNode(node: Node): node is Attr {\r\n\treturn isNodeOfType(node, NodeType.ATTRIBUTE_NODE);\r\n}\r\n\r\n/**\r\n * Checks whether node implements CharacterData\r\n *\r\n * @param node - The node to test\r\n *\r\n * @returns Whether node is a CharacterData node\r\n */\r\nexport function isCharacterDataNode(node: Node): node is CharacterData {\r\n\treturn isNodeOfType(\r\n\t\tnode,\r\n\t\tNodeType.COMMENT_NODE,\r\n\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\r\n\t\tNodeType.TEXT_NODE,\r\n\t\tNodeType.CDATA_SECTION_NODE\r\n\t);\r\n}\r\n\r\n/**\r\n * Checks whether node implements Text\r\n *\r\n * @param node - The node to test\r\n *\r\n * @returns Whether node is a Text (or CDataSection) node\r\n */\r\nexport function isTextNode(node: Node): node is Text {\r\n\treturn isNodeOfType(node, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE);\r\n}\r\n","import CharacterData from '../CharacterData';\r\nimport Document from '../Document';\r\nimport Element from '../Element';\r\nimport Node from '../Node';\r\nimport { NodeType, isNodeOfType } from './NodeType';\r\n\r\n/**\r\n * 3.2. Node Tree: to determine the length of a node, switch on node:\r\n *\r\n * @param node - The node to determine the length of\r\n *\r\n * @returns The length of the node\r\n */\r\nexport function determineLengthOfNode(node: Node): number {\r\n\tswitch (node.nodeType) {\r\n\t\t// DocumentType: Zero.\r\n\t\t// (not necessary, as doctypes never have children)\r\n\r\n\t\t// Text, ProcessingInstruction, Comment: The number of code units in its data.\r\n\t\tcase NodeType.TEXT_NODE:\r\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\r\n\t\tcase NodeType.COMMENT_NODE:\r\n\t\t\treturn (node as CharacterData).data.length;\r\n\r\n\t\t// Any other node: Its number of children.\r\n\t\tdefault:\r\n\t\t\treturn node.childNodes.length;\r\n\t}\r\n}\r\n\r\n/**\r\n * Get inclusive ancestors of the given node.\r\n *\r\n * @param node - Node to get inclusive ancestors of\r\n *\r\n * @returns Node's inclusive ancestors, in tree order\r\n */\r\nexport function getInclusiveAncestors(node: Node): Node[] {\r\n\tlet ancestor: Node | null = node;\r\n\tlet ancestors: Node[] = [];\r\n\twhile (ancestor) {\r\n\t\tancestors.unshift(ancestor);\r\n\t\tancestor = ancestor.parentNode;\r\n\t}\r\n\r\n\treturn ancestors;\r\n}\r\n\r\n/**\r\n * Get the node document associated with the given node.\r\n *\r\n * @param node - The node to get the node document for\r\n *\r\n * @returns The node document for node\r\n */\r\nexport function getNodeDocument(node: Node): Document {\r\n\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\r\n\t\treturn node as Document;\r\n\t}\r\n\r\n\treturn node.ownerDocument!;\r\n}\r\n\r\n/**\r\n * Determine the index of the given node among its siblings.\r\n *\r\n * @param node - Node to determine the index of\r\n *\r\n * @returns The index of node in its parent's children\r\n */\r\nexport function getNodeIndex(node: Node): number {\r\n\treturn node.parentNode!.childNodes.indexOf(node);\r\n}\r\n\r\n/**\r\n * The root of an object is itself, if its parent is null, or else it is the root of its parent.\r\n *\r\n * @param node - Node to get the root of\r\n *\r\n * @returns The root of node\r\n */\r\nexport function getRootOfNode(node: Node): Node {\r\n\twhile (node.parentNode) {\r\n\t\tnode = node.parentNode;\r\n\t}\r\n\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * Invokes callback on each inclusive descendant of node, in tree order\r\n *\r\n * @param node     - Root of the subtree to process\r\n * @param callback - Callback to invoke for each descendant, should not modify node's position in\r\n *                   the tree\r\n */\r\nexport function forEachInclusiveDescendant(node: Node, callback: (node: Node) => void): void {\r\n\tcallback(node);\r\n\tfor (let child = node.firstChild; child; child = child.nextSibling) {\r\n\t\tforEachInclusiveDescendant(child, callback);\r\n\t}\r\n}\r\n\r\n/**\r\n * The list of elements with qualified name qualifiedName for a node root is the HTMLCollection\r\n * returned by the following algorithm:\r\n *\r\n * (this implementation returns a non-live array instead)\r\n *\r\n * @param qualifiedName - The qualifiedName of elements to return, or '*' to return all elements\r\n * @param root          - The root of the subtree from which to collect matching descendants\r\n */\r\nexport function getListOfElementsWithQualifiedName(qualifiedName: string, root: Node): Element[] {\r\n\tconst elements: Element[] = [];\r\n\tforEachInclusiveDescendant(root, (node) => {\r\n\t\t// Only matches descendant elements\r\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst element = node as Element;\r\n\r\n\t\tif (\r\n\t\t\t// 1. If qualifiedName is \"*\" (U+002A), return a HTMLCollection rooted at root, whose\r\n\t\t\t// filter matches only descendant elements.\r\n\t\t\tqualifiedName === '\\u002a' ||\r\n\t\t\t// 2. Otherwise, if root’s node document is an HTML document, return a HTMLCollection\r\n\t\t\t// rooted at root, whose filter matches the following descendant elements:\r\n\t\t\t//    - Whose namespace is the HTML namespace and whose qualified name is qualifiedName,\r\n\t\t\t//      in ASCII lowercase.\r\n\t\t\t//    - Whose namespace is not the HTML namespace and whose qualified name is\r\n\t\t\t//      qualifiedName.\r\n\t\t\t// (html documents not implemented)\r\n\r\n\t\t\t// 3. Otherwise, return a HTMLCollection rooted at root, whose filter matches descendant\r\n\t\t\t// elements whose qualified name is qualifiedName.\r\n\t\t\telement.nodeName === qualifiedName\r\n\t\t) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r\n\r\n/**\r\n * The list of elements with namespace namespace and local name localName for a node root is the\r\n * HTMLCollection returned by the following algorithm:\r\n *\r\n * (this implementation returns a non-live array instead)\r\n *\r\n * @param namespace - The namespace of the elements to return, or '*' to match any namespace\r\n * @param localName - The local name of the elements to return, or '*' to match any local name\r\n * @param root      - The root of the subtree from which to collect matching descendants\r\n */\r\nexport function getListOfElementsWithNamespaceAndLocalName(\r\n\tnamespace: string | null,\r\n\tlocalName: string,\r\n\troot: Node\r\n): Element[] {\r\n\t// 1. If namespace is the empty string, set it to null.\r\n\tif (namespace === '') {\r\n\t\tnamespace = null;\r\n\t}\r\n\r\n\tconst elements: Element[] = [];\r\n\tforEachInclusiveDescendant(root, (node) => {\r\n\t\t// Only matches descendant elements\r\n\t\tif (node === root || node.nodeType !== NodeType.ELEMENT_NODE) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tconst element = node as Element;\r\n\r\n\t\tif (\r\n\t\t\t// 2. If both namespace and localName are \"*\" (U+002A), return a HTMLCollection\r\n\t\t\t//    rooted at root, whose filter matches descendant elements.\r\n\t\t\t// 3. Otherwise, if namespace is \"*\" (U+002A), return a HTMLCollection rooted at\r\n\t\t\t//    root, whose filter matches descendant elements whose local name is localName.\r\n\t\t\t// 4. Otherwise, if localName is \"*\" (U+002A), return a HTMLCollection rooted at\r\n\t\t\t//    root, whose filter matches descendant elements whose namespace is namespace.\r\n\t\t\t// 5. Otherwise, return a HTMLCollection rooted at root, whose filter matches\r\n\t\t\t//    descendant elements whose namespace is namespace and local name is localName.\r\n\t\t\t(namespace === '\\u002a' || element.namespaceURI === namespace) &&\r\n\t\t\t(localName === '\\u002a' || element.localName === localName)\r\n\t\t) {\r\n\t\t\telements.push(element);\r\n\t\t}\r\n\t});\r\n\r\n\treturn elements;\r\n}\r\n","import Document from '../Document';\r\nimport Node from '../Node';\r\n\r\nimport { getNodeDocument } from './treeHelpers';\r\n\r\n// 3.4. Interface Node\r\n\r\n/**\r\n * To clone a node, with an optional document and clone children flag, run these steps:\r\n *\r\n * @param node          - The node to clone\r\n * @param cloneChildren - Whether to also clone node's descendants\r\n * @param document      - The document used to create the copy\r\n */\r\nexport default function cloneNode<TNode extends Node>(\r\n\tnode: TNode,\r\n\tcloneChildren: boolean,\r\n\tdocument?: Document\r\n): TNode {\r\n\t// 1. If document is not given, let document be node’s node document.\r\n\tif (!document) {\r\n\t\tdocument = getNodeDocument(node);\r\n\t}\r\n\r\n\t// 2. If node is an element, then:\r\n\t// 2.1. Let copy be the result of creating an element, given document, node’s local name, node’s\r\n\t// namespace, node’s namespace prefix, and node’s is value, with the synchronous custom elements\r\n\t// flag unset.\r\n\t// 2.2. For each attribute in node’s attribute list:\r\n\t// 2.2.1. Let copyAttribute be a clone of attribute.\r\n\t// 2.2.2. Append copyAttribute to copy.\r\n\t// 3. Otherwise, let copy be a node that implements the same interfaces as node, and fulfills\r\n\t// these additional requirements, switching on node:\r\n\t// Document: Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\r\n\t// DocumentType: Set copy’s name, public ID, and system ID, to those of node.\r\n\t// Attr: Set copy’s namespace, namespace prefix, local name, and value, to those of node.\r\n\t// Text, Comment: Set copy’s data, to that of node.\r\n\t// ProcessingInstruction: Set copy’s target and data to those of node.\r\n\t// Any other node: —\r\n\t// 4. Set copy’s node document and document to copy, if copy is a document, and set copy’s node\r\n\t// document to document otherwise.\r\n\t// (all handled by _copy method)\r\n\tlet copy = node._copy(document) as TNode;\r\n\r\n\t// 5. Run any cloning steps defined for node in other applicable specifications and pass copy,\r\n\t// node, document and the clone children flag if set, as parameters.\r\n\t// (cloning steps not implemented)\r\n\r\n\t// 6. If the clone children flag is set, clone all the children of node and append them to copy,\r\n\t// with document as specified and the clone children flag being set.\r\n\tif (cloneChildren) {\r\n\t\tfor (let child = node.firstChild; child; child = child.nextSibling) {\r\n\t\t\tcopy.appendChild(cloneNode(child, true, document));\r\n\t\t}\r\n\t}\r\n\r\n\t// 7. Return copy.\r\n\treturn copy;\r\n}\r\n","export function expectArity(args: IArguments, minArity: number): void {\r\n\t// According to WebIDL overload resolution semantics, only a lower bound applies to the number\r\n\t// of arguments provided\r\n\tif (args.length < minArity) {\r\n\t\tthrow new TypeError(`Function should be called with at least ${minArity} arguments`);\r\n\t}\r\n}\r\n\r\nexport function expectObject<T>(value: T, Constructor: Function): void {\r\n\tif (!(value instanceof Constructor)) {\r\n\t\tthrow new TypeError(`Value should be an instance of ${Constructor.name}`);\r\n\t}\r\n}\r\n\r\nconst codeByName: Record<string, number> = {\r\n\tIndexSizeError: 1,\r\n\tHierarchyRequestError: 3,\r\n\tWrongDocumentError: 4,\r\n\tInvalidCharacterError: 5,\r\n\tNotFoundError: 8,\r\n\tNotSupportedError: 9,\r\n\tInUseAttributeError: 10,\r\n\tInvalidStateError: 11,\r\n\tNamespaceError: 14,\r\n\tInvalidNodeTypeError: 24,\r\n};\r\n\r\n/**\r\n * Exception type used for DOM errors\r\n *\r\n * @public\r\n */\r\nexport class DOMException extends Error {\r\n\tpublic readonly name: string;\r\n\tpublic readonly message: string;\r\n\tpublic readonly code: number;\r\n\tpublic readonly stack: string | undefined;\r\n\r\n\tconstructor(message: string = '', name: string = 'Error') {\r\n\t\tsuper(message);\r\n\r\n\t\tthis.message = message;\r\n\t\tthis.name = name;\r\n\t\tthis.code = codeByName[name] || 0;\r\n\t\tthis.stack = new Error(message).stack;\r\n\t}\r\n}\r\n\r\nfunction createDOMException(name: string, message: string): Error {\r\n\treturn new DOMException(`${name}: ${message}`, name);\r\n}\r\n\r\nexport function throwHierarchyRequestError(message: string): never {\r\n\tthrow createDOMException('HierarchyRequestError', message);\r\n}\r\n\r\nexport function throwIndexSizeError(message: string): never {\r\n\tthrow createDOMException('IndexSizeError', message);\r\n}\r\n\r\nexport function throwInUseAttributeError(message: string): never {\r\n\tthrow createDOMException('InUseAttributeError', message);\r\n}\r\n\r\nexport function throwInvalidCharacterError(message: string): never {\r\n\tthrow createDOMException('InvalidCharacterError', message);\r\n}\r\n\r\nexport function throwInvalidNodeTypeError(message: string): never {\r\n\tthrow createDOMException('InvalidNodeTypeError', message);\r\n}\r\n\r\nexport function throwInvalidStateError(message: string): never {\r\n\tthrow createDOMException('InvalidStateError', message);\r\n}\r\n\r\nexport function throwNamespaceError(message: string): never {\r\n\tthrow createDOMException('NamespaceError', message);\r\n}\r\n\r\nexport function throwNotFoundError(message: string): never {\r\n\tthrow createDOMException('NotFoundError', message);\r\n}\r\n\r\nexport function throwNotSupportedError(message: string): never {\r\n\tthrow createDOMException('NotSupportedError', message);\r\n}\r\n\r\nexport function throwWrongDocumentError(message: string): never {\r\n\tthrow createDOMException('WrongDocumentError', message);\r\n}\r\n","import Node from '../Node';\r\n\r\nexport interface MutationRecordInit {\r\n\tname?: string;\r\n\tnamespace?: string | null;\r\n\toldValue?: string | null;\r\n\taddedNodes?: Node[];\r\n\tremovedNodes?: Node[];\r\n\tpreviousSibling?: Node | null;\r\n\tnextSibling?: Node | null;\r\n}\r\n\r\n/**\r\n * 3.3.3. Interface MutationRecord\r\n *\r\n * A helper class which describes a specific mutation as it is observed by a MutationObserver.\r\n *\r\n * @public\r\n */\r\nexport default class MutationRecord {\r\n\t/**\r\n\t * Returns \"attributes\" if it was an attribute mutation. \"characterData\" if it was a mutation to\r\n\t * a CharacterData node. And \"childList\" if it was a mutation to the tree of nodes.\r\n\t */\r\n\tpublic type: string;\r\n\r\n\t/**\r\n\t * Returns the node the mutation affected, depending on the type. For \"attributes\", it is the\r\n\t * element whose attribute changed. For \"characterData\", it is the CharacterData node. For\r\n\t * \"childList\", it is the node whose children changed.\r\n\t */\r\n\tpublic target: Node;\r\n\r\n\t/**\r\n\t * Children of target added in this mutation.\r\n\t *\r\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\r\n\t * array.\r\n\t */\r\n\tpublic addedNodes: Node[] = [];\r\n\r\n\t/**\r\n\t * Children of target removed in this mutation.\r\n\t *\r\n\t * (non-standard) According to the spec this should be a NodeList. This implementation uses an\r\n\t * array.\r\n\t */\r\n\tpublic removedNodes: Node[] = [];\r\n\r\n\t/**\r\n\t * The previous sibling of the added or removed nodes, or null otherwise.\r\n\t */\r\n\tpublic previousSibling: Node | null = null;\r\n\r\n\t/**\r\n\t * The next sibling Node of the added or removed nodes, or null otherwise.\r\n\t */\r\n\tpublic nextSibling: Node | null = null;\r\n\r\n\t/**\r\n\t * The local name of the changed attribute, or null otherwise.\r\n\t */\r\n\tpublic attributeName: string | null = null;\r\n\r\n\t/**\r\n\t * The namespace of the changed attribute, or null otherwise.\r\n\t */\r\n\tpublic attributeNamespace: string | null = null;\r\n\r\n\t/**\r\n\t * The return value depends on type. For \"attributes\", it is the value of the changed attribute\r\n\t * before the change. For \"characterData\", it is the data of the changed node before the change.\r\n\t * For \"childList\", it is null.\r\n\t */\r\n\tpublic oldValue: string | null = null;\r\n\r\n\t/**\r\n\t * (non-standard) Constructs a MutationRecord\r\n\t *\r\n\t * @param type   - The value for the type property\r\n\t * @param target - The value for the target property\r\n\t */\r\n\tconstructor(type: string, target: Node) {\r\n\t\tthis.type = type;\r\n\t\tthis.target = target;\r\n\t}\r\n}\r\n","import { getContext } from '../context/Context';\r\nimport MutationObserver from './MutationObserver';\r\nimport { MutationRecordInit, default as MutationRecord } from './MutationRecord';\r\nimport Node from '../Node';\r\n\r\n/**\r\n * 3.3.2. Queuing a mutation record\r\n *\r\n * To queue a mutation record of type for target with name, namespace, oldValue, addedNodes,\r\n * removedNodes, previousSibling and nextSibling, run these steps:\r\n * namespace namespace, oldValue oldValue, addedNodes addedNodes, removedNodes removedNodes,\r\n *\r\n * To queue a tree mutation record for target with addedNodes, removedNodes, previousSibling, and\r\n * nextSibling, run these steps:\r\n *  - Assert: either addedNodes or removedNodes is not empty.\r\n *  - Queue a mutation record of \"childList\" for target with null, null, null, addedNodes,\r\n *    removedNodes, previousSibling, and nextSibling.\r\n *\r\n * @param type   - The type of mutation record to queue\r\n * @param target - The target node\r\n * @param data   - The data for the mutation record\r\n */\r\nexport default function queueMutationRecord(type: string, target: Node, data: MutationRecordInit) {\r\n\t// 1. Let interested observers be an empty map\r\n\tconst interestedObservers: MutationObserver[] = [];\r\n\tconst pairedStrings: (string | null | undefined)[] = [];\r\n\r\n\t// 2. Let nodes be the inclusive ancestors of target.\r\n\t// 3. For each node in nodes, ...:\r\n\tfor (let node: Node | null = target; node; node = node.parentNode) {\r\n\t\tnode._registeredObservers.collectInterestedObservers(\r\n\t\t\ttype,\r\n\t\t\ttarget,\r\n\t\t\tdata,\r\n\t\t\tinterestedObservers,\r\n\t\t\tpairedStrings\r\n\t\t);\r\n\t}\r\n\r\n\tconst context = getContext(target);\r\n\r\n\t// 4. For each observer → mappedOldValue of interestedObservers:\r\n\tinterestedObservers.forEach((observer, index) => {\r\n\t\tconst mappedOldValue = pairedStrings[index];\r\n\r\n\t\t// 4.1. Let record be a new MutationRecord object with its type set to type and target set\r\n\t\t// to target,\r\n\t\tconst record = new MutationRecord(type, target);\r\n\r\n\t\t// ...attributeName set to to name, attributeNamespace set to namespace...\r\n\t\tif (data.name !== undefined && data.namespace !== undefined) {\r\n\t\t\trecord.attributeName = data.name;\r\n\t\t\trecord.attributeNamespace = data.namespace;\r\n\t\t}\r\n\r\n\t\t// ...oldValue set to mappedOldValue...\r\n\t\tif (mappedOldValue !== undefined) {\r\n\t\t\trecord.oldValue = mappedOldValue;\r\n\t\t}\r\n\r\n\t\t// ...addedNodes set to addedNodes...\r\n\t\tif (data.addedNodes !== undefined) {\r\n\t\t\trecord.addedNodes = data.addedNodes;\r\n\t\t}\r\n\r\n\t\t// ...removedNodes set to removedNodes...\r\n\t\tif (data.removedNodes !== undefined) {\r\n\t\t\trecord.removedNodes = data.removedNodes;\r\n\t\t}\r\n\r\n\t\t// ...previousSibling set to previousSibling...\r\n\t\tif (data.previousSibling !== undefined) {\r\n\t\t\trecord.previousSibling = data.previousSibling;\r\n\t\t}\r\n\r\n\t\t// ...and nextSibling set to nextSibling.\r\n\t\tif (data.nextSibling !== undefined) {\r\n\t\t\trecord.nextSibling = data.nextSibling;\r\n\t\t}\r\n\r\n\t\t// 4.2. Enqueue record to observer’s record queue.\r\n\t\tcontext._notifySet.appendRecord(observer, record);\r\n\t});\r\n\r\n\t// 5. Queue a mutation observer microtask.\r\n\tcontext._notifySet.queueMutationObserverMicrotask();\r\n}\r\n","import CharacterData from './CharacterData';\r\nimport Document from './Document';\r\nimport DocumentFragment from './DocumentFragment';\r\nimport Element from './Element';\r\nimport Node from './Node';\r\n\r\nimport { NodeType, isNodeOfType } from './util/NodeType';\r\n\r\n/**\r\n * 3.2.4. Mixin NonElementParentNode\r\n */\r\nexport interface NonElementParentNode {}\r\n// Document implements NonElementParentNode;\r\n// DocumentFragment implements NonElementParentNode;\r\n\r\n/**\r\n * 3.2.6. Mixin ParentNode\r\n */\r\nexport interface ParentNode {\r\n\treadonly children: Element[];\r\n\r\n\tfirstElementChild: Element | null;\r\n\tlastElementChild: Element | null;\r\n\tchildElementCount: number;\r\n\r\n\tprepend(...nodes: (Node | string)[]): void;\r\n\tappend(...nodes: (Node | string)[]): void;\r\n\treplaceChildren(...nodes: (Node | string)[]): void;\r\n}\r\n// Document implements ParentNode;\r\n// DocumentFragment implements ParentNode;\r\n// Element implements ParentNode;\r\n\r\nexport function asParentNode(node: Node): ParentNode | null {\r\n\t// This is only called from treeMutations.js, where node can never be anything other than these\r\n\t/* istanbul ignore else */\r\n\tif (\r\n\t\tisNodeOfType(\r\n\t\t\tnode,\r\n\t\t\tNodeType.ELEMENT_NODE,\r\n\t\t\tNodeType.DOCUMENT_NODE,\r\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE\r\n\t\t)\r\n\t) {\r\n\t\treturn node as Element | Document | DocumentFragment;\r\n\t}\r\n\r\n\t/* istanbul ignore next */\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * Returns the element children of node.\r\n *\r\n * (Non-standard) According to the spec, the children getter should return a live HTMLCollection.\r\n * This implementation returns a static array instead.\r\n *\r\n * @param node - The node to get element children of\r\n *\r\n * @returns The\r\n */\r\nexport function getChildren(node: ParentNode): Element[] {\r\n\tconst elements: Element[] = [];\r\n\tfor (let child = node.firstElementChild; child; child = child.nextElementSibling) {\r\n\t\telements.push(child);\r\n\t}\r\n\treturn elements;\r\n}\r\n\r\n/**\r\n * 3.2.7. Mixin NonDocumentTypeChildNode\r\n */\r\nexport interface NonDocumentTypeChildNode {\r\n\treadonly previousElementSibling: Element | null;\r\n\treadonly nextElementSibling: Element | null;\r\n}\r\n// Element implements NonDocumentTypeChildNode;\r\n// CharacterData implements NonDocumentTypeChildNode;\r\n\r\nexport function asNonDocumentTypeChildNode(node: Node): NonDocumentTypeChildNode | null {\r\n\tif (\r\n\t\tisNodeOfType(\r\n\t\t\tnode,\r\n\t\t\tNodeType.ELEMENT_NODE,\r\n\t\t\tNodeType.COMMENT_NODE,\r\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\r\n\t\t\tNodeType.TEXT_NODE,\r\n\t\t\tNodeType.CDATA_SECTION_NODE\r\n\t\t)\r\n\t) {\r\n\t\treturn node as Element | CharacterData;\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\nexport function getPreviousElementSibling(node: Node): Element | null {\r\n\tfor (let sibling = node.previousSibling; sibling; sibling = sibling.previousSibling) {\r\n\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\r\n\t\t\treturn sibling as Element;\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\nexport function getNextElementSibling(node: Node): Element | null {\r\n\tfor (let sibling = node.nextSibling; sibling; sibling = sibling.nextSibling) {\r\n\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\r\n\t\t\treturn sibling as Element;\r\n\t\t}\r\n\t}\r\n\r\n\treturn null;\r\n}\r\n\r\n/**\r\n * 3.2.8. Mixin ChildNode\r\n */\r\nexport interface ChildNode {\r\n\tbefore(...nodes: (Node | string)[]): void;\r\n\tafter(...nodes: (Node | string)[]): void;\r\n\treplaceWith(...nodes: (Node | string)[]): void;\r\n\tremove(): void;\r\n}\r\n// DocumentType implements ChildNode;\r\n// Element implements ChildNode;\r\n// CharacterData implements ChildNode;\r\n","import { getContext } from '../context/Context';\r\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\r\nimport { throwHierarchyRequestError, throwNotFoundError } from './errorHelpers';\r\nimport { NodeType, isNodeOfType, isTextNode } from './NodeType';\r\nimport {\r\n\tgetNodeDocument,\r\n\tgetNodeIndex,\r\n\tforEachInclusiveDescendant,\r\n\tdetermineLengthOfNode,\r\n} from './treeHelpers';\r\nimport { insertIntoChildren, removeFromChildren } from './treeMutations';\r\nimport Document from '../Document';\r\nimport DocumentFragment from '../DocumentFragment';\r\nimport Element from '../Element';\r\nimport { ParentNode, ChildNode } from '../mixins';\r\nimport Node from '../Node';\r\nimport Range from '../Range';\r\nimport Text from '../Text';\r\n\r\n// 3.2.3. Mutation algorithms\r\n\r\n/**\r\n * To ensure pre-insertion validity of a node into a parent before a child, run these steps:\r\n */\r\nfunction ensurePreInsertionValidity(node: Node, parent: Node, child: Node | null): void {\r\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\r\n\t// HierarchyRequestError.\r\n\tif (\r\n\t\t!isNodeOfType(\r\n\t\t\tparent,\r\n\t\t\tNodeType.DOCUMENT_NODE,\r\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\r\n\t\t\tNodeType.ELEMENT_NODE\r\n\t\t)\r\n\t) {\r\n\t\tthrowHierarchyRequestError('parent must be a Document, DocumentFragment or Element node');\r\n\t}\r\n\r\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\r\n\tif (node.contains(parent)) {\r\n\t\tthrowHierarchyRequestError('node must not be an inclusive ancestor of parent');\r\n\t}\r\n\r\n\t// 3. If child is non-null and its parent is not parent, then throw a NotFoundError.\r\n\tif (child && child.parentNode !== parent) {\r\n\t\tthrowNotFoundError('child is not a child of parent');\r\n\t}\r\n\r\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\r\n\t// Comment node, throw a HierarchyRequestError.\r\n\tif (\r\n\t\t!isNodeOfType(\r\n\t\t\tnode,\r\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\r\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\r\n\t\t\tNodeType.ELEMENT_NODE,\r\n\t\t\tNodeType.TEXT_NODE,\r\n\t\t\tNodeType.CDATA_SECTION_NODE,\r\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\r\n\t\t\tNodeType.COMMENT_NODE\r\n\t\t)\r\n\t) {\r\n\t\tthrowHierarchyRequestError(\r\n\t\t\t'node must be a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction ' +\r\n\t\t\t\t'or Comment node'\r\n\t\t);\r\n\t}\r\n\r\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\r\n\t// not a document, throw a HierarchyRequestError.\r\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\r\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\r\n\t}\r\n\tif (\r\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\r\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\r\n\t) {\r\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\r\n\t}\r\n\r\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\r\n\t// throw a HierarchyRequestError.\r\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\r\n\t\tconst parentDocument = parent as Document;\r\n\t\tswitch (node.nodeType) {\r\n\t\t\t// DocumentFragment node\r\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\r\n\t\t\t\t// If node has more than one element child or has a Text node child.\r\n\t\t\t\tconst fragment = node as DocumentFragment;\r\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'can not insert more than one element under a Document'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\r\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\r\n\t\t\t\t}\r\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child,\r\n\t\t\t\t// child is a doctype, or child is non-null and a doctype is following child.\r\n\t\t\t\tif (\r\n\t\t\t\t\tfragment.firstElementChild &&\r\n\t\t\t\t\t(parentDocument.documentElement ||\r\n\t\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\r\n\t\t\t\t\t\t(child &&\r\n\t\t\t\t\t\t\tparentDocument.doctype &&\r\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\r\n\t\t\t\t\t\t\t'element'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t// element\r\n\t\t\tcase NodeType.ELEMENT_NODE:\r\n\t\t\t\t// parent has an element child, child is a doctype, or child is non-null and a\r\n\t\t\t\t// doctype is following child.\r\n\t\t\t\tif (\r\n\t\t\t\t\tparentDocument.documentElement ||\r\n\t\t\t\t\t(child && isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) ||\r\n\t\t\t\t\t(child &&\r\n\t\t\t\t\t\tparentDocument.doctype &&\r\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\r\n\t\t\t\t\t\t\t'element'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t// doctype\r\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\r\n\t\t\t\t// parent has a doctype child, child is non-null and an element is preceding child,\r\n\t\t\t\t// or child is null and parent has an element child.\r\n\t\t\t\tif (\r\n\t\t\t\t\tparentDocument.doctype ||\r\n\t\t\t\t\t(child &&\r\n\t\t\t\t\t\tparentDocument.documentElement &&\r\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child)) ||\r\n\t\t\t\t\t(!child && parentDocument.documentElement)\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\r\n\t\t\t\t\t\t\t'element'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * To pre-insert a node into a parent before a child, run these steps:\r\n *\r\n * @param node   - Node to pre-insert\r\n * @param parent - Parent to insert under\r\n * @param child  - Child to insert before, or null to insert at the end of parent\r\n *\r\n * @returns The inserted node\r\n */\r\nexport function preInsertNode<TNode extends Node>(\r\n\tnode: TNode,\r\n\tparent: Node,\r\n\tchild: Node | null\r\n): TNode {\r\n\t// 1. Ensure pre-insertion validity of node into parent before child.\r\n\tensurePreInsertionValidity(node, parent, child);\r\n\r\n\t// 2. Let referenceChild be child.\r\n\tlet referenceChild = child;\r\n\r\n\t// 3. If referenceChild is node, set it to node’s next sibling.\r\n\tif (referenceChild === node) {\r\n\t\treferenceChild = node.nextSibling;\r\n\t}\r\n\r\n\t// 4. Adopt node into parent's node document.\r\n\tadoptNode(node, getNodeDocument(parent));\r\n\r\n\t// 5. Insert node into parent before referenceChild.\r\n\tinsertNode(node, parent, referenceChild);\r\n\r\n\t// 6. Return node.\r\n\treturn node;\r\n}\r\n\r\n/**\r\n * To insert a node into a parent before a child, with an optional suppress observers flag, run\r\n * these steps:\r\n *\r\n * @param node              - Node to insert\r\n * @param parent            - Parent to insert under\r\n * @param child             - Child to insert before, or null to insert at end of parent\r\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\r\n */\r\nexport function insertNode(\r\n\tnode: Node,\r\n\tparent: Node,\r\n\tchild: Node | null,\r\n\tsuppressObservers: boolean = false\r\n): void {\r\n\t// 1. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\r\n\tconst isDocumentFragment = isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE);\r\n\tconst nodes = isDocumentFragment ? Array.from(node.childNodes) : [node];\r\n\r\n\t// 2. Let count be nodes's size.\r\n\tconst count = nodes.length;\r\n\r\n\t// 3. If count is 0, then return.\r\n\tif (count === 0) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 4. If node is a DocumentFragment node, then:\r\n\tif (isDocumentFragment) {\r\n\t\t// 4.1 Remove its children with the suppress observers flag set.\r\n\t\tnodes.forEach((n) => removeNode(n, true));\r\n\r\n\t\t// 4.2 Queue a tree mutation record for node with « », nodes, null, and null.\r\n\t\t// Note: This step intentionally does not pay attention to the suppress observers flag.\r\n\t\tqueueMutationRecord('childList', node, {\r\n\t\t\tremovedNodes: nodes,\r\n\t\t});\r\n\t}\r\n\r\n\t// 5. If child is non-null, then:\r\n\tif (child !== null) {\r\n\t\tconst childIndex = getNodeIndex(child);\r\n\t\tconst context = getContext(node);\r\n\t\tcontext.forEachRange((range) => {\r\n\t\t\t// 2.1. For each live range whose start node is parent and start offset is greater than\r\n\t\t\t// child’s index, increase its start offset by count.\r\n\t\t\tif (range.startContainer === parent && range.startOffset > childIndex) {\r\n\t\t\t\trange.startOffset += count;\r\n\t\t\t}\r\n\r\n\t\t\t// 2.2. For each live range whose end node is parent and end offset is greater than\r\n\t\t\t// child’s index, increase its end offset by count.\r\n\t\t\tif (range.endContainer === parent && range.endOffset > childIndex) {\r\n\t\t\t\trange.endOffset += count;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// 6. Let previousSibling be child’s previous sibling or parent’s last child if child is null.\r\n\tlet previousSibling = child === null ? parent.lastChild : child.previousSibling;\r\n\r\n\t// 7. For each node in nodes, in tree order:\r\n\tnodes.forEach((node) => {\r\n\t\t// 7.1. If child is null, then append node to parent’s children.\r\n\t\t// 7.2. Otherwise, insert node into parent’s children before child’s index.\r\n\t\tinsertIntoChildren(node, parent, child);\r\n\r\n\t\t// 7.3. If parent is a shadow host and node is a slottable, then assign a slot for node.\r\n\t\t// (shadow dom not implemented)\r\n\r\n\t\t// 7.4. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the\r\n\t\t// empty list, then run signal a slot change for parent.\r\n\t\t// 7.5. Run assign slottables for a tree with node’s tree.\r\n\t\t// (shadow dom not implemented)\r\n\r\n\t\t// 7.6. For each shadow-including inclusive descendant inclusiveDescendant of node, in\r\n\t\t// shadow-including tree order:\r\n\t\t// 7.6.1. Run the insertion steps with inclusiveDescendant.\r\n\t\t// (insertion steps not implemented)\r\n\r\n\t\t// 7.6.2. If inclusiveDescendant is connected, then:\r\n\t\t// 7.6.2.1. If inclusiveDescendant is custom, then enqueue a custom element callback\r\n\t\t// reaction with inclusiveDescendant, callback name \"connectedCallback\", and an empty\r\n\t\t// argument list.\r\n\t\t// 7.6.2.2. Otherwise, try to upgrade inclusiveDescendant. If this successfully upgrades\r\n\t\t// inclusiveDescendant, its connectedCallback will be enqueued automatically during the\r\n\t\t// upgrade an element algorithm.\r\n\t\t// (custom elements not implemented)\r\n\t});\r\n\r\n\t// 8. If suppress observers flag is unset, queue a tree mutation record for parent with nodes,\r\n\t// « », previousSibling and child.\r\n\tif (!suppressObservers) {\r\n\t\tqueueMutationRecord('childList', parent, {\r\n\t\t\taddedNodes: nodes,\r\n\t\t\tnextSibling: child,\r\n\t\t\tpreviousSibling: previousSibling,\r\n\t\t});\r\n\t}\r\n\r\n\t// 9. Run the children changed steps for parent\r\n\t// (children changed steps not implemented)\r\n}\r\n\r\n/**\r\n * To append a node to a parent\r\n *\r\n * @param node   - Node to append\r\n * @param parent - Parent to append to\r\n *\r\n * @returns The appended node\r\n */\r\nexport function appendNode<TNode extends Node>(node: TNode, parent: Node): TNode {\r\n\t// pre-insert node into parent before null.\r\n\treturn preInsertNode(node, parent, null);\r\n}\r\n\r\n/**\r\n * To replace a child with node within a parent, run these steps:\r\n *\r\n * @param child  - The child node to replace\r\n * @param node   - The node to replace child with\r\n * @param parent - The parent to replace under\r\n *\r\n * @returns The old child node\r\n */\r\nexport function replaceChildWithNode<TChild extends Node>(\r\n\tchild: TChild,\r\n\tnode: Node,\r\n\tparent: Node\r\n): TChild {\r\n\t// 1. If parent is not a Document, DocumentFragment, or Element node, throw a\r\n\t// HierarchyRequestError.\r\n\tif (\r\n\t\t!isNodeOfType(\r\n\t\t\tparent,\r\n\t\t\tNodeType.DOCUMENT_NODE,\r\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\r\n\t\t\tNodeType.ELEMENT_NODE\r\n\t\t)\r\n\t) {\r\n\t\tthrowHierarchyRequestError('Can not replace under a non-parent node');\r\n\t}\r\n\r\n\t// 2. If node is a host-including inclusive ancestor of parent, throw a HierarchyRequestError.\r\n\tif (node.contains(parent)) {\r\n\t\tthrowHierarchyRequestError('Can not insert a node under its own descendant');\r\n\t}\r\n\r\n\t// 3. If child’s parent is not parent, then throw a NotFoundError.\r\n\tif (child.parentNode !== parent) {\r\n\t\tthrowNotFoundError('child is not a child of parent');\r\n\t}\r\n\r\n\t// 4. If node is not a DocumentFragment, DocumentType, Element, Text, ProcessingInstruction, or\r\n\t// Comment node, throw a HierarchyRequestError.\r\n\tif (\r\n\t\t!isNodeOfType(\r\n\t\t\tnode,\r\n\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE,\r\n\t\t\tNodeType.DOCUMENT_TYPE_NODE,\r\n\t\t\tNodeType.ELEMENT_NODE,\r\n\t\t\tNodeType.TEXT_NODE,\r\n\t\t\tNodeType.CDATA_SECTION_NODE,\r\n\t\t\tNodeType.PROCESSING_INSTRUCTION_NODE,\r\n\t\t\tNodeType.COMMENT_NODE\r\n\t\t)\r\n\t) {\r\n\t\tthrowHierarchyRequestError(\r\n\t\t\t\"Can not insert a node that isn't a DocumentFragment, DocumentType, Element, Text, \" +\r\n\t\t\t\t'ProcessingInstruction or Comment'\r\n\t\t);\r\n\t}\r\n\r\n\t// 5. If either node is a Text node and parent is a document, or node is a doctype and parent is\r\n\t// not a document, throw a HierarchyRequestError.\r\n\tif (isNodeOfType(node, NodeType.TEXT_NODE) && isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\r\n\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\r\n\t}\r\n\tif (\r\n\t\tisNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE) &&\r\n\t\t!isNodeOfType(parent, NodeType.DOCUMENT_NODE)\r\n\t) {\r\n\t\tthrowHierarchyRequestError('can only insert a DocumentType node under a Document');\r\n\t}\r\n\r\n\t// 6. If parent is a document, and any of the statements below, switched on node, are true,\r\n\t// throw a HierarchyRequestError.\r\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\r\n\t\tconst parentDocument = parent as Document;\r\n\t\tswitch (node.nodeType) {\r\n\t\t\t// DocumentFragment node\r\n\t\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\r\n\t\t\t\t// If node has more than one element child or has a Text node child.\r\n\t\t\t\tconst fragment = node as DocumentFragment;\r\n\t\t\t\tif (fragment.firstElementChild !== fragment.lastElementChild) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'can not insert more than one element under a Document'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tif (\r\n\t\t\t\t\tArray.from(fragment.childNodes).some((child) =>\r\n\t\t\t\t\t\tisNodeOfType(child, NodeType.TEXT_NODE)\r\n\t\t\t\t\t)\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError('can not insert a Text node under a Document');\r\n\t\t\t\t}\r\n\t\t\t\t// Otherwise, if node has one element child and either parent has an element child\r\n\t\t\t\t// that is not child or a doctype is following child.\r\n\t\t\t\tif (\r\n\t\t\t\t\tfragment.firstElementChild &&\r\n\t\t\t\t\t((parentDocument.documentElement &&\r\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\r\n\t\t\t\t\t\t(child &&\r\n\t\t\t\t\t\t\tparentDocument.doctype &&\r\n\t\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype)))\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\r\n\t\t\t\t\t\t\t'element'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t// element\r\n\t\t\tcase NodeType.ELEMENT_NODE:\r\n\t\t\t\t// parent has an element child that is not child or a doctype is following child.\r\n\t\t\t\tif (\r\n\t\t\t\t\t(parentDocument.documentElement &&\r\n\t\t\t\t\t\tparentDocument.documentElement !== (child as Node)) ||\r\n\t\t\t\t\t(parentDocument.doctype &&\r\n\t\t\t\t\t\tgetNodeIndex(child) < getNodeIndex(parentDocument.doctype))\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\r\n\t\t\t\t\t\t\t'element'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t// doctype\r\n\t\t\tcase NodeType.DOCUMENT_TYPE_NODE:\r\n\t\t\t\t// parent has a doctype child that is not child, or an element is preceding child.\r\n\t\t\t\tif (\r\n\t\t\t\t\t(parentDocument.doctype && parentDocument.doctype !== (child as Node)) ||\r\n\t\t\t\t\t(parentDocument.documentElement &&\r\n\t\t\t\t\t\tgetNodeIndex(parentDocument.documentElement) < getNodeIndex(child))\r\n\t\t\t\t) {\r\n\t\t\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\t\t\t'Document should contain at most one doctype, followed by at most one ' +\r\n\t\t\t\t\t\t\t'element'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\t\t// The above statements differ from the pre-insert algorithm.\r\n\t}\r\n\r\n\t// 7. Let referenceChild be child’s next sibling.\r\n\tlet referenceChild = child.nextSibling;\r\n\r\n\t// 8. If referenceChild is node, set it to node’s next sibling.\r\n\tif (referenceChild === node) {\r\n\t\treferenceChild = node.nextSibling;\r\n\t}\r\n\r\n\t// 9. Let previousSibling be child’s previous sibling.\r\n\tconst previousSibling = child.previousSibling;\r\n\r\n\t// 10. Adopt node into parent's node document\r\n\tadoptNode(node, getNodeDocument(parent));\r\n\r\n\t// 11. Let removedNodes be the empty set.\r\n\tlet removedNodes: Node[] = [];\r\n\r\n\t// 12. If child’s parent is non-null, then:\r\n\tif (child.parentNode !== null) {\r\n\t\t// 11.1. Set removedNodes to « child ».\r\n\t\tremovedNodes.push(child);\r\n\r\n\t\t// 11.2. Remove child with the suppress observers flag set.\r\n\t\tremoveNode(child, true);\r\n\t}\r\n\t// The above can only be false if child is node.\r\n\r\n\t// 13. Let nodes be node’s children if node is a DocumentFragment node; otherwise « node ».\r\n\tconst nodes = isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)\r\n\t\t? Array.from(node.childNodes)\r\n\t\t: [node];\r\n\r\n\t// 14. Insert node into parent before referenceChild with the suppress observers flag set.\r\n\tinsertNode(node, parent, referenceChild, true);\r\n\r\n\t// 15. Queue a tree mutation record for parent with nodes, removedNodes, previousSibling and\r\n\t// referenceChild.\r\n\tqueueMutationRecord('childList', parent, {\r\n\t\taddedNodes: nodes,\r\n\t\tremovedNodes: removedNodes,\r\n\t\tnextSibling: referenceChild,\r\n\t\tpreviousSibling: previousSibling,\r\n\t});\r\n\r\n\t// 16. Return child.\r\n\treturn child;\r\n}\r\n\r\n/**\r\n * To replace all with a node within a parent, run these steps:\r\n *\r\n * @param node   New node to insert, or null to remove all nodes under parent\r\n * @param parent Parent to replace under\r\n */\r\nexport function replaceAllWithNode(node: Node | null, parent: Node): void {\r\n\t// 1. If node is non-null, then adopt node into parent's node document\r\n\tif (node !== null) {\r\n\t\tadoptNode(node, getNodeDocument(parent));\r\n\t}\r\n\r\n\t// 2. Let removedNodes be parent’s children.\r\n\tconst removedNodes = Array.from(parent.childNodes);\r\n\r\n\t// 3. Let addedNodes be the empty set.\r\n\tlet addedNodes: Node[] = [];\r\n\r\n\tif (node !== null) {\r\n\t\t// 4. If node is a DocumentFragment node, then set addedNodes to node's children.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)) {\r\n\t\t\tnode.childNodes.forEach((child) => {\r\n\t\t\t\taddedNodes.push(child);\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\t// 5. Otherwise, if node is non-null, set addedNodes to « node ».\r\n\t\t\taddedNodes.push(node);\r\n\t\t}\r\n\t}\r\n\r\n\t// 6. Remove all parent’s children, in tree order, with the suppress observers flag set.\r\n\tremovedNodes.forEach((child) => {\r\n\t\tremoveNode(child, true);\r\n\t});\r\n\r\n\t// 7. If node is non-null, then insert node into parent before null with the suppress observers\r\n\t// flag set.\r\n\tif (node !== null) {\r\n\t\tinsertNode(node, parent, null, true);\r\n\t}\r\n\r\n\t// 8. If either addedNodes or removedNodes is not empty, then queue a tree mutation record for\r\n\t// parent with addedNodes, removedNodes, null, and null.\r\n\tif (addedNodes.length > 0 || removedNodes.length > 0) {\r\n\t\tqueueMutationRecord('childList', parent, {\r\n\t\t\taddedNodes,\r\n\t\t\tremovedNodes,\r\n\t\t});\r\n\t}\r\n\r\n\t// This algorithm does not make any checks with regards to the node tree constraints.\r\n\t// Specification authors need to use it wisely.\r\n}\r\n\r\n/**\r\n * To pre-remove a child from a parent, run these steps:\r\n *\r\n * @param child  - Child node to remove\r\n * @param parent - Parent under which to remove child\r\n *\r\n * @returns The removed child\r\n */\r\nexport function preRemoveChild<TChild extends Node>(child: TChild, parent: Node): TChild {\r\n\t// 1. If child’s parent is not parent, then throw a NotFoundError.\r\n\tif (child.parentNode !== parent) {\r\n\t\tthrowNotFoundError('child is not a child of parent');\r\n\t}\r\n\r\n\t// 2. Remove child.\r\n\tremoveNode(child);\r\n\r\n\t// 3. Return child.\r\n\treturn child;\r\n}\r\n\r\n/**\r\n * To remove a node, with an optional suppress observers flag, run these steps:\r\n *\r\n * @param node              - Child to remove\r\n * @param suppressObservers - Whether to skip enqueueing a mutation record for this mutation\r\n */\r\nexport function removeNode(node: Node, suppressObservers: boolean = false): void {\r\n\t// 1. Let parent be node's parent\r\n\t// 2. Assert: parent is non-null.\r\n\tconst parent = node.parentNode!;\r\n\r\n\t// 3. Let index be node’s index.\r\n\tconst index = getNodeIndex(node);\r\n\r\n\tconst context = getContext(node);\r\n\tcontext.forEachRange((range) => {\r\n\t\t// 4. For each live range whose start node is an inclusive descendant of node, set its start\r\n\t\t// to (parent, index).\r\n\t\tif (node.contains(range.startContainer)) {\r\n\t\t\trange.startContainer = parent;\r\n\t\t\trange.startOffset = index;\r\n\t\t}\r\n\r\n\t\t// 5. For each live range whose end node is an inclusive descendant of node, set its end to\r\n\t\t// (parent, index).\r\n\t\tif (node.contains(range.endContainer)) {\r\n\t\t\trange.endContainer = parent;\r\n\t\t\trange.endOffset = index;\r\n\t\t}\r\n\r\n\t\t// 6. For each live range whose start node is parent and start offset is greater than index,\r\n\t\t// decrease its start offset by one.\r\n\t\tif (range.startContainer === parent && range.startOffset > index) {\r\n\t\t\trange.startOffset -= 1;\r\n\t\t}\r\n\r\n\t\t// 7. For each live range whose end node is parent and end offset is greater than index,\r\n\t\t// decrease its end offset by one.\r\n\t\tif (range.endContainer === parent && range.endOffset > index) {\r\n\t\t\trange.endOffset -= 1;\r\n\t\t}\r\n\t});\r\n\r\n\t// 8. For each NodeIterator object iterator whose root’s node document is node’s node document,\r\n\t// run the NodeIterator pre-removing steps given node and iterator.\r\n\t// (NodeIterator not implemented)\r\n\r\n\t// 9. Let oldPreviousSibling be node’s previous sibling.\r\n\tconst oldPreviousSibling = node.previousSibling;\r\n\r\n\t// 10. Let oldNextSibling be node’s next sibling.\r\n\tconst oldNextSibling = node.nextSibling;\r\n\r\n\t// 11. Remove node from its parent’s children.\r\n\tremoveFromChildren(node, parent);\r\n\r\n\t// 12. If node is assigned, then run assign slottables for node’s assigned slot.\r\n\t// (shadow dom not implemented)\r\n\r\n\t// 13. If parent's root is a shadow root, and parent is a slot whose assigned nodes is the empty\r\n\t// list, then run signal a slot change for parent.\r\n\t// (shadow dom not implemented)\r\n\r\n\t// 14. If node has an inclusive descendant that is a slot, then:\r\n\t// 14.1. Run assign slottables for a tree with parent’s tree.\r\n\t// 14.2. Run assign slottables for a tree with node’s tree.\r\n\t// (shadow dom not implemented)\r\n\r\n\t// 15. Run the removing steps with node and parent.\r\n\t// (removing steps not implemented)\r\n\r\n\t// 16. Let isParentConnected be parent's connected.\r\n\t// 17. If node is custom and isParentConnected is true, then enqueue a custom element callback\r\n\t// reaction with node, callback name \"disconnectedCallback\", and an empty argument list.\r\n\t// It is intentional for now that custom elements do not get parent passed. This might change in\r\n\t// the future if there is a need.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 18. For each shadow-including descendant descendant of node, in shadow-including tree order,\r\n\t// then:\r\n\t// 18.1. Run the removing steps with descendant.\r\n\t// (shadow dom not implemented)\r\n\r\n\t// 18.2. If descendant is custom and isParentConnected is true, then enqueue a custom element\r\n\t// callback reaction with descendant, callback name \"disconnectedCallback\", and an empty\r\n\t// argument list.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 19. For each inclusive ancestor inclusiveAncestor of parent, and then for each registered of\r\n\t// inclusiveAncestor's registered observer list, if registered's options's subtree is true, then\r\n\t// append a new transient registered observer whose observer is registered's observer, options\r\n\t// is registered's options, and source is registered to node's registered observer list.\r\n\tfor (\r\n\t\tlet inclusiveAncestor: Node | null = parent;\r\n\t\tinclusiveAncestor;\r\n\t\tinclusiveAncestor = inclusiveAncestor.parentNode\r\n\t) {\r\n\t\tinclusiveAncestor._registeredObservers.appendTransientRegisteredObservers(node);\r\n\t}\r\n\r\n\t// 20. If suppress observers flag is unset, queue a tree mutation record for parent with « »,\r\n\t// « node », oldPreviousSibling, and oldNextSibling\r\n\tif (!suppressObservers) {\r\n\t\tqueueMutationRecord('childList', parent, {\r\n\t\t\tremovedNodes: [node],\r\n\t\t\tnextSibling: oldNextSibling,\r\n\t\t\tpreviousSibling: oldPreviousSibling,\r\n\t\t});\r\n\t}\r\n\r\n\t// 21. Run the children changed steps for parent\r\n\t// (children changed steps not implemented)\r\n}\r\n\r\n/**\r\n * 3.5. Interface Document\r\n *\r\n * To adopt a node into a document, with an optional forceDocumentFragmentAdoption, run these steps:\r\n *\r\n * (forceDocumentFragmentAdoption is only set to true for HTML template, so is not implemented here)\r\n *\r\n * @param node     - Node to adopt\r\n * @param document - Document to adopt node into\r\n */\r\nexport function adoptNode(node: Node, document: Document): void {\r\n\t// 1. If forceDocumentFragmentAdoption is not given, then set it false.\r\n\t// (value unused)\r\n\r\n\t// 2. Let oldDocument be node’s node document.\r\n\tconst oldDocument = getNodeDocument(node);\r\n\r\n\t// 2. If node’s parent is non-null, remove node.\r\n\tif (node.parentNode) {\r\n\t\tremoveNode(node);\r\n\t}\r\n\r\n\t// 3. If document is not oldDocument, then:\r\n\tif (document === oldDocument) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 3.1. For each inclusiveDescendant in node’s shadow-including inclusive descendants:\r\n\tforEachInclusiveDescendant(node, (inclusiveDescendant) => {\r\n\t\t// 3.1.1. If forceDocumentFragmentAdoption is false, inclusiveDescendant is a\r\n\t\t// DocumentFragment node, inclusiveDescendant is node, and node's host is non-null, then\r\n\t\t// continue\r\n\t\t// Note: this is only reasonable as long as all adopt callers remove the children of node.\r\n\t\t// (shadow dom and HTML templates not implemented)\r\n\r\n\t\t// 3.1.2. Set inclusiveDescendant’s node document to document.\r\n\t\t// (calling code ensures that node is never a Document)\r\n\t\tinclusiveDescendant.ownerDocument = document;\r\n\r\n\t\t// 3.1.3. If inclusiveDescendant is an element, then set the node document of each attribute\r\n\t\t// in inclusiveDescendant’s attribute list to document.\r\n\t\tif (isNodeOfType(inclusiveDescendant, NodeType.ELEMENT_NODE)) {\r\n\t\t\tfor (const attr of (inclusiveDescendant as Element).attributes) {\r\n\t\t\t\tattr.ownerDocument = document;\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\r\n\t// 3.2. For each inclusiveDescendant in node’s shadow-including inclusive descendants that is\r\n\t// custom, enqueue a custom element callback reaction with inclusiveDescendant, callback name\r\n\t// \"adoptedCallback\", and an argument list containing oldDocument and document.\r\n\t// (custom element support has not been implemented)\r\n\r\n\t// 3.3. For each inclusiveDescendant in node’s shadow-including inclusive descendants, in\r\n\t// shadow-including tree order, run the adopting steps with inclusiveDescendant and oldDocument.\r\n\t// (adopting steps not implemented)\r\n}\r\n\r\n/**\r\n * The descendant text content of a node node is the concatenation of the data of all the Text node\r\n * descendants of node, in tree order.\r\n *\r\n * @param node Root node\r\n *\r\n * @returns  The concatenation of data of all the Text node descendants of the given node, in tree\r\n *           order\r\n */\r\nexport function getDescendantTextContent(node: Node): string {\r\n\tconst data: string[] = [];\r\n\tforEachInclusiveDescendant(node, (descendant) => {\r\n\t\t// CDATASection is a subtype of Text\r\n\t\tif (!isNodeOfType(descendant, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tdata.push((descendant as Text).data);\r\n\t});\r\n\treturn data.join('');\r\n}\r\n\r\n/**\r\n * Implementation of the textContent setter for DocumentFragment and Element\r\n *\r\n * @param parent    Node for which to set textContent\r\n * @param newValue  New textContent value\r\n */\r\nexport function stringReplaceAll(parent: Node, newValue: string): void {\r\n\t// 1. Let node be null.\r\n\tlet node = null;\r\n\r\n\t// 2. If the given value is not the empty string, then set node to a new Text node whose data is\r\n\t// the given value and node document is parent’s node document.\r\n\tif (newValue !== '') {\r\n\t\tconst context = getContext(parent);\r\n\t\tnode = new context.Text(newValue);\r\n\t}\r\n\r\n\t// 3. Replace all with node within the this.\r\n\treplaceAllWithNode(node, parent);\r\n}\r\n\r\n/**\r\n * To convert nodes into a node, given nodes and document, run these steps:\r\n *\r\n * @param nodes    Nodes and/or strings to convert\r\n * @param document Document used to create new nodes\r\n *\r\n * @returns A single node representing nodes\r\n */\r\nfunction convertNodesIntoNode(nodes: (Node | string)[], document: Document): Node {\r\n\t// 1. Let node be null.\r\n\t// (created as needed in branches below)\r\n\r\n\t// 2. Replace each string in nodes with a new Text node whose data is the string and node\r\n\t// document is document.\r\n\tconst actualNodes: Node[] = nodes.map((nodeOrString) => {\r\n\t\t// IDL actually coerces every non-node (e.g., null) into a string here\r\n\t\tif (nodeOrString instanceof Node) {\r\n\t\t\treturn nodeOrString;\r\n\t\t}\r\n\t\treturn document.createTextNode(String(nodeOrString));\r\n\t});\r\n\r\n\t// 3. If nodes contains one node, set node to that node.\r\n\tif (actualNodes.length === 1) {\r\n\t\treturn actualNodes[0];\r\n\t} else {\r\n\t\t// 4. Otherwise, set node to a new DocumentFragment whose node document is document, and then\r\n\t\t// append each node in nodes, if any, to it.\r\n\t\tconst node = document.createDocumentFragment();\r\n\t\tactualNodes.forEach((child) => {\r\n\t\t\tnode.appendChild(child);\r\n\t\t});\r\n\t\treturn node;\r\n\t}\r\n\r\n\t// 5. Return node.\r\n\t// (done in branches above)\r\n}\r\n\r\n/**\r\n * The prepend(nodes) method, when invoked, must run these steps:\r\n *\r\n * @param thisObject - The ParentNode on which the method is invoked\r\n * @param nodes      - The nodes (and/or strings) to prepend\r\n */\r\nexport function prependNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\r\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\r\n\t// document.\r\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\r\n\r\n\t// 2. Pre-insert node into this before the this’s first child.\r\n\tpreInsertNode(node, thisObject, thisObject.firstChild);\r\n}\r\n\r\n/**\r\n * The append(nodes) method, when invoked, must run these steps:\r\n *\r\n * @param thisObject - The ParentNode on which the method is invoked\r\n * @param nodes      - The nodes (and/or strings) to append\r\n */\r\nexport function appendNodes(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\r\n\t// 1. Let node be the result of converting nodes into a node given nodes and this’s node\r\n\t// document.\r\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\r\n\r\n\t// 2. Append node to this\r\n\tappendNode(node, thisObject);\r\n}\r\n\r\n/**\r\n * The replaceChildren(nodes) method, when invoked, must run these steps:\r\n *\r\n * @param thisObject - The ParentNode on which the method is invoked\r\n * @param nodes      - The nodes (and/or strings) to replace the children with\r\n */\r\nexport function replaceChildren(thisObject: Node & ParentNode, nodes: (Node | string)[]): void {\r\n\t// 1. Let node be the result of converting nodes into a node given nodes and this's node\r\n\t// document.\r\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\r\n\r\n\t// 2. Ensure pre-insertion validity of node into this before null.\r\n\tensurePreInsertionValidity(node, thisObject, null);\r\n\r\n\t// 3. Replace all with node within this.\r\n\treplaceAllWithNode(node, thisObject);\r\n}\r\n\r\n/**\r\n * The before(nodes) method, when invoked, must run these steps:\r\n *\r\n * @param thisObject - The ChildNode on which the method is invoked\r\n * @param nodes        The nodes (and/or strings) to insert\r\n */\r\nexport function insertNodesBefore(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\r\n\t// 1. Let parent be this’s parent.\r\n\tconst parent = thisObject.parentNode;\r\n\r\n\t// 2. If parent is null, then return.\r\n\tif (parent === null) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 3. Let viablePreviousSibling be this’s first preceding sibling not in nodes, and\r\n\t// null otherwise.\r\n\tlet viablePreviousSibling = thisObject.previousSibling;\r\n\twhile (viablePreviousSibling !== null && nodes.indexOf(viablePreviousSibling) >= 0) {\r\n\t\tviablePreviousSibling = viablePreviousSibling.previousSibling;\r\n\t}\r\n\r\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\r\n\t// node document.\r\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\r\n\r\n\t// 5. If viablePreviousSibling is null, set it to parent’s first child, and to\r\n\t// viablePreviousSibling’s next sibling otherwise.\r\n\t// (it makes more sense to rename this as it will no longer be a previous sibling to the\r\n\t// inserted nodes)\r\n\tconst referenceNode =\r\n\t\tviablePreviousSibling === null ? parent.firstChild : viablePreviousSibling.nextSibling;\r\n\r\n\t// 6. Pre-insert node into parent before viablePreviousSibling.\r\n\tpreInsertNode(node, parent, referenceNode);\r\n}\r\n\r\n/**\r\n * The after(nodes) method, when invoked, must run these steps:\r\n *\r\n * @param thisObject - The ChildNode on which the method is invoked\r\n * @param nodes      - The nodes (and/or strings) to insert\r\n */\r\nexport function insertNodesAfter(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\r\n\t// 1. Let parent be this’s parent.\r\n\tconst parent = thisObject.parentNode;\r\n\r\n\t// 2. If parent is null, then return.\r\n\tif (parent === null) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\r\n\t// otherwise.\r\n\tlet viableNextSibling = thisObject.nextSibling;\r\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\r\n\t\tviableNextSibling = viableNextSibling.nextSibling;\r\n\t}\r\n\r\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\r\n\t// node document.\r\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\r\n\r\n\t// 5. Pre-insert node into parent before viableNextSibling.\r\n\tpreInsertNode(node, parent, viableNextSibling);\r\n}\r\n\r\n/**\r\n * The replaceWith(nodes) method, when invoked, must run these steps:\r\n *\r\n * @param thisObject - The ChildNode on which the method is invoked\r\n * @param nodes      - The nodes (and/or strings) to insert\r\n */\r\nexport function replaceWithNodes(thisObject: Node & ChildNode, nodes: (Node | string)[]): void {\r\n\t// 1. Let parent be this’s parent.\r\n\tconst parent = thisObject.parentNode;\r\n\r\n\t// 2. If parent is null, then return.\r\n\tif (parent === null) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 3. Let viableNextSibling be this’s first following sibling not in nodes, and null\r\n\t// otherwise.\r\n\tlet viableNextSibling = thisObject.nextSibling;\r\n\twhile (viableNextSibling !== null && nodes.indexOf(viableNextSibling) >= 0) {\r\n\t\tviableNextSibling = viableNextSibling.nextSibling;\r\n\t}\r\n\r\n\t// 4. Let node be the result of converting nodes into a node, given nodes and this’s\r\n\t// node document.\r\n\tconst node = convertNodesIntoNode(nodes, getNodeDocument(thisObject));\r\n\r\n\t// 5. If this’s parent is parent, replace the this with node within parent.\r\n\t// Note: this could have been inserted into node.\r\n\tif (thisObject.parentNode === parent) {\r\n\t\treplaceChildWithNode(thisObject, node, parent);\r\n\t} else {\r\n\t\t// 6. Otherwise, pre-insert node into parent before viableNextSibling.\r\n\t\tpreInsertNode(node, parent, viableNextSibling);\r\n\t}\r\n}\r\n\r\n/**\r\n * The remove() method, when invoked, must run these steps:\r\n *\r\n * @param thisObject The ChildNode on which the method is invoked\r\n */\r\nexport function removeFromParent(thisObject: Node & ChildNode): void {\r\n\t// 1. If this’s parent is null, then return.\r\n\tif (thisObject.parentNode === null) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 2. Remove the this.\r\n\tremoveNode(thisObject);\r\n}\r\n\r\n/**\r\n * To insert a node node into a live range range, run these steps:\r\n *\r\n * @param node  - the node to insert\r\n * @param range - the live range to insert into\r\n */\r\nexport function insertNodeIntoRange(node: Node, range: Range): void {\r\n\t// 1. If range's start node is a ProcessingInstruction or Comment node, is a Text node whose\r\n\t// parent is null, or is node, then throw a \"HierarchyRequestError\" DOMException.\r\n\tconst startContainer = range.startContainer;\r\n\tif (isNodeOfType(startContainer, NodeType.PROCESSING_INSTRUCTION_NODE)) {\r\n\t\tthrowHierarchyRequestError('Can not insert into a processing instruction');\r\n\t}\r\n\tif (isNodeOfType(startContainer, NodeType.COMMENT_NODE)) {\r\n\t\tthrowHierarchyRequestError('Can not insert into a comment');\r\n\t}\r\n\tif (isTextNode(startContainer) && startContainer.parentNode === null) {\r\n\t\tthrowHierarchyRequestError('Can not insert into a text node without a parent');\r\n\t}\r\n\r\n\t// 2. Let referenceNode be null.\r\n\tlet referenceNode: Node | null = null;\r\n\r\n\t// 3. If range's start node is a Text node, set referenceNode to that Text node.\r\n\tif (isTextNode(startContainer)) {\r\n\t\treferenceNode = startContainer;\r\n\t} else {\r\n\t\t// 4. Otherwise, set referenceNode to the child of start node whose index is start offset,\r\n\t\t// and null if there is no such child.\r\n\t\treferenceNode = startContainer.childNodes[range.startOffset] || null;\r\n\t}\r\n\r\n\t// 5. Let parent be range's start node if referenceNode is null, and referenceNode's parent\r\n\t// otherwise.\r\n\tconst parent = referenceNode === null ? startContainer : referenceNode.parentNode!;\r\n\r\n\t// 6. Ensure pre-insertion validity of node into parent before referenceNode.\r\n\tensurePreInsertionValidity(node, parent, referenceNode);\r\n\r\n\t// 7. If range's start node is a Text node, set referenceNode to the result of splitting it with\r\n\t// offset range's start offset.\r\n\tif (isTextNode(startContainer)) {\r\n\t\treferenceNode = startContainer.splitText(range.startOffset);\r\n\t}\r\n\r\n\t// 8. If node is referenceNode, set referenceNode to its next sibling.\r\n\tif (node === referenceNode) {\r\n\t\treferenceNode = referenceNode.nextSibling;\r\n\t}\r\n\r\n\t// 9. If node's parent is non-null, then remove node.\r\n\tif (node.parentNode !== null) {\r\n\t\tremoveNode(node);\r\n\t}\r\n\r\n\t// 10. Let newOffset be parent's length if referenceNode is null, and referenceNode's index\r\n\t// otherwise.\r\n\tlet newOffset =\r\n\t\treferenceNode === null ? determineLengthOfNode(parent) : getNodeIndex(referenceNode);\r\n\r\n\t// 11. Increase newOffset by node's length if node is a DocumentFragment node, and one\r\n\t// otherwise.\r\n\tif (isNodeOfType(node, NodeType.DOCUMENT_FRAGMENT_NODE)) {\r\n\t\tnewOffset += determineLengthOfNode(node);\r\n\t} else {\r\n\t\tnewOffset += 1;\r\n\t}\r\n\r\n\t// 12. Pre-insert node into parent before referenceNode.\r\n\tpreInsertNode(node, parent, referenceNode);\r\n\r\n\t// 13. If range is collapsed, then set range’s end to (parent, newOffset).\r\n\tif (range.collapsed) {\r\n\t\trange.setEnd(parent, newOffset);\r\n\t}\r\n}\r\n","import { asParentNode, asNonDocumentTypeChildNode } from '../mixins';\r\nimport Document from '../Document';\r\nimport DocumentType from '../DocumentType';\r\nimport Element from '../Element';\r\nimport Node from '../Node';\r\n\r\nimport { NodeType, isNodeOfType } from './NodeType';\r\n\r\n/**\r\n * Insert node into parent's children before referenceNode.\r\n *\r\n * Updates the pointers that model the tree, as well as precomputing derived properties.\r\n *\r\n * @param node           - Node to insert\r\n * @param parent         - Parent to insert under\r\n * @param referenceChild - Child to insert before\r\n */\r\nexport function insertIntoChildren(node: Node, parent: Node, referenceChild: Node | null): void {\r\n\t// Node\r\n\tnode.parentNode = parent;\r\n\tconst previousSibling: Node | null =\r\n\t\treferenceChild === null ? parent.lastChild : referenceChild.previousSibling;\r\n\tconst nextSibling: Node | null = referenceChild === null ? null : referenceChild;\r\n\tnode.previousSibling = previousSibling;\r\n\tnode.nextSibling = nextSibling;\r\n\tif (previousSibling) {\r\n\t\tpreviousSibling.nextSibling = node;\r\n\t} else {\r\n\t\tparent.firstChild = node;\r\n\t}\r\n\tif (nextSibling) {\r\n\t\tnextSibling.previousSibling = node;\r\n\t\tparent.childNodes.splice(parent.childNodes.indexOf(nextSibling), 0, node);\r\n\t} else {\r\n\t\tparent.lastChild = node;\r\n\t\tparent.childNodes.push(node);\r\n\t}\r\n\r\n\t// ParentNode\r\n\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\r\n\t\tconst element = node as Element;\r\n\t\tconst parentNode = asParentNode(parent);\r\n\t\t// Functions calling this will ensure parent is always a ParentNode\r\n\t\t/* istanbul ignore else */\r\n\t\tif (parentNode) {\r\n\t\t\tlet previousElementSibling: Element | null = null;\r\n\t\t\tfor (let sibling = previousSibling; sibling; sibling = sibling.previousSibling) {\r\n\t\t\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\r\n\t\t\t\t\tpreviousElementSibling = sibling as Element;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tconst siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\r\n\t\t\t\tif (siblingNonDocumentTypeChildNode) {\r\n\t\t\t\t\tpreviousElementSibling = siblingNonDocumentTypeChildNode.previousElementSibling;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tlet nextElementSibling: Element | null = null;\r\n\t\t\tfor (let sibling = nextSibling; sibling; sibling = sibling.nextSibling) {\r\n\t\t\t\tif (isNodeOfType(sibling, NodeType.ELEMENT_NODE)) {\r\n\t\t\t\t\tnextElementSibling = sibling as Element;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tconst siblingNonDocumentTypeChildNode = asNonDocumentTypeChildNode(sibling);\r\n\t\t\t\t// An element can never be inserted before a doctype\r\n\t\t\t\t/* istanbul ignore else */\r\n\t\t\t\tif (siblingNonDocumentTypeChildNode) {\r\n\t\t\t\t\tnextElementSibling = siblingNonDocumentTypeChildNode.nextElementSibling;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\tif (!previousElementSibling) {\r\n\t\t\t\tparentNode.firstElementChild = element;\r\n\t\t\t}\r\n\t\t\tif (!nextElementSibling) {\r\n\t\t\t\tparentNode.lastElementChild = element;\r\n\t\t\t}\r\n\t\t\tparentNode.childElementCount += 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// Document\r\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\r\n\t\tconst parentDocument = parent as Document;\r\n\t\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\r\n\t\t\tparentDocument.documentElement = node as Element;\r\n\t\t} else if (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tparentDocument.doctype = node as DocumentType;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * Remove node from parent's children.\r\n *\r\n * Updates the pointers that model the tree, as well as precomputing derived properties.\r\n *\r\n * @param node   - Node to remove\r\n * @param parent - Parent to remove from\r\n */\r\nexport function removeFromChildren(node: Node, parent: Node) {\r\n\tconst previousSibling = node.previousSibling;\r\n\tconst nextSibling = node.nextSibling;\r\n\tconst isElement = isNodeOfType(node, NodeType.ELEMENT_NODE);\r\n\tconst previousElementSibling = isElement ? (node as Element).previousElementSibling : null;\r\n\tconst nextElementSibling = isElement ? (node as Element).nextElementSibling : null;\r\n\r\n\t// Node\r\n\tnode.parentNode = null;\r\n\tnode.previousSibling = null;\r\n\tnode.nextSibling = null;\r\n\tif (previousSibling) {\r\n\t\tpreviousSibling.nextSibling = nextSibling;\r\n\t} else {\r\n\t\tparent.firstChild = nextSibling;\r\n\t}\r\n\tif (nextSibling) {\r\n\t\tnextSibling.previousSibling = previousSibling;\r\n\t} else {\r\n\t\tparent.lastChild = previousSibling;\r\n\t}\r\n\tparent.childNodes.splice(parent.childNodes.indexOf(node), 1);\r\n\r\n\t// ParentNode\r\n\tif (isElement) {\r\n\t\tconst parentNode = asParentNode(parent);\r\n\t\t// Functions calling this will ensure parent is always a ParentNode\r\n\t\t/* istanbul ignore else */\r\n\t\tif (parentNode) {\r\n\t\t\tif (parentNode.firstElementChild === node) {\r\n\t\t\t\tparentNode.firstElementChild = nextElementSibling;\r\n\t\t\t}\r\n\t\t\tif (parentNode.lastElementChild === node) {\r\n\t\t\t\tparentNode.lastElementChild = previousElementSibling;\r\n\t\t\t}\r\n\t\t\tparentNode.childElementCount -= 1;\r\n\t\t}\r\n\t}\r\n\r\n\t// Document\r\n\tif (isNodeOfType(parent, NodeType.DOCUMENT_NODE)) {\r\n\t\tconst parentDocument = parent as Document;\r\n\t\tif (isNodeOfType(node, NodeType.ELEMENT_NODE)) {\r\n\t\t\tparentDocument.documentElement = null;\r\n\t\t} else if (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tparentDocument.doctype = null;\r\n\t\t}\r\n\t}\r\n}\r\n","import { expectObject } from './errorHelpers';\r\n\r\nexport function asUnsignedLong(number: number): number {\r\n\treturn number >>> 0;\r\n}\r\n\r\nexport function legacyNullToEmptyString(value: string | null): string {\r\n\t// Treat null as empty string\r\n\tif (value === null) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\t// Coerce other values to string\r\n\treturn String(value);\r\n}\r\n\r\nexport function ifNullActAsIfEmptyString(value: string | null | undefined): string {\r\n\t// Treat both undefined and null as empty string\r\n\tif (value === undefined || value === null) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\t// Coerce other values to string\r\n\treturn String(value);\r\n}\r\n\r\nexport function asObject<T>(value: T, Constructor: any): T {\r\n\texpectObject(value, Constructor);\r\n\r\n\treturn value;\r\n}\r\n\r\nexport function asNullableObject<T>(value: T | null | undefined, Constructor: any): T | null {\r\n\tif (value === undefined || value === null) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn asObject(value, Constructor);\r\n}\r\n\r\nexport function asNullableString(value: string | null | undefined): string | null {\r\n\t// Treat undefined as null\r\n\tif (value === undefined) {\r\n\t\treturn null;\r\n\t}\r\n\r\n\treturn value;\r\n}\r\n","import Attr from './Attr';\r\nimport Element from './Element';\r\nimport Document from './Document';\r\nimport Text from './Text';\r\nimport { getContext } from './context/Context';\r\nimport RegisteredObservers from './mutation-observer/RegisteredObservers';\r\nimport cloneNode from './util/cloneNode';\r\nimport { expectArity } from './util/errorHelpers';\r\nimport {\r\n\tpreInsertNode,\r\n\tappendNode,\r\n\treplaceChildWithNode,\r\n\tpreRemoveChild,\r\n\tremoveNode,\r\n} from './util/mutationAlgorithms';\r\nimport { NodeType, isNodeOfType, isAttrNode } from './util/NodeType';\r\nimport {\r\n\tgetInclusiveAncestors,\r\n\tgetNodeDocument,\r\n\tgetNodeIndex,\r\n\tgetRootOfNode,\r\n} from './util/treeHelpers';\r\nimport { asNullableObject, asNullableString, asObject } from './util/typeHelpers';\r\n\r\nconst orderKeyByNode = new WeakMap<Node, number>();\r\n\r\n/**\r\n * Get an implementation-dependent integer value that can be used to consistently determine an\r\n * ordering between unrelated nodes.\r\n *\r\n * @param node - The node to compare ordering for\r\n */\r\nfunction getOrderKey(node: Node): number {\r\n\tlet orderKey = orderKeyByNode.get(node);\r\n\tif (orderKey === undefined) {\r\n\t\torderKey = Math.random();\r\n\t\torderKeyByNode.set(node, orderKey);\r\n\t}\r\n\treturn orderKey;\r\n}\r\n\r\n/**\r\n * 3.4. Interface Node\r\n *\r\n * @public\r\n */\r\nexport default abstract class Node {\r\n\t// Node types are exposed as properties of the constructor\r\n\tstatic ELEMENT_NODE: number = NodeType.ELEMENT_NODE;\r\n\tstatic ATTRIBUTE_NODE: number = NodeType.ATTRIBUTE_NODE;\r\n\tstatic TEXT_NODE: number = NodeType.TEXT_NODE;\r\n\tstatic CDATA_SECTION_NODE: number = NodeType.CDATA_SECTION_NODE;\r\n\tstatic ENTITY_REFERENCE_NODE: number = NodeType.ENTITY_REFERENCE_NODE; // legacy\r\n\tstatic ENTITY_NODE: number = NodeType.ENTITY_NODE; // legacy\r\n\tstatic PROCESSING_INSTRUCTION_NODE: number = NodeType.PROCESSING_INSTRUCTION_NODE;\r\n\tstatic COMMENT_NODE: number = NodeType.COMMENT_NODE;\r\n\tstatic DOCUMENT_NODE: number = NodeType.DOCUMENT_NODE;\r\n\tstatic DOCUMENT_TYPE_NODE: number = NodeType.DOCUMENT_TYPE_NODE;\r\n\tstatic DOCUMENT_FRAGMENT_NODE: number = NodeType.DOCUMENT_FRAGMENT_NODE;\r\n\tstatic NOTATION_NODE: number = NodeType.NOTATION_NODE; // legacy\r\n\r\n\t// Node types also exist as instance properties, assigned to the prototype below\r\n\tpublic ELEMENT_NODE!: number;\r\n\tpublic ATTRIBUTE_NODE!: number;\r\n\tpublic TEXT_NODE!: number;\r\n\tpublic CDATA_SECTION_NODE!: number;\r\n\tpublic ENTITY_REFERENCE_NODE!: number; // legacy\r\n\tpublic ENTITY_NODE!: number; // legacy\r\n\tpublic PROCESSING_INSTRUCTION_NODE!: number;\r\n\tpublic COMMENT_NODE!: number;\r\n\tpublic DOCUMENT_NODE!: number;\r\n\tpublic DOCUMENT_TYPE_NODE!: number;\r\n\tpublic DOCUMENT_FRAGMENT_NODE!: number;\r\n\tpublic NOTATION_NODE!: number; // legacy\r\n\r\n\t/**\r\n\t * Returns the type of node, represented by a number.\r\n\t */\r\n\tpublic abstract get nodeType(): number;\r\n\r\n\t/**\r\n\t * Returns a string appropriate for the type of node.\r\n\t */\r\n\tpublic abstract get nodeName(): string;\r\n\r\n\t/**\r\n\t * A reference to the Document node in which the current node resides.\r\n\t */\r\n\tpublic ownerDocument: Document | null = null;\r\n\r\n\t/**\r\n\t * The parent node of the current node.\r\n\t */\r\n\tpublic parentNode: Node | null = null;\r\n\r\n\t/**\r\n\t * The parent if it is an element, or null otherwise.\r\n\t */\r\n\tpublic get parentElement(): Element | null {\r\n\t\treturn this.parentNode && isNodeOfType(this.parentNode, NodeType.ELEMENT_NODE)\r\n\t\t\t? (this.parentNode as Element)\r\n\t\t\t: null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if this has children, and false otherwise.\r\n\t */\r\n\tpublic hasChildNodes(): boolean {\r\n\t\treturn !!this.childNodes.length;\r\n\t}\r\n\r\n\t/**\r\n\t * The node's children.\r\n\t *\r\n\t * Non-standard: implemented as an array rather than a NodeList.\r\n\t */\r\n\tpublic childNodes: Node[] = [];\r\n\r\n\t/**\r\n\t * The first child node of the current node, or null if it has no children.\r\n\t */\r\n\tpublic firstChild: Node | null = null;\r\n\r\n\t/**\r\n\t * The last child node of the current node, or null if it has no children.\r\n\t */\r\n\tpublic lastChild: Node | null = null;\r\n\r\n\t/**\r\n\t * The first preceding sibling of the current node, or null if it has none.\r\n\t */\r\n\tpublic previousSibling: Node | null = null;\r\n\r\n\t/**\r\n\t * The first following sibling of the current node, or null if it has none.\r\n\t */\r\n\tpublic nextSibling: Node | null = null;\r\n\r\n\t/**\r\n\t * The value of the node.\r\n\t */\r\n\tpublic abstract get nodeValue(): string | null;\r\n\tpublic abstract set nodeValue(value: string | null);\r\n\r\n\t/**\r\n\t * The textContent of the node.\r\n\t */\r\n\tpublic abstract get textContent(): string | null;\r\n\tpublic abstract set textContent(value: string | null);\r\n\r\n\t/**\r\n\t * (non-standard)\r\n\t * Each node has a registered observer list of zero or more registered observers, which is\r\n\t * initially empty.\r\n\t */\r\n\tpublic _registeredObservers: RegisteredObservers = new RegisteredObservers(this);\r\n\r\n\t/**\r\n\t * Puts the specified node and all of its subtree into a \"normalized\" form. In a normalized\r\n\t * subtree, no text nodes in the subtree are empty and there are no adjacent text nodes.\r\n\t */\r\n\tpublic normalize(): void {\r\n\t\t// for each descendant exclusive Text node node of this:\r\n\t\tlet node = this.firstChild;\r\n\t\tlet index = 0;\r\n\t\tconst document = getNodeDocument(this);\r\n\t\twhile (node) {\r\n\t\t\tlet nextNode = node.nextSibling;\r\n\t\t\tif (!isNodeOfType(node, NodeType.TEXT_NODE)) {\r\n\t\t\t\t// Process descendants\r\n\t\t\t\tnode.normalize();\r\n\t\t\t\tnode = nextNode;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\tconst textNode = node as Text;\r\n\t\t\t// 1. Let length be node’s length.\r\n\t\t\tlet length = textNode.length;\r\n\r\n\t\t\t// 2. If length is zero, then remove node and continue with the next exclusive Text\r\n\t\t\t// node, if any.\r\n\t\t\tif (length === 0) {\r\n\t\t\t\tremoveNode(node);\r\n\t\t\t\t--index;\r\n\t\t\t\tnode = nextNode;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// 3. Let data be the concatenation of the data of node’s contiguous exclusive Text\r\n\t\t\t// nodes (excluding itself), in tree order.\r\n\t\t\tlet data = '';\r\n\t\t\tconst siblingsToRemove = [];\r\n\t\t\tfor (\r\n\t\t\t\tlet sibling = textNode.nextSibling;\r\n\t\t\t\tsibling && isNodeOfType(sibling, NodeType.TEXT_NODE);\r\n\t\t\t\tsibling = sibling.nextSibling\r\n\t\t\t) {\r\n\t\t\t\tdata += (sibling as Text).data;\r\n\t\t\t\tsiblingsToRemove.push(sibling);\r\n\t\t\t}\r\n\r\n\t\t\t// 4. Replace data with node node, offset length, count 0, and data data.\r\n\t\t\tif (data) {\r\n\t\t\t\ttextNode.replaceData(length, 0, data);\r\n\t\t\t}\r\n\r\n\t\t\t// 5. Let currentNode be node’s next sibling.\r\n\t\t\t// 6. While currentNode is an exclusive Text node:\r\n\t\t\tconst context = getContext(this);\r\n\t\t\tfor (let i = 0, l = siblingsToRemove.length; i < l; ++i) {\r\n\t\t\t\tconst currentNode = siblingsToRemove[i];\r\n\t\t\t\tconst currentNodeIndex = index + i + 1;\r\n\r\n\t\t\t\tcontext.forEachRange((range) => {\r\n\t\t\t\t\t// 6.1. For each live range whose start node is currentNode, add length to its\r\n\t\t\t\t\t// start offset and set its start node to node.\r\n\t\t\t\t\tif (range.startContainer === currentNode) {\r\n\t\t\t\t\t\trange.startOffset += length;\r\n\t\t\t\t\t\trange.startContainer = textNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 6.2. For each live range whose end node is currentNode, add length to its end\r\n\t\t\t\t\t// offset and set its end node to node.\r\n\t\t\t\t\tif (range.endContainer === currentNode) {\r\n\t\t\t\t\t\trange.endOffset += length;\r\n\t\t\t\t\t\trange.endContainer = textNode;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 6.3. For each live range whose start node is currentNode’s parent and start\r\n\t\t\t\t\t// offset is currentNode’s index, set its start node to node and its start\r\n\t\t\t\t\t// offset to length.\r\n\t\t\t\t\tif (range.startContainer === this && range.startOffset === currentNodeIndex) {\r\n\t\t\t\t\t\trange.startContainer = textNode;\r\n\t\t\t\t\t\trange.startOffset = length;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 6.4. For each live range whose end node is currentNode’s parent and end\r\n\t\t\t\t\t// offset is currentNode’s index, set its end node to node and its end offset to\r\n\t\t\t\t\t// length.\r\n\t\t\t\t\tif (range.endContainer === this && range.endOffset === currentNodeIndex) {\r\n\t\t\t\t\t\trange.endContainer = textNode;\r\n\t\t\t\t\t\trange.endOffset = length;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\t\t\t\t// 6.5. Add currentNode’s length to length.\r\n\t\t\t\tlength += (currentNode as Text).length;\r\n\r\n\t\t\t\t// 6.6. Set currentNode to its next sibling.\r\n\t\t\t\t// (see for-loop increment)\r\n\t\t\t}\r\n\r\n\t\t\t// 7. Remove node’s contiguous exclusive Text nodes (excluding itself), in tree order.\r\n\t\t\twhile (siblingsToRemove.length) {\r\n\t\t\t\tremoveNode(siblingsToRemove.shift() as Node);\r\n\t\t\t}\r\n\r\n\t\t\t// Move to next node\r\n\t\t\tnode = node.nextSibling;\r\n\t\t\t++index;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a copy of the current node.\r\n\t *\r\n\t * @param deep - Whether to also clone the node's descendants\r\n\t *\r\n\t * @returns A copy of the current node\r\n\t */\r\n\tpublic cloneNode(deep: boolean = false): this {\r\n\t\treturn cloneNode(this, deep);\r\n\t}\r\n\r\n\tstatic DOCUMENT_POSITION_DISCONNECTED = 0x1;\r\n\tstatic DOCUMENT_POSITION_PRECEDING = 0x2;\r\n\tstatic DOCUMENT_POSITION_FOLLOWING = 0x4;\r\n\tstatic DOCUMENT_POSITION_CONTAINS = 0x8;\r\n\tstatic DOCUMENT_POSITION_CONTAINED_BY = 0x10;\r\n\tstatic DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 0x20;\r\n\r\n\t/**\r\n\t * Compare the position of this node with the given one.\r\n\t *\r\n\t * @param other - Node to compare with\r\n\t *\r\n\t * @returns a combination of the DOCUMENT_POSITION_* flags\r\n\t */\r\n\tpublic compareDocumentPosition(other: Node): number {\r\n\t\texpectArity(arguments, 1);\r\n\t\tother = asObject(other, Node);\r\n\r\n\t\t// 1. If this is other, then return zero.\r\n\t\tif (this === other) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\t// 2. Let node1 be other and node2 be this.\r\n\t\tlet node1: Node | null = other;\r\n\t\tlet node2: Node | null = this;\r\n\r\n\t\t// 3. Let attr1 and attr2 be null.\r\n\t\tlet attr1: Attr | null = null;\r\n\t\tlet attr2: Attr | null = null;\r\n\r\n\t\t// 4. If node1 is an attribute, then set attr1 to node1 and node1 to attr1's element.\r\n\t\tif (isAttrNode(node1)) {\r\n\t\t\tattr1 = node1;\r\n\t\t\tnode1 = attr1.ownerElement;\r\n\t\t}\r\n\r\n\t\t// 5. If node2 is an attribute, then:\r\n\t\tif (isAttrNode(node2)) {\r\n\t\t\t// 5.1. Set attr2 to node2 and node2 to attr2's element.\r\n\t\t\tattr2 = node2;\r\n\t\t\tnode2 = attr2.ownerElement;\r\n\r\n\t\t\t// 5.2. If attr1 and node1 are non-null, and node2 is node1, then:\r\n\t\t\tif (attr1 !== null && node1 !== null && node2 === node1) {\r\n\t\t\t\t// 5.2.1. For each attr in node2’s attribute list:\r\n\t\t\t\tfor (const attr of (node2 as Element).attributes) {\r\n\t\t\t\t\t// 5.2.1.1. If attr equals attr1, then return the result of adding\r\n\t\t\t\t\t// DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_PRECEDING.\r\n\t\t\t\t\tif (attr === attr1) {\r\n\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\r\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_PRECEDING\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// 5.2.1.2. If attr equals attr2, then return the result of adding\r\n\t\t\t\t\t// DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC and DOCUMENT_POSITION_FOLLOWING.\r\n\t\t\t\t\tif (attr === attr2) {\r\n\t\t\t\t\t\treturn (\r\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\r\n\t\t\t\t\t\t\tNode.DOCUMENT_POSITION_FOLLOWING\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 6. If node1 or node2 is null, or node1's root is not node2's root, then return the result\r\n\t\t// of adding DOCUMENT_POSITION_DISCONNECTED, DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and\r\n\t\t// either DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING, with the constraint\r\n\t\t// that this is to be consistent, together.\r\n\t\t// Note: Whether to return DOCUMENT_POSITION_PRECEDING or DOCUMENT_POSITION_FOLLOWING is\r\n\t\t// typically implemented via pointer comparison. In JavaScript implementations a cached\r\n\t\t// Math.random() value can be used.\r\n\t\tif (node1 === null || node2 === null) {\r\n\t\t\treturn (\r\n\t\t\t\tNode.DOCUMENT_POSITION_DISCONNECTED |\r\n\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\r\n\t\t\t\t(getOrderKey(node1 || attr1!) > getOrderKey(node2 || attr2!)\r\n\t\t\t\t\t? Node.DOCUMENT_POSITION_FOLLOWING\r\n\t\t\t\t\t: Node.DOCUMENT_POSITION_PRECEDING)\r\n\t\t\t);\r\n\t\t}\r\n\t\tconst ancestors1 = getInclusiveAncestors(node1);\r\n\t\tconst ancestors2 = getInclusiveAncestors(node2);\r\n\t\tif (ancestors1[0] !== ancestors2[0]) {\r\n\t\t\treturn (\r\n\t\t\t\tNode.DOCUMENT_POSITION_DISCONNECTED |\r\n\t\t\t\tNode.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\r\n\t\t\t\t(getOrderKey(ancestors1[0]) > getOrderKey(ancestors2[0])\r\n\t\t\t\t\t? Node.DOCUMENT_POSITION_FOLLOWING\r\n\t\t\t\t\t: Node.DOCUMENT_POSITION_PRECEDING)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 7. If node1 is an ancestor of node2 and attr1 is null, or node1 is node2 and attr2 is\r\n\t\t// non-null, then return the result of adding DOCUMENT_POSITION_CONTAINS to\r\n\t\t// DOCUMENT_POSITION_PRECEDING.\r\n\t\tlet firstDistinctAncestorIndex = 0;\r\n\t\twhile (\r\n\t\t\tfirstDistinctAncestorIndex < ancestors1.length &&\r\n\t\t\tfirstDistinctAncestorIndex < ancestors2.length\r\n\t\t) {\r\n\t\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t\t++firstDistinctAncestorIndex;\r\n\t\t}\r\n\t\tconst node1ContainsNode2 =\r\n\t\t\tnode1 !== node2 && firstDistinctAncestorIndex === ancestors1.length;\r\n\t\tconst node2ContainsNode1 =\r\n\t\t\tnode1 !== node2 && firstDistinctAncestorIndex === ancestors2.length;\r\n\t\tif ((node1ContainsNode2 && attr1 === null) || (node1 === node2 && attr2 !== null)) {\r\n\t\t\treturn Node.DOCUMENT_POSITION_CONTAINS | Node.DOCUMENT_POSITION_PRECEDING;\r\n\t\t}\r\n\r\n\t\t// 8. If node1 is a descendant of node2 and attr2 is null, or node1 is node2 and attr1 is\r\n\t\t// non-null, then return the result of adding DOCUMENT_POSITION_CONTAINED_BY to\r\n\t\t// DOCUMENT_POSITION_FOLLOWING.\r\n\t\tif ((node2ContainsNode1 && attr2 === null) || (node1 === node2 && attr1 !== null)) {\r\n\t\t\treturn Node.DOCUMENT_POSITION_CONTAINED_BY | Node.DOCUMENT_POSITION_FOLLOWING;\r\n\t\t}\r\n\r\n\t\t// 9. If node1 is preceding node2, then return DOCUMENT_POSITION_PRECEDING.\r\n\t\t// Note: Due to the way attributes are handled in this algorithm this results in a node's\r\n\t\t// attributes counting as preceding that node's children, despite attributes not\r\n\t\t// participating in the same tree.\r\n\t\tif (\r\n\t\t\tnode1ContainsNode2 ||\r\n\t\t\tgetNodeIndex(ancestors1[firstDistinctAncestorIndex]) <\r\n\t\t\t\tgetNodeIndex(ancestors2[firstDistinctAncestorIndex])\r\n\t\t) {\r\n\t\t\treturn Node.DOCUMENT_POSITION_PRECEDING;\r\n\t\t}\r\n\r\n\t\t// 10. Return DOCUMENT_POSITION_FOLLOWING.\r\n\t\treturn Node.DOCUMENT_POSITION_FOLLOWING;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if other is an inclusive descendant of this, and false otherwise\r\n\t * (including when other is null).\r\n\t *\r\n\t * @param childNode - Node to check\r\n\t *\r\n\t * @returns Whether childNode is an inclusive descendant of the current node\r\n\t */\r\n\tpublic contains(other: Node | null): boolean {\r\n\t\texpectArity(arguments, 1);\r\n\t\tother = asNullableObject(other, Node);\r\n\r\n\t\twhile (other && other != this) {\r\n\t\t\tother = other.parentNode;\r\n\t\t}\r\n\t\treturn other === this;\r\n\t}\r\n\r\n\t/**\r\n\t *\r\n\t *\r\n\t * @param namespace - The namespace to look up\r\n\t *\r\n\t * @returns The prefix for the given namespace, or null if none was found\r\n\t */\r\n\tpublic abstract lookupPrefix(namespace: string | null): string | null;\r\n\r\n\t/**\r\n\t * Returns the namespace for the given prefix.\r\n\t *\r\n\t * @param prefix - The prefix to look up\r\n\t *\r\n\t * @returns The namespace for the given prefix, or null if the prefix is not defined\r\n\t */\r\n\tpublic abstract lookupNamespaceURI(prefix: string | null): string | null;\r\n\r\n\t/**\r\n\t * Return true if defaultNamespace is the same as namespace, and false otherwise.\r\n\t *\r\n\t * @param namespace - The namespace to check\r\n\t *\r\n\t * @returns Whether namespace is the default namespace\r\n\t */\r\n\tpublic isDefaultNamespace(namespace: string | null): boolean {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnamespace = asNullableString(namespace);\r\n\r\n\t\t// 1. If namespace is the empty string, then set it to null.\r\n\t\tif (namespace === '') {\r\n\t\t\tnamespace = null;\r\n\t\t}\r\n\r\n\t\t// 2. Let defaultNamespace be the result of running locate a namespace for this\r\n\t\t// using null.\r\n\t\tconst defaultNamespace = this.lookupNamespaceURI(null);\r\n\r\n\t\t// 3. Return true if defaultNamespace is the same as namespace, and false otherwise.\r\n\t\treturn defaultNamespace === namespace;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts the specified node before child within this.\r\n\t *\r\n\t * If child is null, the new node is appended after the last child node of the current node.\r\n\t *\r\n\t * @param node  - Node to insert\r\n\t * @param child - Childnode of the current node before which to insert, or null to append\r\n\t *                newNode at the end\r\n\t *\r\n\t * @returns The node that was inserted\r\n\t */\r\n\tpublic insertBefore<TNode extends Node>(node: TNode, child: Node | null): TNode {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnode = asObject(node, Node);\r\n\t\tchild = asNullableObject(child, Node);\r\n\r\n\t\treturn preInsertNode(node, this, child);\r\n\t}\r\n\r\n\t/**\r\n\t * Adds node to the end of the list of children of this.\r\n\t *\r\n\t * If the node already exists it is removed from its current parent node, then added.\r\n\t *\r\n\t * @param node - Node to append\r\n\t *\r\n\t * @returns The node that was inserted\r\n\t */\r\n\tpublic appendChild<TNode extends Node>(node: TNode): TNode {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\treturn appendNode(node, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces child with node within this and returns child.\r\n\t *\r\n\t * @param node  - Node to insert\r\n\t * @param child - Node to remove\r\n\t *\r\n\t * @returns The node that was removed\r\n\t */\r\n\tpublic replaceChild<TChild extends Node>(node: Node, child: TChild): TChild {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnode = asObject(node, Node);\r\n\t\tchild = asObject(child, Node);\r\n\r\n\t\treturn replaceChildWithNode(child, node, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes child from this and returns the removed node.\r\n\t *\r\n\t * @param child - Child of the current node to remove\r\n\t *\r\n\t * @returns The node that was removed\r\n\t */\r\n\tpublic removeChild<TChild extends Node>(child: TChild): TChild {\r\n\t\texpectArity(arguments, 1);\r\n\t\tchild = asObject(child, Node);\r\n\r\n\t\treturn preRemoveChild(child, this);\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic abstract _copy(document: Document): Node;\r\n}\r\n\r\nNode.prototype.ELEMENT_NODE = NodeType.ELEMENT_NODE;\r\nNode.prototype.ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE;\r\nNode.prototype.TEXT_NODE = NodeType.TEXT_NODE;\r\nNode.prototype.CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE;\r\nNode.prototype.ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE; // legacy\r\nNode.prototype.ENTITY_NODE = NodeType.ENTITY_NODE; // legacy\r\nNode.prototype.PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE;\r\nNode.prototype.COMMENT_NODE = NodeType.COMMENT_NODE;\r\nNode.prototype.DOCUMENT_NODE = NodeType.DOCUMENT_NODE;\r\nNode.prototype.DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE;\r\nNode.prototype.DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE;\r\nNode.prototype.NOTATION_NODE = NodeType.NOTATION_NODE; // legacy\r\n","import Attr from '../Attr';\r\nimport Element from '../Element';\r\nimport queueMutationRecord from '../mutation-observer/queueMutationRecord';\r\n\r\n/**\r\n * To handle attribute changes for an attribute attribute with element, oldValue, and newValue, run\r\n * these steps:\r\n *\r\n * @param attribute - The attribute that is being changed\r\n * @param element   - The element that has the attribute\r\n * @param oldValue  - The old value for the attribute\r\n * @param newValue  - The new value for the attribute\r\n */\r\nexport function handleAttributeChanges(\r\n\tattribute: Attr,\r\n\telement: Element,\r\n\toldValue: string | null,\r\n\tnewValue: string | null\r\n): void {\r\n\t// 1. Queue a mutation record of \"attributes\" for element with attribute’s local name,\r\n\t// attribute's namespace, oldValue, « », « », null, and null.\r\n\tqueueMutationRecord('attributes', element, {\r\n\t\tname: attribute.localName,\r\n\t\tnamespace: attribute.namespaceURI,\r\n\t\toldValue,\r\n\t});\r\n\r\n\t// 2. If element is custom, then enqueue a custom element callback reaction with element,\r\n\t// callback name \"attributeChangedCallback\", and an argument list containing attribute’s local\r\n\t// name, attribute’s value, value, and attribute’s namespace.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 3. Run the attribute change steps with element, attribute’s local name, oldValue, newValue,\r\n\t// and attribute’s namespace.\r\n\t// (attribute change steps not implemented)\r\n}\r\n\r\n/**\r\n * To change an attribute attribute to value, run these steps:\r\n *\r\n * @param attribute - The attribute to change\r\n * @param value     - The new value for the attribute\r\n */\r\nexport function changeAttribute(attribute: Attr, value: string): void {\r\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\r\n\t// value.\r\n\thandleAttributeChanges(attribute, attribute.ownerElement!, attribute.value, value);\r\n\r\n\t// 2. Set attribute’s value to value.\r\n\t(attribute as any)._value = value;\r\n}\r\n\r\n/**\r\n * To append an attribute attribute to an element element, run these steps:\r\n *\r\n * @param attribute - The attribute to append\r\n * @param element   - The element to append attribute to\r\n */\r\nexport function appendAttribute(attribute: Attr, element: Element): void {\r\n\t// 1. Handle attribute changes for attribute with element, null and attribute's value.\r\n\thandleAttributeChanges(attribute, element, null, attribute.value);\r\n\r\n\t// 2. Append attribute to element’s attribute list.\r\n\telement.attributes.push(attribute);\r\n\r\n\t// 3. Set attribute’s element to element.\r\n\tattribute.ownerElement = element;\r\n}\r\n\r\n/**\r\n * To remove an attribute attribute, run these steps:\r\n *\r\n * @param attribute - The attribute to remove\r\n */\r\nexport function removeAttribute(attribute: Attr): void {\r\n\tconst attributeElement = attribute.ownerElement!;\r\n\t// 1. Handle attribute changes for attribute with attribute’s element, attribute’s value, and\r\n\t// null.\r\n\thandleAttributeChanges(attribute, attributeElement, attribute.value, null);\r\n\r\n\t// 2. Remove attribute from attribute's element’s attribute list.\r\n\tattributeElement.attributes.splice(attributeElement.attributes.indexOf(attribute), 1);\r\n\r\n\t// 3. Set attribute’s element to null.\r\n\tattribute.ownerElement = null;\r\n}\r\n\r\n/**\r\n * To replace an attribute oldAttr with an attribute newAttr, run these steps:\r\n *\r\n * @param oldAttr - The attribute to replace\r\n * @param newAttr - The attribute to replace oldAttr with\r\n */\r\nexport function replaceAttribute(oldAttr: Attr, newAttr: Attr): void {\r\n\tconst oldAttrElement = oldAttr.ownerElement!;\r\n\t// 1. Handle attribute changes for oldAttr with oldAttr’s element, oldAttr’s value,\r\n\t// and newAttr’s value.\r\n\thandleAttributeChanges(oldAttr, oldAttrElement, oldAttr.value, newAttr.value);\r\n\r\n\t// 4. Replace oldAttr by newAttr in element’s attribute list.\r\n\toldAttrElement.attributes.splice(oldAttrElement.attributes.indexOf(oldAttr), 1, newAttr);\r\n\r\n\t// 5. Set newAttr’s element to oldAttr's element.\r\n\tnewAttr.ownerElement = oldAttrElement;\r\n\r\n\t// 6. Set oldAttr’s element to null.\r\n\toldAttr.ownerElement = null;\r\n}\r\n","import Document from './Document';\r\nimport Element from './Element';\r\nimport Node from './Node';\r\nimport { getContext } from './context/Context';\r\nimport { changeAttribute } from './util/attrMutations';\r\nimport { expectArity } from './util/errorHelpers';\r\nimport { NodeType } from './util/NodeType';\r\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\r\n\r\n/**\r\n * 3.9.2. Interface Attr\r\n *\r\n * @public\r\n */\r\nexport default class Attr extends Node {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.ATTRIBUTE_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\t// Return the qualified name\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tpublic get nodeValue(): string | null {\r\n\t\treturn this._value;\r\n\t}\r\n\r\n\tpublic set nodeValue(newValue: string | null) {\r\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\r\n\r\n\t\t// Set an existing attribute value with this and new value.\r\n\t\tsetExistingAttributeValue(this, newValue);\r\n\t}\r\n\r\n\tpublic get textContent(): string | null {\r\n\t\treturn this._value;\r\n\t}\r\n\r\n\tpublic set textContent(newValue: string | null) {\r\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\r\n\r\n\t\t// Set an existing attribute value with this and new value.\r\n\t\tsetExistingAttributeValue(this, newValue);\r\n\t}\r\n\r\n\tpublic lookupPrefix(namespace: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If namespace is null or the empty string, then return null.\r\n\t\t// (not necessary due to recursion)\r\n\r\n\t\t// 2. Switch on this:\r\n\t\t// Attr - Return the result of locating a namespace prefix for its element, if its element\r\n\t\t// is non-null, and null otherwise.\r\n\t\tif (this.ownerElement !== null) {\r\n\t\t\treturn this.ownerElement.lookupPrefix(namespace);\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If prefix is the empty string, then set it to null.\r\n\t\t// (not necessary due to recursion)\r\n\r\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\r\n\r\n\t\t// To locate a namespace for a node using prefix, switch on node: Attr\r\n\t\t// 1. If its element is null, then return null.\r\n\t\tif (this.ownerElement === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 2. Return the result of running locate a namespace on its element using prefix.\r\n\t\treturn this.ownerElement.lookupNamespaceURI(prefix);\r\n\t}\r\n\r\n\t// Attr\r\n\r\n\tpublic readonly namespaceURI: string | null;\r\n\tpublic readonly prefix: string | null;\r\n\tpublic readonly localName: string;\r\n\tpublic readonly name: string;\r\n\r\n\tprivate _value: string;\r\n\r\n\tpublic get value(): string {\r\n\t\treturn this._value;\r\n\t}\r\n\r\n\tpublic set value(value: string) {\r\n\t\tsetExistingAttributeValue(this, value);\r\n\t}\r\n\r\n\tpublic ownerElement: Element | null;\r\n\r\n\t/**\r\n\t * (non-standard) use Document#createAttribute(NS) or Element#setAttribute(NS) to create\r\n\t * attribute nodes\r\n\t *\r\n\t * @param namespace - The namespace URI for the attribute\r\n\t * @param prefix    - The prefix for the attribute\r\n\t * @param localName - The local name for the attribute\r\n\t * @param value     - The value for the attribute\r\n\t * @param element   - The element for the attribute, or null if the attribute is not attached to\r\n\t *                    an element\r\n\t */\r\n\tconstructor(\r\n\t\tnamespace: string | null,\r\n\t\tprefix: string | null,\r\n\t\tlocalName: string,\r\n\t\tvalue: string,\r\n\t\telement: Element | null\r\n\t) {\r\n\t\tsuper();\r\n\r\n\t\tthis.namespaceURI = namespace;\r\n\t\tthis.prefix = prefix;\r\n\t\tthis.localName = localName;\r\n\t\tthis.name = prefix === null ? localName : `${prefix}:${localName}`;\r\n\t\tthis._value = value;\r\n\t\tthis.ownerElement = element;\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): Attr {\r\n\t\t// Set copy’s namespace, namespace prefix, local name, and value, to those of node.\r\n\t\tconst context = getContext(document);\r\n\t\tconst copy = new context.Attr(\r\n\t\t\tthis.namespaceURI,\r\n\t\t\tthis.prefix,\r\n\t\t\tthis.localName,\r\n\t\t\tthis.value,\r\n\t\t\tnull\r\n\t\t);\r\n\t\tcopy.ownerDocument = document;\r\n\t\treturn copy;\r\n\t}\r\n}\r\n\r\n/**\r\n * To set an existing attribute value, given an attribute attribute and string value, run these\r\n * steps:\r\n *\r\n * @param attribute - The attribute to set the value of\r\n * @param value     - The new value for attribute\r\n */\r\nfunction setExistingAttributeValue(attribute: Attr, value: string) {\r\n\tvalue = String(value);\r\n\r\n\t// 1. If attribute’s element is null, then set attribute’s value to value.\r\n\tconst element = attribute.ownerElement;\r\n\tif (element === null) {\r\n\t\t(attribute as any)._value = value;\r\n\t} else {\r\n\t\t// 2. Otherwise, change attribute to value.\r\n\t\tchangeAttribute(attribute, value);\r\n\t}\r\n}\r\n","import {\r\n\tNonDocumentTypeChildNode,\r\n\tChildNode,\r\n\tgetNextElementSibling,\r\n\tgetPreviousElementSibling,\r\n} from './mixins';\r\nimport Element from './Element';\r\nimport Node from './Node';\r\nimport { getContext } from './context/Context';\r\nimport queueMutationRecord from './mutation-observer/queueMutationRecord';\r\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\r\nimport {\r\n\tasUnsignedLong,\r\n\tifNullActAsIfEmptyString,\r\n\tlegacyNullToEmptyString,\r\n} from './util/typeHelpers';\r\nimport {\r\n\tinsertNodesBefore,\r\n\tinsertNodesAfter,\r\n\treplaceWithNodes,\r\n\tremoveFromParent,\r\n} from './util/mutationAlgorithms';\r\n\r\n/**\r\n * 3.10. Interface CharacterData\r\n *\r\n * @public\r\n */\r\nexport default abstract class CharacterData\r\n\textends Node\r\n\timplements NonDocumentTypeChildNode, ChildNode\r\n{\r\n\t// Node\r\n\r\n\tpublic get nodeValue(): string | null {\r\n\t\treturn this._data;\r\n\t}\r\n\r\n\tpublic set nodeValue(newValue: string | null) {\r\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\r\n\r\n\t\t// Set an existing attribute value with this and new value.\r\n\t\treplaceData(this, 0, this.length, newValue);\r\n\t}\r\n\r\n\tpublic get textContent(): string | null {\r\n\t\treturn this._data;\r\n\t}\r\n\r\n\tpublic set textContent(newValue: string | null) {\r\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\r\n\r\n\t\t// Set an existing attribute value with this and new value.\r\n\t\treplaceData(this, 0, this.length, newValue);\r\n\t}\r\n\r\n\tpublic lookupPrefix(namespace: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If namespace is null or the empty string, then return null.\r\n\t\t// (not necessary due to recursion)\r\n\r\n\t\t// 2. Switch on this:\r\n\t\t// Any other node - Return the result of locating a namespace prefix for its parent element,\r\n\t\t// if its parent element is non-null, and null otherwise.\r\n\t\tconst parentElement = this.parentElement;\r\n\t\tif (parentElement !== null) {\r\n\t\t\treturn parentElement.lookupPrefix(namespace);\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If prefix is the empty string, then set it to null.\r\n\t\t// (not necessary due to recursion)\r\n\r\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\r\n\r\n\t\t// To locate a namespace for a node using prefix, switch on node: Any other node\r\n\t\t// 1. If its parent element is null, then return null.\r\n\t\tconst parentElement = this.parentElement;\r\n\t\tif (parentElement === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 2. Return the result of running locate a namespace on its parent element using prefix.\r\n\t\treturn parentElement.lookupNamespaceURI(prefix);\r\n\t}\r\n\r\n\t// ChildNode\r\n\r\n\tpublic before(...nodes: (Node | string)[]): void {\r\n\t\tinsertNodesBefore(this, nodes);\r\n\t}\r\n\r\n\tpublic after(...nodes: (Node | string)[]): void {\r\n\t\tinsertNodesAfter(this, nodes);\r\n\t}\r\n\r\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\r\n\t\treplaceWithNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic remove(): void {\r\n\t\tremoveFromParent(this);\r\n\t}\r\n\r\n\t// NonDocumentTypeChildNode\r\n\r\n\tpublic get previousElementSibling(): Element | null {\r\n\t\treturn getPreviousElementSibling(this);\r\n\t}\r\n\r\n\tpublic get nextElementSibling(): Element | null {\r\n\t\treturn getNextElementSibling(this);\r\n\t}\r\n\r\n\t// CharacterData\r\n\r\n\t/**\r\n\t * Each node inheriting from the CharacterData interface has an associated mutable string called\r\n\t * data.\r\n\t */\r\n\tprotected _data: string;\r\n\r\n\tpublic get data(): string {\r\n\t\treturn this._data;\r\n\t}\r\n\r\n\tpublic set data(newValue: string) {\r\n\t\t// [LegacyNullToEmptyString]\r\n\t\tnewValue = legacyNullToEmptyString(newValue);\r\n\r\n\t\t// replace data with node this, offset 0, count this’s length, and data\r\n\t\t// new value.\r\n\t\treplaceData(this, 0, this.length, newValue);\r\n\t}\r\n\r\n\tpublic get length(): number {\r\n\t\treturn this.data.length;\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) CharacterData should never be instantiated directly.\r\n\t *\r\n\t * @param data - The data to associate with the node\r\n\t */\r\n\tprotected constructor(data: string) {\r\n\t\tsuper();\r\n\t\tthis._data = String(data);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a substring of the node's data.\r\n\t *\r\n\t * @param offset - Offset at which to start the substring\r\n\t * @param count  - The number of code units to return\r\n\t *\r\n\t * @returns The specified substring\r\n\t */\r\n\tpublic substringData(offset: number, count: number): string {\r\n\t\texpectArity(arguments, 2);\r\n\t\treturn substringData(this, offset, count);\r\n\t}\r\n\r\n\t/**\r\n\t * Appends data to the node's data.\r\n\t *\r\n\t * @param data - Data to append\r\n\t */\r\n\tpublic appendData(data: string): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\treplaceData(this, this.length, 0, data);\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts data at the specified position in the node's data.\r\n\t *\r\n\t * @param offset - Offset at which to insert\r\n\t * @param data   - Data to insert\r\n\t */\r\n\tpublic insertData(offset: number, data: string): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\treplaceData(this, offset, 0, data);\r\n\t}\r\n\r\n\t/**\r\n\t * Deletes data from the specified position.\r\n\t *\r\n\t * @param offset - Offset at which to delete\r\n\t * @param count  - Number of code units to delete\r\n\t */\r\n\tpublic deleteData(offset: number, count: number): void {\r\n\t\texpectArity(arguments, 2);\r\n\t\treplaceData(this, offset, count, '');\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces data at the specified position.\r\n\t *\r\n\t * @param offset - Offset at which to replace\r\n\t * @param count  - Number of code units to remove\r\n\t * @param data   - Data to insert\r\n\t */\r\n\tpublic replaceData(offset: number, count: number, data: string): void {\r\n\t\texpectArity(arguments, 3);\r\n\t\treplaceData(this, offset, count, data);\r\n\t}\r\n}\r\n\r\n/**\r\n * To replace data of node node with offset offset, count count, and data data, run these steps:\r\n *\r\n * @param node   - The node to replace data on\r\n * @param offset - The offset at which to start replacing\r\n * @param count  - The number of code units to replace\r\n * @param data   - The data to insert in place of the removed data\r\n */\r\nexport function replaceData(\r\n\tnode: CharacterData,\r\n\toffset: number,\r\n\tcount: number,\r\n\tdata: string\r\n): void {\r\n\t// Match spec data types\r\n\toffset = asUnsignedLong(offset);\r\n\tcount = asUnsignedLong(count);\r\n\r\n\t// 1. Let length be node’s length.\r\n\tconst length = node.length;\r\n\r\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\r\n\tif (offset > length) {\r\n\t\tthrowIndexSizeError(\"can not replace data past the node's length\");\r\n\t}\r\n\r\n\t// 3. If offset plus count is greater than length, then set count to length minus offset.\r\n\tif (offset + count > length) {\r\n\t\tcount = length - offset;\r\n\t}\r\n\r\n\t// 4. Queue a mutation record of \"characterData\" for node with null, null, node's data, « »,\r\n\t// « », null, and null.\r\n\tqueueMutationRecord('characterData', node, {\r\n\t\toldValue: node.data,\r\n\t});\r\n\r\n\t// 5. Insert data into node’s data after offset code units.\r\n\t// 6. Let delete offset be offset + data's length.\r\n\t// 7. Starting from delete offset code units, remove count code units from node’s data.\r\n\tconst nodeData = node.data;\r\n\tconst newData = nodeData.substring(0, offset) + data + nodeData.substring(offset + count);\r\n\t(node as any)._data = newData;\r\n\r\n\tconst context = getContext(node);\r\n\tcontext.forEachRange((range) => {\r\n\t\t// 8. For each live range whose start node is node and start offset is greater than offset\r\n\t\t// but less than or equal to offset plus count, set its start offset to offset.\r\n\t\tif (\r\n\t\t\trange.startContainer === node &&\r\n\t\t\trange.startOffset > offset &&\r\n\t\t\trange.startOffset <= offset + count\r\n\t\t) {\r\n\t\t\trange.startOffset = offset;\r\n\t\t}\r\n\r\n\t\t// 9. For each live range whose end node is node and end offset is greater than offset but\r\n\t\t// less than or equal to offset plus count, set its end offset to offset.\r\n\t\tif (\r\n\t\t\trange.endContainer === node &&\r\n\t\t\trange.endOffset > offset &&\r\n\t\t\trange.endOffset <= offset + count\r\n\t\t) {\r\n\t\t\trange.endOffset = offset;\r\n\t\t}\r\n\r\n\t\t// 10. For each live range whose start node is node and start offset is greater than offset\r\n\t\t// plus count, increase its start offset by data's length and decrease it by count.\r\n\t\tif (range.startContainer === node && range.startOffset > offset + count) {\r\n\t\t\trange.startOffset = range.startOffset + data.length - count;\r\n\t\t}\r\n\r\n\t\t// 11. For each live range whose end node is node and end offset is greater than offset plus\r\n\t\t// count, increase its end offset by data's length and decrease it by count.\r\n\t\tif (range.endContainer === node && range.endOffset > offset + count) {\r\n\t\t\trange.endOffset = range.endOffset + data.length - count;\r\n\t\t}\r\n\t});\r\n\r\n\t// 12. If node's parent is non-null, then run the children changed steps for node’s parent.\r\n\t// (children changed steps not implemented)\r\n}\r\n\r\n/**\r\n * To substring data with node node, offset offset, and count count, run these steps:\r\n *\r\n * @param node   - The node to get data from\r\n * @param offset - The offset at which to start the substring\r\n * @param count  - The number of code units to include in the substring\r\n *\r\n * @returns The requested substring\r\n */\r\nexport function substringData(node: CharacterData, offset: number, count: number): string {\r\n\t// Match spec data types\r\n\toffset = asUnsignedLong(offset);\r\n\tcount = asUnsignedLong(count);\r\n\r\n\t// 1. Let length be node’s length.\r\n\tconst length = node.length;\r\n\r\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\r\n\tif (offset > length) {\r\n\t\tthrowIndexSizeError(\"can not substring data past the node's length\");\r\n\t}\r\n\r\n\t// 3. If offset plus count is greater than length, return a string whose value is the code units\r\n\t// from the offsetth code unit to the end of node’s data, and then return.\r\n\tif (offset + count > length) {\r\n\t\treturn node.data.substring(offset);\r\n\t}\r\n\r\n\t// 4. Return a string whose value is the code units from the offsetth code unit to the\r\n\t// offset+countth code unit in node’s data.\r\n\treturn node.data.substring(offset, offset + count);\r\n}\r\n","import { replaceData, substringData, default as CharacterData } from './CharacterData';\r\nimport Document from './Document';\r\nimport { getContext } from './context/Context';\r\nimport { expectArity, throwIndexSizeError } from './util/errorHelpers';\r\nimport { insertNode } from './util/mutationAlgorithms';\r\nimport { NodeType, isNodeOfType } from './util/NodeType';\r\nimport { getNodeIndex } from './util/treeHelpers';\r\nimport { asUnsignedLong } from './util/typeHelpers';\r\n\r\n/**\r\n * 3.11. Interface Text\r\n *\r\n * @public\r\n */\r\nexport default class Text extends CharacterData {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.TEXT_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn '#text';\r\n\t}\r\n\r\n\t// Text\r\n\r\n\t/**\r\n\t * Returns a new Text node whose data is data and node document is current global object’s\r\n\t * associated Document.\r\n\t *\r\n\t * @param data - The data for the new text node\r\n\t */\r\n\tconstructor(data: string = '') {\r\n\t\tsuper(data);\r\n\r\n\t\tconst context = getContext(this);\r\n\t\tthis.ownerDocument = context.document;\r\n\t}\r\n\r\n\t/**\r\n\t * Splits data at the given offset and returns the remainder as Text node.\r\n\t *\r\n\t * @param offset - The offset at which to split\r\n\t *\r\n\t * @returns a text node containing the second half of the split node's data\r\n\t */\r\n\tpublic splitText(offset: number): Text {\r\n\t\texpectArity(arguments, 1);\r\n\t\toffset = asUnsignedLong(offset);\r\n\r\n\t\treturn splitText(this, offset);\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): Text {\r\n\t\t// Set copy’s data, to that of node.\r\n\t\tconst context = getContext(document);\r\n\t\tconst copy = new context.Text(this.data);\r\n\t\tcopy.ownerDocument = document;\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the combined data of all direct Text node siblings.\r\n\t *\r\n\t * @returns the concatenation of the data of the contiguous Text nodes of this, in\r\n\t *          tree order.\r\n\t */\r\n\tpublic get wholeText(): string {\r\n\t\tconst allData: string[] = [this.data];\r\n\r\n\t\tlet previousSibling = this.previousSibling;\r\n\t\twhile (\r\n\t\t\tpreviousSibling !== null &&\r\n\t\t\tisNodeOfType(previousSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\r\n\t\t) {\r\n\t\t\tconst data = (previousSibling as Text).data;\r\n\t\t\tallData.unshift(data);\r\n\t\t\tpreviousSibling = previousSibling.previousSibling;\r\n\t\t}\r\n\r\n\t\tlet nextSibling = this.nextSibling;\r\n\t\twhile (\r\n\t\t\tnextSibling !== null &&\r\n\t\t\tisNodeOfType(nextSibling, NodeType.TEXT_NODE, NodeType.CDATA_SECTION_NODE)\r\n\t\t) {\r\n\t\t\tconst data = (nextSibling as Text).data;\r\n\t\t\tallData.push(data);\r\n\t\t\tnextSibling = nextSibling.nextSibling;\r\n\t\t}\r\n\r\n\t\treturn allData.join('');\r\n\t}\r\n}\r\n\r\n/**\r\n * To split a Text node node with offset offset, run these steps:\r\n *\r\n * @param node   - The text node to split\r\n * @param offset - The offset to split at\r\n *\r\n * @returns a text node containing the second half of the split node's data\r\n */\r\nfunction splitText(node: Text, offset: number): Text {\r\n\t// 1. Let length be node’s length.\r\n\tconst length = node.length;\r\n\r\n\t// 2. If offset is greater than length, then throw an IndexSizeError.\r\n\tif (offset > length) {\r\n\t\tthrowIndexSizeError(\"can not split past the node's length\");\r\n\t}\r\n\r\n\t// 3. Let count be length minus offset.\r\n\tconst count = length - offset;\r\n\r\n\t// 4. Let new data be the result of substringing data with node node, offset offset, and count\r\n\t// count.\r\n\tconst newData = substringData(node, offset, count);\r\n\r\n\t// 5. Let new node be a new Text node, with the same node document as node. Set new node’s data\r\n\t// to new data.\r\n\tconst context = getContext(node);\r\n\tconst newNode = new context.Text(newData);\r\n\tnewNode.ownerDocument = node.ownerDocument;\r\n\r\n\t// 6. Let parent be node’s parent.\r\n\tconst parent = node.parentNode;\r\n\r\n\t// 7. If parent is non-null, then:\r\n\tif (parent !== null) {\r\n\t\t// 7.1. Insert new node into parent before node’s next sibling.\r\n\t\tinsertNode(newNode, parent, node.nextSibling);\r\n\r\n\t\tconst indexOfNodePlusOne = getNodeIndex(node) + 1;\r\n\t\tconst context = getContext(node);\r\n\t\tcontext.forEachRange((range) => {\r\n\t\t\t// 7.2. For each live range whose start node is node and start offset is greater than\r\n\t\t\t// offset, set its start node to new node and decrease its start offset by offset.\r\n\t\t\tif (range.startContainer === node && range.startOffset > offset) {\r\n\t\t\t\trange.startContainer = newNode;\r\n\t\t\t\trange.startOffset -= offset;\r\n\t\t\t}\r\n\r\n\t\t\t// 7.3. For each live range whose end node is node and end offset is greater than\r\n\t\t\t// offset, set its end node to new node and decrease its end offset by offset.\r\n\t\t\tif (range.endContainer === node && range.endOffset > offset) {\r\n\t\t\t\trange.endContainer = newNode;\r\n\t\t\t\trange.endOffset -= offset;\r\n\t\t\t}\r\n\r\n\t\t\t// 7.4. For each live range whose start node is parent and start offset is equal to the\r\n\t\t\t// index of node + 1, increase its start offset by one.\r\n\t\t\tif (range.startContainer === parent && range.startOffset === indexOfNodePlusOne) {\r\n\t\t\t\trange.startOffset += 1;\r\n\t\t\t}\r\n\r\n\t\t\t// 7.5. For each live range whose end node is parent and end offset is equal to the\r\n\t\t\t// index of node + 1, increase its end offset by one.\r\n\t\t\tif (range.endContainer === parent && range.endOffset === indexOfNodePlusOne) {\r\n\t\t\t\trange.endOffset += 1;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// 8. Replace data with node node, offset offset, count count, and data the empty string.\r\n\treplaceData(node, offset, count, '');\r\n\r\n\t// 9. Return new node.\r\n\treturn newNode;\r\n}\r\n","import Document from './Document';\r\nimport Text from './Text';\r\nimport { getContext } from './context/Context';\r\nimport { NodeType } from './util/NodeType';\r\n\r\n/**\r\n * @public\r\n */\r\nexport default class CDATASection extends Text {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.CDATA_SECTION_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn '#cdata-section';\r\n\t}\r\n\r\n\t// CDATASection\r\n\r\n\t/**\r\n\t * (non-standard) use Document#createCDATASection to create a CDATA section.\r\n\t *\r\n\t * @param data - The data for the node\r\n\t */\r\n\tconstructor(data: string) {\r\n\t\tsuper(data);\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): CDATASection {\r\n\t\t// Set copy’s data, to that of node.\r\n\t\tconst context = getContext(document);\r\n\t\tconst copy = new context.CDATASection(this.data);\r\n\t\tcopy.ownerDocument = document;\r\n\t\treturn copy;\r\n\t}\r\n}\r\n","import CharacterData from './CharacterData';\r\nimport Document from './Document';\r\nimport { getContext } from './context/Context';\r\nimport { NodeType } from './util/NodeType';\r\n\r\n/**\r\n * @public\r\n */\r\nexport default class Comment extends CharacterData {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.COMMENT_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn '#comment';\r\n\t}\r\n\r\n\t// Comment\r\n\r\n\t/**\r\n\t * Returns a new Comment node whose data is data and node document is current global object’s\r\n\t * associated Document.\r\n\t *\r\n\t * @param data - The data for the new comment\r\n\t */\r\n\tconstructor(data: string = '') {\r\n\t\tsuper(data);\r\n\r\n\t\tconst context = getContext(this);\r\n\t\tthis.ownerDocument = context.document;\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): Comment {\r\n\t\t// Set copy’s data, to that of node.\r\n\t\tconst context = getContext(document);\r\n\t\tconst copy = new context.Comment(this.data);\r\n\t\tcopy.ownerDocument = document;\r\n\t\treturn copy;\r\n\t}\r\n}\r\n","import { ChildNode } from './mixins';\r\nimport Document from './Document';\r\nimport Node from './Node';\r\nimport { getContext } from './context/Context';\r\nimport { expectArity } from './util/errorHelpers';\r\nimport { NodeType } from './util/NodeType';\r\nimport {\r\n\tinsertNodesBefore,\r\n\tinsertNodesAfter,\r\n\treplaceWithNodes,\r\n\tremoveFromParent,\r\n} from './util/mutationAlgorithms';\r\n\r\n/**\r\n * @public\r\n */\r\nexport default class DocumentType extends Node implements ChildNode {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.DOCUMENT_TYPE_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn this.name;\r\n\t}\r\n\r\n\tpublic get nodeValue(): string | null {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic set nodeValue(_newValue: string | null) {\r\n\t\t// Do nothing.\r\n\t}\r\n\r\n\tpublic get textContent(): string | null {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic set textContent(_newValue: string | null) {\r\n\t\t// Do nothing.\r\n\t}\r\n\r\n\tpublic lookupPrefix(namespace: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If namespace is null or the empty string, then return null.\r\n\t\t// (not necessary due to return value)\r\n\r\n\t\t// 2. Switch on this:\r\n\t\t// DocumentType - Return null\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If prefix is the empty string, then set it to null.\r\n\t\t// (not necessary due to return value)\r\n\r\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\r\n\r\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentType\r\n\t\t// Return null.\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// ChildNode\r\n\r\n\tpublic before(...nodes: (Node | string)[]): void {\r\n\t\tinsertNodesBefore(this, nodes);\r\n\t}\r\n\r\n\tpublic after(...nodes: (Node | string)[]): void {\r\n\t\tinsertNodesAfter(this, nodes);\r\n\t}\r\n\r\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\r\n\t\treplaceWithNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic remove(): void {\r\n\t\tremoveFromParent(this);\r\n\t}\r\n\r\n\t// DocumentType\r\n\r\n\t/**\r\n\t * The name of the doctype.\r\n\t */\r\n\tpublic name: string;\r\n\r\n\t/**\r\n\t * The public ID of the doctype.\r\n\t */\r\n\tpublic publicId: string;\r\n\r\n\t/**\r\n\t * The system ID of the doctype.\r\n\t */\r\n\tpublic systemId: string;\r\n\r\n\t/**\r\n\t * (non-standard) Use DOMImplementation#createDocumentType instead.\r\n\t *\r\n\t * @param name     - The name of the doctype\r\n\t * @param publicId - The public ID of the doctype\r\n\t * @param systemId - The system ID of the doctype\r\n\t */\r\n\tconstructor(name: string, publicId: string = '', systemId: string = '') {\r\n\t\tsuper();\r\n\r\n\t\tthis.name = name;\r\n\t\tthis.publicId = publicId;\r\n\t\tthis.systemId = systemId;\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): DocumentType {\r\n\t\t// Set copy’s name, public ID, and system ID, to those of node.\r\n\t\tconst context = getContext(document);\r\n\t\tconst copy = new context.DocumentType(this.name, this.publicId, this.systemId);\r\n\t\tcopy.ownerDocument = document;\r\n\t\treturn copy;\r\n\t}\r\n}\r\n","import Element from '../Element';\r\nimport Node from '../Node';\r\nimport { throwInvalidCharacterError, throwNamespaceError } from './errorHelpers';\r\n\r\n// 1.5. Namespaces\r\n\r\nexport const HTML_NAMESPACE = 'http://www.w3.org/1999/xhtml';\r\nexport const XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';\r\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\r\n\r\n/*\r\n// NAME_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\r\nconst regenerate = require('regenerate');\r\n\r\nconst NameStartChar = regenerate()\r\n\t.add(':')\r\n\t.addRange('A', 'Z')\r\n\t.add('_')\r\n\t.addRange('a', 'z')\r\n\t.addRange(0xC0, 0xD6)\r\n\t.addRange(0xD8, 0xF6)\r\n\t.addRange(0xF8, 0x2FF)\r\n\t.addRange(0x370, 0x37D)\r\n\t.addRange(0x37F, 0x1FFF)\r\n\t.addRange(0x200C, 0x200D)\r\n\t.addRange(0x2070, 0x218F)\r\n\t.addRange(0x2C00, 0x2FEF)\r\n\t.addRange(0x3001, 0xD7FF)\r\n\t.addRange(0xF900, 0xFDCF)\r\n\t.addRange(0xFDF0, 0xFFFD)\r\n\t.addRange(0x10000, 0xEFFFF);\r\n\r\nconst NameChar = NameStartChar.clone()\r\n\t.add('-')\r\n\t.add('.')\r\n\t.addRange('0', '9')\r\n\t.add(0xB7)\r\n\t.addRange(0x0300, 0x036F)\r\n\t.addRange(0x203F, 0x2040);\r\n\r\nreturn `^(?:${NameStartChar.toString()})(?:${NameChar.toString()})*$`;\r\n*/\r\nconst NAME_REGEX_XML_1_0_FIFTH_EDITION =\r\n\t/^(?:[:A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(?:[\\-\\.0-:A-Z_a-z\\xB7\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u037D\\u037F-\\u1FFF\\u200C\\u200D\\u203F\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\r\n\r\n/**\r\n * Returns true if name matches the Name production.\r\n *\r\n * @param name - The name to check\r\n *\r\n * @returns true if name matches Name, otherwise false\r\n */\r\nexport function matchesNameProduction(name: string): boolean {\r\n\treturn NAME_REGEX_XML_1_0_FIFTH_EDITION.test(name);\r\n}\r\n\r\n/**\r\n * @param name - The name to check\r\n *\r\n * @returns True if the name is a valid QName, provided it is also a valid Name, otherwise false\r\n */\r\nfunction isValidQName(name: string): boolean {\r\n\t// (QName is basically NCName | (NCName ':' NCName) where NCName is Name without ':', so here we\r\n\t// check that name contains at most a single colon, and that the other parts are valid Names)\r\n\tconst parts = name.split(':');\r\n\tif (parts.length > 2) {\r\n\t\t// Too many colons\r\n\t\treturn false;\r\n\t}\r\n\t// Each part should be a valid Name - we already know they don't contain ':', so a valid Name\r\n\t// here also means a valid NCName\r\n\treturn parts.every((part) => matchesNameProduction(part));\r\n}\r\n\r\n/**\r\n * To validate a qualifiedName,\r\n *\r\n * @param qualifiedName - Qualified name to validate\r\n */\r\nexport function validateQualifiedName(qualifiedName: string): void {\r\n\t// throw an InvalidCharacterError if qualifiedName does not match the QName production.\r\n\tif (!isValidQName(qualifiedName)) {\r\n\t\tthrowInvalidCharacterError('The qualified name is not a valid QName');\r\n\t}\r\n}\r\n\r\n/**\r\n * To validate and extract a namespace and qualifiedName, run these steps:\r\n *\r\n * @param namespace     - Namespace for the qualified name\r\n * @param qualifiedName - Qualified name to validate and extract the components of\r\n *\r\n * @returns Namespace, prefix and localName\r\n */\r\nexport function validateAndExtract(\r\n\tnamespace: string | null,\r\n\tqualifiedName: string\r\n): { namespace: string | null; prefix: string | null; localName: string } {\r\n\t// 1. If namespace is the empty string, set it to null.\r\n\tif (namespace === '') {\r\n\t\tnamespace = null;\r\n\t}\r\n\r\n\t// 2. Validate qualifiedName.\r\n\tvalidateQualifiedName(qualifiedName);\r\n\r\n\t// 3. Let prefix be null.\r\n\tlet prefix: string | null = null;\r\n\r\n\t// 4.  Let localName be qualifiedName.\r\n\tlet localName = qualifiedName;\r\n\r\n\t// 5. If qualifiedName contains a \":\" (U+003A), then split the string on it and set prefix to\r\n\t// the part before and localName to the part after.\r\n\tconst index = qualifiedName.indexOf(':');\r\n\tif (index >= 0) {\r\n\t\tprefix = qualifiedName.substring(0, index);\r\n\t\tlocalName = qualifiedName.substring(index + 1);\r\n\t}\r\n\r\n\t// 6. If prefix is non-null and namespace is null, then throw a NamespaceError.\r\n\tif (prefix !== null && namespace === null) {\r\n\t\tthrowNamespaceError('Qualified name with prefix can not have a null namespace');\r\n\t}\r\n\r\n\t// 7. If prefix is \"xml\" and namespace is not the XML namespace, then throw a NamespaceError.\r\n\tif (prefix === 'xml' && namespace !== XML_NAMESPACE) {\r\n\t\tthrowNamespaceError('xml prefix can only be used for the XML namespace');\r\n\t}\r\n\r\n\t// 8. If either qualifiedName or prefix is \"xmlns\" and namespace is not the XMLNS namespace,\r\n\t// then throw a NamespaceError.\r\n\tif ((qualifiedName === 'xmlns' || prefix === 'xmlns') && namespace !== XMLNS_NAMESPACE) {\r\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must use the XMLNS namespace');\r\n\t}\r\n\r\n\t// 9. If namespace is the XMLNS namespace and neither qualifiedName nor prefix is \"xmlns\", then\r\n\t// throw a NamespaceError.\r\n\tif (namespace === XMLNS_NAMESPACE && qualifiedName !== 'xmlns' && prefix !== 'xmlns') {\r\n\t\tthrowNamespaceError('xmlns prefix or qualifiedName must be used for the XMLNS namespace');\r\n\t}\r\n\r\n\t// 10. Return namespace, prefix, and localName.\r\n\treturn { namespace, prefix, localName };\r\n}\r\n\r\n/**\r\n * To locate a namespace prefix for an element using namespace, run these steps:\r\n *\r\n * @param element    - The element at which to start the lookup\r\n * @param namespace  - Namespace for which to look up the prefix\r\n *\r\n * @returns The prefix, or null if there isn't one\r\n */\r\nexport function locateNamespacePrefix(element: Element, namespace: string | null): string | null {\r\n\t// 1. If element’s namespace is namespace and its namespace prefix is non-null, then return its\r\n\t// namespace prefix.\r\n\tif (element.namespaceURI === namespace && element.prefix !== null) {\r\n\t\treturn element.prefix;\r\n\t}\r\n\r\n\t// 2. If element has an attribute whose namespace prefix is \"xmlns\" and value is namespace, then\r\n\t// return element’s first such attribute’s local name.\r\n\tconst attr = Array.from(element.attributes).find(\r\n\t\t(attr) => attr.prefix === 'xmlns' && attr.value === namespace\r\n\t);\r\n\tif (attr) {\r\n\t\treturn attr.localName;\r\n\t}\r\n\r\n\t// 3. If element’s parent element is non-null, then return the result of running locate a\r\n\t// namespace prefix on that element using namespace.\r\n\tif (element.parentElement !== null) {\r\n\t\treturn locateNamespacePrefix(element.parentElement, namespace);\r\n\t}\r\n\r\n\t// 4. Return null.\r\n\treturn null;\r\n}\r\n","import Element from '../Element';\r\nimport { XML_NAMESPACE, XMLNS_NAMESPACE } from '../util/namespaceHelpers';\r\n\r\n// 3.2.1.1.2 The Namespace Prefix Map\r\n\r\n/**\r\n * A namespace prefix map is a map that associates namespaceURI and namespace prefix lists, where\r\n * namespaceURI values are the map's unique keys (which can include the null value representing no\r\n * namespace), and ordered lists of associated prefix values are the map's key values. The namespace\r\n * prefix map will be populated by previously seen namespaceURIs and all their previously\r\n * encountered prefix associations for a given node and its ancestors.\r\n *\r\n * NOTE: the last seen prefix for a given namespaceURI is at the end of its respective list. The\r\n * list is searched to find potentially matching prefixes, and if no matches are found for the given\r\n * namespaceURI, then the last prefix in the list is used. See copy a namespace prefix map and\r\n * retrieve a preferred prefix string for additional details.\r\n */\r\nexport class NamespacePrefixMap {\r\n\tprivate _map: Map<string | null, string[]> = new Map();\r\n\r\n\t/**\r\n\t * To copy a namespace prefix map map means to copy the map's keys into a new empty namespace\r\n\t * prefix map, and to copy each of the values in the namespace prefix list associated with each\r\n\t * keys' value into a new list which should be associated with the respective key in the new\r\n\t * map.\r\n\t *\r\n\t * @returns A copy of the namespace prefix map\r\n\t */\r\n\tpublic copy(): NamespacePrefixMap {\r\n\t\tconst copy = new NamespacePrefixMap();\r\n\t\t// Array.from needed to allow compilation to ES5 targets\r\n\t\tfor (const [namespace, prefixes] of Array.from(this._map.entries())) {\r\n\t\t\tcopy._map.set(namespace, prefixes.concat());\r\n\t\t}\r\n\t\treturn copy;\r\n\t}\r\n\r\n\t/**\r\n\t * To retrieve a preferred prefix string preferred prefix from the namespace prefix map map\r\n\t * given a namespace ns, the user agent should:\r\n\t *\r\n\t * @param preferredPrefix - The prefix to look up\r\n\t * @param ns              - The namespace for the prefix\r\n\t *\r\n\t * @returns The matching candidate prefix, if found, or null otherwise\r\n\t */\r\n\tpublic retrievePreferredPrefixString(\r\n\t\tpreferredPrefix: string | null,\r\n\t\tns: string | null\r\n\t): string | null {\r\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\r\n\t\t// key in map that matches the value of ns or if there is no such key, then stop running\r\n\t\t// these steps, and return the null value.\r\n\t\tconst candidatesList = this._map.get(ns);\r\n\t\tif (candidatesList === undefined) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 2. Otherwise, for each prefix value prefix in candidates list, iterating from beginning\r\n\t\t// to end:\r\n\t\t// NOTE: There will always be at least one prefix value in the list.\r\n\t\tfor (const prefix of candidatesList) {\r\n\t\t\t// 2.1. If prefix matches preferred prefix, then stop running these steps and return\r\n\t\t\t// prefix.\r\n\t\t\tif (prefix === preferredPrefix) {\r\n\t\t\t\treturn prefix;\r\n\t\t\t}\r\n\r\n\t\t\t// 2.2. If prefix is the last item in the candidates list, then stop running these steps\r\n\t\t\t// and return prefix.\r\n\t\t}\r\n\t\treturn candidatesList[candidatesList.length - 1];\r\n\t}\r\n\r\n\t/**\r\n\t * To check if a prefix string prefix is found in a namespace prefix map map given a namespace\r\n\t * ns, the user agent should:\r\n\t *\r\n\t * @param prefix - The prefix to check\r\n\t * @param ns     - The namespace to check\r\n\t *\r\n\t * @returns Whether the combination of prefix and ns is found in the map\r\n\t */\r\n\tpublic checkIfFound(prefix: string, ns: string | null): boolean {\r\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\r\n\t\t// key in map that matches the value of ns or if there is no such key, then stop running\r\n\t\t// these steps, and return false.\r\n\t\tconst candidatesList = this._map.get(ns);\r\n\t\tif (candidatesList === undefined) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 2. If the value of prefix occurs at least once in candidates list, return true, otherwise\r\n\t\t// return false.\r\n\t\treturn candidatesList.indexOf(prefix) >= 0;\r\n\t}\r\n\r\n\t/**\r\n\t * To add a prefix string prefix to the namespace prefix map map given a namespace ns, the user\r\n\t * agent should:\r\n\t *\r\n\t * @param prefix - The prefix to add\r\n\t * @param ns     - The namespace to add for prefix\r\n\t */\r\n\tpublic add(prefix: string, ns: string | null): void {\r\n\t\t// 1. Let candidates list be the result of retrieving a list from map where there exists a\r\n\t\t// key in map that matches the value of ns or if there is no such key, then let candidates\r\n\t\t// list be null.\r\n\t\t// (undefined used instead of null for convenience)\r\n\t\tconst candidatesList = this._map.get(ns);\r\n\r\n\t\t// 2. If candidates list is null, then create a new list with prefix as the only item in the\r\n\t\t// list, and associate that list with a new key ns in map.\r\n\t\tif (candidatesList === undefined) {\r\n\t\t\tthis._map.set(ns, [prefix]);\r\n\t\t} else {\r\n\t\t\t// 3. Otherwise, append prefix to the end of candidates list.\r\n\t\t\tcandidatesList.push(prefix);\r\n\t\t}\r\n\r\n\t\t// NOTE: The steps in retrieve a preferred prefix string use the list to track the most\r\n\t\t// recently used (MRU) prefix associated with a given namespace, which will be the prefix at\r\n\t\t// the end of the list. This list may contain duplicates of the same prefix value seen\r\n\t\t// earlier (and that's OK).\r\n\t}\r\n}\r\n\r\nexport type LocalPrefixesMap = { [key: string]: string | null };\r\n\r\n// 3.2.1.1.1 Recording the namespace\r\n\r\n/**\r\n * This following algorithm will update the namespace prefix map with any found namespace prefix\r\n * definitions, add the found prefix definitions to the local prefixes map, and return a local\r\n * default namespace value defined by a default namespace attribute if one exists. Otherwise it\r\n * returns null.\r\n *\r\n * @param element          - Element for which to record namespace information\r\n * @param map              - The namespace prefix map to update\r\n * @param localPrefixesMap - The local prefixes map to update\r\n *\r\n * @returns The local default namespace value for element, or null if element does not define one\r\n */\r\nexport function recordNamespaceInformation(\r\n\telement: Element,\r\n\tmap: NamespacePrefixMap,\r\n\tlocalPrefixesMap: LocalPrefixesMap\r\n): string | null {\r\n\t// 1. Let default namespace attr value be null.\r\n\tlet defaultNamespaceAttrValue: string | null = null;\r\n\r\n\t// 2. Main: For each attribute attr in element's attributes, in the order they are specified in\r\n\t// the element's attribute list:\r\n\t// NOTE: The following conditional steps find namespace prefixes. Only attributes in the XMLNS\r\n\t// namespace are considered (e.g., attributes made to look like namespace declarations via\r\n\t// setAttribute(\"xmlns:pretend-prefix\", \"pretend-namespace\") are not included).\r\n\tfor (const attr of element.attributes) {\r\n\t\t// 2.1. Let attribute namespace be the value of attr's namespaceURI value.\r\n\t\tconst attributeNamespace = attr.namespaceURI;\r\n\r\n\t\t// 2.2. Let attribute prefix be the value of attr's prefix.\r\n\t\tconst attributePrefix = attr.prefix;\r\n\r\n\t\t// 2.3. If the attribute namespace is the XMLNS namespace, then:\r\n\t\tif (attributeNamespace === XMLNS_NAMESPACE) {\r\n\t\t\t// 2.3.1. If attribute prefix is null, then attr is a default namespace declaration. Set\r\n\t\t\t// the default namespace attr value to attr's value and stop running these steps,\r\n\t\t\t// returning to Main to visit the next attribute.\r\n\t\t\tif (attributePrefix === null) {\r\n\t\t\t\tdefaultNamespaceAttrValue = attr.value;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// 2.3.2. Otherwise, the attribute prefix is non-null and attr is a namespace prefix\r\n\t\t\t// definition. Run the following steps:\r\n\t\t\t// 2.3.2.1. Let prefix definition be the value of attr's localName.\r\n\t\t\tconst prefixDefinition = attr.localName;\r\n\r\n\t\t\t// 2.3.2.2. Let namespace definition be the value of attr's value.\r\n\t\t\tlet namespaceDefinition: string | null = attr.value;\r\n\r\n\t\t\t// 2.3.2.3. If namespace definition is the XML namespace, then stop running these steps,\r\n\t\t\t// and return to Main to visit the next attribute.\r\n\t\t\t// NOTE: XML namespace definitions in prefixes are completely ignored (in order to avoid\r\n\t\t\t// unnecessary work when there might be prefix conflicts). XML namespaced elements are\r\n\t\t\t// always handled uniformly by prefixing (and overriding if necessary) the element's\r\n\t\t\t// localname with the reserved \"xml\" prefix.\r\n\t\t\tif (namespaceDefinition === XML_NAMESPACE) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// 2.3.2.4. If namespace definition is the empty string (the declarative form of having\r\n\t\t\t// no namespace), then let namespace definition be null instead.\r\n\t\t\tif (namespaceDefinition === '') {\r\n\t\t\t\tnamespaceDefinition = null;\r\n\t\t\t}\r\n\r\n\t\t\t// 2.3.2.5. If prefix definition is found in map given the namespace namespace\r\n\t\t\t// definition, then stop running these steps, and return to Main to visit the next\r\n\t\t\t// attribute.\r\n\t\t\t// NOTE: This step avoids adding duplicate prefix definitions for the same namespace in\r\n\t\t\t// the map. This has the side-effect of avoiding later serialization of duplicate\r\n\t\t\t// namespace prefix declarations in any descendant nodes.\r\n\t\t\tif (map.checkIfFound(prefixDefinition, namespaceDefinition)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// 2.3.2.6. Add the prefix prefix definition to map given namespace namespace\r\n\t\t\t// definition.\r\n\t\t\tmap.add(prefixDefinition, namespaceDefinition);\r\n\r\n\t\t\t// 2.3.2.7. Add the value of prefix definition as a new key to the local prefixes map,\r\n\t\t\t// with the namespace definition as the key's value replacing the value of null with the\r\n\t\t\t// empty string if applicable.\r\n\t\t\tlocalPrefixesMap[prefixDefinition] =\r\n\t\t\t\tnamespaceDefinition === null ? '' : namespaceDefinition;\r\n\t\t}\r\n\t}\r\n\r\n\t// 3. Return the value of default namespace attr value.\r\n\t// NOTE: The empty string is a legitimate return value and is not converted to null.\r\n\treturn defaultNamespaceAttrValue;\r\n}\r\n","import CDATASection from '../CDATASection';\r\nimport Comment from '../Comment';\r\nimport Document from '../Document';\r\nimport DocumentType from '../DocumentType';\r\nimport Element from '../Element';\r\nimport Node from '../Node';\r\nimport ProcessingInstruction from '../ProcessingInstruction';\r\nimport Text from '../Text';\r\nimport { throwInvalidStateError } from '../util/errorHelpers';\r\nimport {\r\n\tmatchesNameProduction,\r\n\tHTML_NAMESPACE,\r\n\tXML_NAMESPACE,\r\n\tXMLNS_NAMESPACE,\r\n} from '../util/namespaceHelpers';\r\nimport { NodeType } from '../util/NodeType';\r\nimport {\r\n\trecordNamespaceInformation,\r\n\tLocalPrefixesMap,\r\n\tNamespacePrefixMap,\r\n} from './NamespacePrefixMap';\r\n\r\n/*\r\n// CHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\r\nconst regenerate = require('regenerate');\r\n\r\nconst Char = regenerate()\r\n\t.add(0x9)\r\n\t.add(0xA)\r\n\t.add(0xD)\r\n\t.addRange(0x20, 0xD7FF)\r\n\t.addRange(0xE000, 0xFFFD)\r\n\t.addRange(0x10000, 0xEFFFF);\r\n\r\nreturn `^(${Char.toString()})*$`;\r\n*/\r\nconst CHAR_REGEX_XML_1_0_FIFTH_EDITION =\r\n\t/^(?:[\\t\\n\\r -\\uD7FF\\uE000-\\uFFFD]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])*$/;\r\n\r\n/*\r\n// PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION generated using regenerate:\r\nconst regenerate = require('regenerate');\r\n\r\n// #x20 | #xD | #xA | [a-zA-Z0-9] | [-'()+,./:=?;!*#@$_%]\r\nconst PubidChar = regenerate()\r\n\t.add(0x20)\r\n\t.add(0xD)\r\n\t.add(0xA)\r\n\t.addRange('a', 'z')\r\n\t.addRange('A', 'Z')\r\n\t.addRange('0', '9')\r\n\t.add(...\"-'()+,./:=?;!*#@$_%\");\r\n\r\n`^(${PubidChar.toString()})*$`;\r\n*/\r\nconst PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION = /^(?:[\\n\\r !#-%'-;=\\?-Z_a-z])*$/;\r\n\r\nconst HTML_VOID_ELEMENTS = [\r\n\t'area',\r\n\t'base',\r\n\t'basefont',\r\n\t'bgsound',\r\n\t'br',\r\n\t'col',\r\n\t'embed',\r\n\t'frame',\r\n\t'hr',\r\n\t'img',\r\n\t'input',\r\n\t'keygen',\r\n\t'link',\r\n\t'menuitem',\r\n\t'meta',\r\n\t'param',\r\n\t'source',\r\n\t'track',\r\n\t'wbr',\r\n];\r\n\r\n// 3.2. Serializing\r\n\r\n/**\r\n * The following steps form the fragment serializing algorithm:\r\n *\r\n * @param node                - The node to serialize\r\n * @param requireWellFormed   - Determines whether the result needs to be well-formed\r\n * @param withFictionalParent - Whether to treat node as a fictional parent with node as its only\r\n *                              child\r\n *\r\n * @returns A string representing the serialization of node\r\n */\r\nexport function serializeFragment(\r\n\tnode: Node,\r\n\trequireWellFormed: boolean,\r\n\twithFictionalParent: boolean = false\r\n): string {\r\n\t// 1. Let context document be the value of node's node document.\r\n\t// 2. If context document is an HTML document, return an HTML serialization of node.\r\n\t// (HTML documents not implemented)\r\n\r\n\t// 3. Otherwise, context document is an XML document; return an XML serialization of node\r\n\t// passing the flag require well-formed.\r\n\t// Note: if implemented as stated in the spec, this would make innerHTML return the outerHTML\r\n\t// and make outerHTML trigger undefined behavior (the spec doesn't state the type of the\r\n\t// fictional node that acts as a parent). Instead, serialize the children only\r\n\tconst childNodes = withFictionalParent ? [node] : node.childNodes;\r\n\tconst result: string[] = [];\r\n\tfor (const child of childNodes) {\r\n\t\tproduceXmlSerialization(child, requireWellFormed, result);\r\n\t}\r\n\treturn result.join('');\r\n\r\n\t// NOTE: The XML serialization defined in this document conforms to the requirements of the XML\r\n\t// fragment serialization algorithm defined in [HTML5].\r\n}\r\n\r\n// 3.2.1. XML Serialization\r\n\r\ntype PrefixIndex = { value: number };\r\n\r\n/**\r\n * To produce an XML serialization of a Node node given a flag require well-formed, run the\r\n * following steps:\r\n *\r\n * @param node              - The node to serialize\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nexport function produceXmlSerialization(\r\n\tnode: Node,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\t// 1. Let namespace be a context namespace with value null. The context namespace tracks the XML\r\n\t// serialization algorithm's current default namespace. The context namespace is changed when\r\n\t// either an Element Node has a default namespace declaration, or the algorithm generates a\r\n\t// default namespace declaration for the Element Node to match its own namespace. The algorithm\r\n\t// assumes no namespace (null) to start.\r\n\tconst namespace: string | null = null;\r\n\r\n\t// 2. Let prefix map be a new namespace prefix map.\r\n\tconst prefixMap = new NamespacePrefixMap();\r\n\r\n\t// 3. Add the XML namespace with prefix value \"xml\" to prefix map.\r\n\tprefixMap.add('xml', XML_NAMESPACE);\r\n\r\n\t// 4. Let prefix index be a generated namespace prefix index with value 1. The generated\r\n\t// namespace prefix index is used to generate a new unique prefix value when no suitable\r\n\t// existing namespace prefix is available to serialize a node's namespaceURI (or the\r\n\t// namespaceURI of one of node's attributes). See the generate a prefix algorithm.\r\n\tconst prefixIndex: PrefixIndex = { value: 1 };\r\n\r\n\t// 5. Return the result of running the XML serialization algorithm on node passing the context\r\n\t// namespace namespace, namespace prefix map prefix map, generated namespace prefix index\r\n\t// reference to prefix index, and the flag require well-formed. If an exception occurs during\r\n\t// the execution of the algorithm, then catch that exception and throw an \"InvalidStateError\"\r\n\t// DOMException.\r\n\ttry {\r\n\t\trunXmlSerializationAlgorithm(\r\n\t\t\tnode,\r\n\t\t\tnamespace,\r\n\t\t\tprefixMap,\r\n\t\t\tprefixIndex,\r\n\t\t\trequireWellFormed,\r\n\t\t\tresult\r\n\t\t);\r\n\t} catch (error) {\r\n\t\tconst message =\r\n\t\t\terror instanceof Error ? error.message : 'An error occurred during serialization.';\r\n\t\treturn throwInvalidStateError(message);\r\n\t}\r\n}\r\n\r\n/**\r\n * The XML serialization algorithm produces an XML serialization of an arbitrary DOM node node based\r\n * on the node's interface type. Each referenced algorithm is to be passed the arguments as they\r\n * were recieved by the caller and return their result to the caller. Re-throw any exceptions.\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n *\r\n * @returns The serialization of node\r\n */\r\nfunction runXmlSerializationAlgorithm(\r\n\tnode: Node,\r\n\tnamespace: null | string,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\t// If node's interface is:\r\n\tswitch (node.nodeType) {\r\n\t\t// Element: Run the algorithm for XML serializing an Element node node.\r\n\t\tcase NodeType.ELEMENT_NODE:\r\n\t\t\tserializeElementNode(\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tprefixMap,\r\n\t\t\t\tprefixIndex,\r\n\t\t\t\trequireWellFormed,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t\treturn;\r\n\r\n\t\t// Document: Run the algorithm for XML serializing a Document node node.\r\n\t\tcase NodeType.DOCUMENT_NODE:\r\n\t\t\tserializeDocumentNode(\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tprefixMap,\r\n\t\t\t\tprefixIndex,\r\n\t\t\t\trequireWellFormed,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t\treturn;\r\n\r\n\t\t// Comment: Run the algorithm for XML serializing a Comment node node.\r\n\t\tcase NodeType.COMMENT_NODE:\r\n\t\t\tserializeCommentNode(\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tprefixMap,\r\n\t\t\t\tprefixIndex,\r\n\t\t\t\trequireWellFormed,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t\treturn;\r\n\r\n\t\t// CDATASection: Run the algorithm for XML serializing a CDATASection node node.\r\n\t\t// Note: this is currently commented out in the DOM parsing spec, as it is based on the DOM4\r\n\t\t// spec which removed the CDATASection interface. It seems the interface has been restored\r\n\t\t// in the DOM living standard, so we'll implement its serialization as specced previously.\r\n\t\tcase NodeType.CDATA_SECTION_NODE:\r\n\t\t\tserializeCDATASectionNode(\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tprefixMap,\r\n\t\t\t\tprefixIndex,\r\n\t\t\t\trequireWellFormed,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t\treturn;\r\n\r\n\t\t// Text: Run the algorithm for XML serializing a Text node node.\r\n\t\tcase NodeType.TEXT_NODE:\r\n\t\t\tserializeTextNode(node, namespace, prefixMap, prefixIndex, requireWellFormed, result);\r\n\t\t\treturn;\r\n\r\n\t\t// DocumentFragment: Run the algorithm for XML serializing a DocumentFragment node node.\r\n\t\tcase NodeType.DOCUMENT_FRAGMENT_NODE:\r\n\t\t\tserializeDocumentFragmentNode(\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tprefixMap,\r\n\t\t\t\tprefixIndex,\r\n\t\t\t\trequireWellFormed,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t\treturn;\r\n\r\n\t\t// DocumentType: Run the algorithm for XML serializing a DocumentType node node.\r\n\t\tcase NodeType.DOCUMENT_TYPE_NODE:\r\n\t\t\tserializeDocumentTypeNode(\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tprefixMap,\r\n\t\t\t\tprefixIndex,\r\n\t\t\t\trequireWellFormed,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t\treturn;\r\n\r\n\t\t// ProcessingInstruction: Run the algorithm for XML serializing a ProcessingInstruction node\r\n\t\t// node.\r\n\t\tcase NodeType.PROCESSING_INSTRUCTION_NODE:\r\n\t\t\tserializeProcessingInstructionNode(\r\n\t\t\t\tnode,\r\n\t\t\t\tnamespace,\r\n\t\t\t\tprefixMap,\r\n\t\t\t\tprefixIndex,\r\n\t\t\t\trequireWellFormed,\r\n\t\t\t\tresult\r\n\t\t\t);\r\n\t\t\treturn;\r\n\r\n\t\t// An Attr object: Return an empty string.\r\n\t\tcase NodeType.ATTRIBUTE_NODE:\r\n\t\t\treturn;\r\n\r\n\t\t// Anything else: Throw a TypeError. Only Nodes and Attr objects can be serialized by this\r\n\t\t// algorithm.\r\n\t\t// (not reachable from public API)\r\n\t\t/* istanbul ignore next */\r\n\t\tdefault:\r\n\t\t\tthrow new TypeError('Only Nodes and Attr objects can be serialized by this algorithm.');\r\n\t}\r\n}\r\n\r\n/**\r\n * 3.2.1.1 XML serializing an Element node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeElementNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\tconst element = node as Element;\r\n\t// If the require well-formed flag is set (its value is true), and this node's localName\r\n\t// attribute contains the character \":\" (U+003A COLON) or does not match the XML Name\r\n\t// production, then throw an exception; the serialization of this node would not be a\r\n\t// well-formed element.\r\n\tif (\r\n\t\trequireWellFormed &&\r\n\t\t(element.localName.indexOf(':') >= 0 || !matchesNameProduction(element.localName))\r\n\t) {\r\n\t\tthrow new Error(\r\n\t\t\t`Can not serialize an element because the localName \"${element.localName}\" is not allowed.`\r\n\t\t);\r\n\t}\r\n\r\n\t// 2. Let markup be the string \"<\" (U+003C LESS-THAN SIGN).\r\n\tresult.push('<');\r\n\r\n\t// 3. Let qualified name be an empty string.\r\n\tlet qualifiedName = '';\r\n\r\n\t// 4. Let skip end tag be a boolean flag with value false.\r\n\tlet skipEndTag = false;\r\n\r\n\t// 5. Let ignore namespace definition attribute be a boolean flag with value false.\r\n\tlet ignoreNamespaceDefinitionAttribute = false;\r\n\r\n\t// 6. Given prefix map, copy a namespace prefix map and let map be the result.\r\n\tconst map = prefixMap.copy();\r\n\r\n\t// 7. Let local prefixes map be an empty map. The map has unique Node prefix strings as its\r\n\t// keys, with corresponding namespaceURI Node values as the map's key values (in this map, the\r\n\t// null namespace is represented by the empty string).\r\n\t// NOTE: This map is local to each element. It is used to ensure there are no conflicting\r\n\t// prefixes should a new namespace prefix attribute need to be generated. It is also used to\r\n\t// enable skipping of duplicate prefix definitions when writing an element's attributes: the map\r\n\t// allows the algorithm to distinguish between a prefix in the namespace prefix map that might\r\n\t// be locally-defined (to the current Element) and one that is not.\r\n\tconst localPrefixesMap: LocalPrefixesMap = {};\r\n\r\n\t// 8. Let local default namespace be the result of recording the namespace information for node\r\n\t// given map and local prefixes map.\r\n\t// NOTE: The above step will update map with any found namespace prefix definitions, add the\r\n\t// found prefix definitions to the local prefixes map and return a local default namespace value\r\n\t// defined by a default namespace attribute if one exists. Otherwise it returns null.\r\n\tconst localDefaultNamespace = recordNamespaceInformation(element, map, localPrefixesMap);\r\n\r\n\t// 9. Let inherited ns be a copy of namespace.\r\n\tlet inheritedNs = namespace;\r\n\r\n\t// 10. Let ns be the value of node's namespaceURI attribute.\r\n\tconst ns = element.namespaceURI;\r\n\r\n\t// 11. If inherited ns is equal to ns, then:\r\n\tif (inheritedNs === ns) {\r\n\t\t// 11.1. If local default namespace is non-null, then set ignore namespace definition\r\n\t\t// attribute to true.\r\n\t\tif (localDefaultNamespace !== null) {\r\n\t\t\tignoreNamespaceDefinitionAttribute = true;\r\n\t\t}\r\n\r\n\t\t// 11.2. If ns is the XML namespace, then append to qualified name the concatenation of the\r\n\t\t// string \"xml:\" and the value of node's localName.\r\n\t\tif (ns === XML_NAMESPACE) {\r\n\t\t\tqualifiedName += 'xml:' + element.localName;\r\n\t\t} else {\r\n\t\t\t// 11.3. Otherwise, append to qualified name the value of node's localName. The node's\r\n\t\t\t// prefix if it exists, is dropped.\r\n\t\t\tqualifiedName += element.localName;\r\n\t\t}\r\n\t\t// 11.4. Append the value of qualified name to markup.\r\n\t\tresult.push(qualifiedName);\r\n\t} else {\r\n\t\t// 12. Otherwise, inherited ns is not equal to ns (the node's own namespace is different\r\n\t\t// from the context namespace of its parent). Run these sub-steps:\r\n\t\t// 12.1. Let prefix be the value of node's prefix attribute.\r\n\t\tlet prefix = element.prefix;\r\n\r\n\t\t// 12.2. Let candidate prefix be the result of retrieving a preferred prefix string prefix\r\n\t\t// from map given namespace ns.\r\n\t\t// NOTE: The above may return null if no namespace key ns exists in map.\r\n\t\tlet candidatePrefix = map.retrievePreferredPrefixString(prefix, ns);\r\n\r\n\t\t// 12.3. If the value of prefix matches \"xmlns\", then run the following steps:\r\n\t\tif (prefix === 'xmlns') {\r\n\t\t\t// 12.3.1. If the require well-formed flag is set, then throw an error. An Element with\r\n\t\t\t// prefix \"xmlns\" will not legally round-trip in a conforming XML parser.\r\n\t\t\tif (requireWellFormed) {\r\n\t\t\t\tthrow new Error(\r\n\t\t\t\t\t'Can not serialize an element with prefix \"xmlns\" because it will ' +\r\n\t\t\t\t\t\t'not legally round-trip in a conforming XML parser.'\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// 12.3.2. Let candidate prefix be the value of prefix.\r\n\t\t\tcandidatePrefix = prefix;\r\n\t\t}\r\n\r\n\t\t// 12.4. Found a suitable namespace prefix: if candidate prefix is non-null (a namespace\r\n\t\t// prefix is defined which maps to ns), then:\r\n\t\tif (candidatePrefix !== null) {\r\n\t\t\t// NOTE: The following may serialize a different prefix than the Element's existing\r\n\t\t\t// prefix if it already had one. However, the retrieving a preferred prefix string\r\n\t\t\t// algorithm already tried to match the existing prefix if possible.\r\n\r\n\t\t\t// 12.4.1. Append to qualified name the concatenation of candidate prefix, \":\" (U+003A\r\n\t\t\t// COLON), and node's localName. There exists on this node or the node's ancestry a\r\n\t\t\t// namespace prefix definition that defines the node's namespace.\r\n\t\t\tqualifiedName += candidatePrefix + ':' + element.localName;\r\n\r\n\t\t\t// 12.4.2. If the local default namespace is non-null (there exists a locally-defined\r\n\t\t\t// default namespace declaration attribute) and its value is not the XML namespace, then\r\n\t\t\t// let inherited ns get the value of local default namespace unless the local default\r\n\t\t\t// namespace is the empty string in which case let it get null (the context namespace is\r\n\t\t\t// changed to the declared default, rather than this node's own namespace).\r\n\t\t\t// NOTE: Any default namespace definitions or namespace prefixes that define the XML\r\n\t\t\t// namespace are omitted when serializing this node's attributes.\r\n\t\t\tif (localDefaultNamespace !== null && localDefaultNamespace !== XML_NAMESPACE) {\r\n\t\t\t\tinheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\r\n\t\t\t}\r\n\r\n\t\t\t// 12.4.3. Append the value of qualified name to markup.\r\n\t\t\tresult.push(qualifiedName);\r\n\t\t} else if (prefix !== null) {\r\n\t\t\t// 12.5. Otherwise, if prefix is non-null, then:\r\n\t\t\t// NOTE: By this step, there is no namespace or prefix mapping declaration in this node\r\n\t\t\t// (or any parent node visited by this algorithm) that defines prefix otherwise the step\r\n\t\t\t// labelled Found a suitable namespace prefix would have been followed. The sub-steps\r\n\t\t\t// that follow will create a new namespace prefix declaration for prefix and ensure that\r\n\t\t\t// prefix does not conflict with an existing namespace prefix declaration of the same\r\n\t\t\t// localName in node's attribute list.\r\n\r\n\t\t\t// 12.5.1. If the local prefixes map contains a key matching prefix, then let prefix be\r\n\t\t\t// the result of generating a prefix providing as input map, ns, and prefix index.\r\n\t\t\tif (prefix in localPrefixesMap) {\r\n\t\t\t\tprefix = generatePrefix(map, ns, prefixIndex);\r\n\t\t\t}\r\n\r\n\t\t\t// 12.5.2. Add prefix to map given namespace ns.\r\n\t\t\tmap.add(prefix, ns);\r\n\r\n\t\t\t// 12.5.3. Append to qualified name the concatenation of prefix, \":\" (U+003A COLON), and\r\n\t\t\t// node's localName.\r\n\t\t\tqualifiedName += prefix + ':' + element.localName;\r\n\r\n\t\t\t// 12.5.4. Append the value of qualified name to markup.\r\n\t\t\tresult.push(qualifiedName);\r\n\r\n\t\t\t// 12.5.5. Append the following to markup, in the order listed:\r\n\t\t\t// NOTE: The following serializes a namespace prefix declaration for prefix which was\r\n\t\t\t// just added to the map.\r\n\t\t\t// 12.5.5.1. \" \" (U+0020 SPACE);\r\n\t\t\t// 12.5.5.2. The string \"xmlns:\";\r\n\t\t\t// 12.5.5.3. The value of prefix;\r\n\t\t\t// 12.5.5.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\r\n\t\t\t// 12.5.5.5. The result of serializing an attribute value given ns and the require\r\n\t\t\t// well-formed flag as input;\r\n\t\t\t// 12.5.5.6. \"\"\" (U+0022 QUOTATION MARK).\r\n\t\t\tresult.push(\r\n\t\t\t\t' xmlns:',\r\n\t\t\t\tprefix,\r\n\t\t\t\t'=\"',\r\n\t\t\t\tserializeAttributeValue(ns, requireWellFormed),\r\n\t\t\t\t'\"'\r\n\t\t\t);\r\n\r\n\t\t\t// 12.5.5.7. If local default namespace is non-null (there exists a locally-defined\r\n\t\t\t// default namespace declaration attribute), then let inherited ns get the value of\r\n\t\t\t// local default namespace unless the local default namespace is the empty string in\r\n\t\t\t// which case let it get null.\r\n\t\t\tif (localDefaultNamespace !== null) {\r\n\t\t\t\tinheritedNs = localDefaultNamespace === '' ? null : localDefaultNamespace;\r\n\t\t\t}\r\n\t\t} else if (\r\n\t\t\tlocalDefaultNamespace === null ||\r\n\t\t\t(localDefaultNamespace !== null && localDefaultNamespace !== ns)\r\n\t\t) {\r\n\t\t\t// 12.6. Otherwise, if local default namespace is null, or local default namespace is\r\n\t\t\t// non-null and its value is not equal to ns, then:\r\n\t\t\t// NOTE: At this point, the namespace for this node still needs to be serialized, but\r\n\t\t\t// there's no prefix (or candidate prefix) availble; the following uses the default\r\n\t\t\t// namespace declaration to define the namespace --optionally replacing an existing\r\n\t\t\t// default declaration if present.\r\n\r\n\t\t\t// 12.6.1. Set the ignore namespace definition attribute flag to true.\r\n\t\t\tignoreNamespaceDefinitionAttribute = true;\r\n\r\n\t\t\t// 12.6.2. Append to qualified name the value of node's localName.\r\n\t\t\tqualifiedName += element.localName;\r\n\r\n\t\t\t// 12.6.3. Let the value of inherited ns be ns.\r\n\t\t\t// NOTE: The new default namespace will be used in the serialization to define this\r\n\t\t\t// node's namespace and act as the context namespace for its children.\r\n\t\t\tinheritedNs = ns;\r\n\r\n\t\t\t// 12.6.4. Append the value of qualified name to markup.\r\n\t\t\tresult.push(qualifiedName);\r\n\r\n\t\t\t// 12.6.5. Append the following to markup, in the order listed:\r\n\t\t\t// NOTE: The following serializes the new (or replacement) default namespace definition.\r\n\t\t\t// 12.6.5.1. \" \" (U+0020 SPACE);\r\n\t\t\t// 12.6.5.2. The string \"xmlns\";\r\n\t\t\t// 12.6.5.3. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\r\n\t\t\t// 12.6.5.4. The result of serializing an attribute value given ns and the require\r\n\t\t\t// well-formed flag as input;\r\n\t\t\t// 12.6.5.5. \"\"\" (U+0022 QUOTATION MARK).\r\n\t\t\tresult.push(' xmlns=\"', serializeAttributeValue(ns, requireWellFormed), '\"');\r\n\t\t} else {\r\n\t\t\t// 12.7. Otherwise, the node has a local default namespace that matches ns. Append to\r\n\t\t\t// qualified name the value of node's localName, let the value of inherited ns be ns,\r\n\t\t\t// and append the value of qualified name to markup.\r\n\t\t\tqualifiedName += element.localName;\r\n\t\t\tinheritedNs = ns;\r\n\t\t\tresult.push(qualifiedName);\r\n\t\t}\r\n\r\n\t\t// NOTE: All of the combinations where ns is not equal to inherited ns are handled above\r\n\t\t// such that node will be serialized preserving its original namespaceURI.\r\n\t}\r\n\r\n\t// 13. Append to markup the result of the XML serialization of node's attributes given map,\r\n\t// prefix index, local prefixes map, ignore namespace definition attribute flag, and require\r\n\t// well-formed flag.\r\n\tserializeAttributes(\r\n\t\telement,\r\n\t\tmap,\r\n\t\tprefixIndex,\r\n\t\tlocalPrefixesMap,\r\n\t\tignoreNamespaceDefinitionAttribute,\r\n\t\trequireWellFormed,\r\n\t\tresult\r\n\t);\r\n\r\n\t// 14. If ns is the HTML namespace, and the node's list of children is empty, and the node's\r\n\t// localName matches any one of the following void elements: \"area\", \"base\", \"basefont\",\r\n\t// \"bgsound\", \"br\", \"col\", \"embed\", \"frame\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"menuitem\",\r\n\t// \"meta\", \"param\", \"source\", \"track\", \"wbr\"; then append the following to markup, in the order\r\n\t// listed:\r\n\tif (\r\n\t\tns === HTML_NAMESPACE &&\r\n\t\t!element.hasChildNodes() &&\r\n\t\tHTML_VOID_ELEMENTS.indexOf(element.localName) >= 0\r\n\t) {\r\n\t\t// 14.1. \" \" (U+0020 SPACE);\r\n\t\t// 14.2. \"/\" (U+002F SOLIDUS).\r\n\t\tresult.push(' /');\r\n\r\n\t\t// and set the skip end tag flag to true.\r\n\t\tskipEndTag = true;\r\n\t}\r\n\r\n\t// 15. If ns is not the HTML namespace, and the node's list of children is empty, then append\r\n\t// \"/\" (U+002F SOLIDUS) to markup and set the skip end tag flag to true.\r\n\tif (ns !== HTML_NAMESPACE && !element.hasChildNodes()) {\r\n\t\tresult.push('/');\r\n\t\tskipEndTag = true;\r\n\t}\r\n\r\n\t// 16. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\r\n\tresult.push('>');\r\n\r\n\t// 17. If the value of skip end tag is true, then return the value of markup and skip the\r\n\t// remaining steps. The node is a leaf-node.\r\n\tif (skipEndTag) {\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 18. If ns is the HTML namespace, and the node's localName matches the string \"template\", then\r\n\t// this is a template element. Append to markup the result of XML serializing a DocumentFragment\r\n\t// node given the template element's template contents (a DocumentFragment), providing inherited\r\n\t// ns, map, prefix index, and the require well-formed flag.\r\n\t// NOTE: This allows template content to round-trip , given the rules for parsing XHTML\r\n\t// documents.\r\n\t// (HTML documents not implemented)\r\n\r\n\t// 19. Otherwise, append to markup the result of running the XML serialization algorithm on each\r\n\t// of node's children, in tree order, providing inherited ns, map, prefix index, and the require\r\n\t// well-formed flag.\r\n\tfor (const child of node.childNodes) {\r\n\t\trunXmlSerializationAlgorithm(\r\n\t\t\tchild,\r\n\t\t\tinheritedNs,\r\n\t\t\tmap,\r\n\t\t\tprefixIndex,\r\n\t\t\trequireWellFormed,\r\n\t\t\tresult\r\n\t\t);\r\n\t}\r\n\r\n\t// 20. Append the following to markup, in the order listed:\r\n\t// 20.1. \"</\" (U+003C LESS-THAN SIGN, U+002F SOLIDUS);\r\n\t// 20.2. The value of qualified name;\r\n\t// 20.3. \">\" (U+003E GREATER-THAN SIGN).\r\n\tresult.push('</', qualifiedName, '>');\r\n\r\n\t// 21. Return the value of markup.\r\n}\r\n\r\n// 3.2.1.1.3 Serializing an Element's attributes\r\n\r\n/**\r\n * The XML serialization of the attributes of an Element element together with a namespace prefix\r\n * map map, a generated namespace prefix index prefix index reference, a local prefixes map, a\r\n * ignore namespace definition attribute flag, and a require well-formed flag, is the result of the\r\n * following algorithm:\r\n *\r\n * @param element                            - The element for which to serialize attributes\r\n * @param prefixMap                          - The namespace prefix map\r\n * @param prefixIndex                        - The generated namespace prefix index, by reference\r\n * @param localPrefixesMap                   - The local prefixes map\r\n * @param ignoreNamespaceDefinitionAttribute - The ignore namespace definition attribute flag\r\n * @param requireWellFormed                  - The require well-formed flag\r\n * @param result                             - Array of strings in which to construct the result\r\n */\r\nfunction serializeAttributes(\r\n\telement: Element,\r\n\tmap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\tlocalPrefixesMap: LocalPrefixesMap,\r\n\tignoreNamespaceDefinitionAttribute: boolean,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\t// 1. Let result be the empty string.\r\n\t// (result constructed in-place in argument)\r\n\r\n\t// 2. Let localname set be a new empty namespace localname set. This localname set will contain\r\n\t// tuples of unique attribute namespaceURI and localName pairs, and is populated as each attr is\r\n\t// processed. This set is used to [optionally] enforce the well-formed constraint that an\r\n\t// element cannot have two attributes with the same namespaceURI and localName. This can occur\r\n\t// when two otherwise identical attributes on the same element differ only by their prefix\r\n\t// values.\r\n\tconst localNameSet: { namespaceURI: string | null; localName: string }[] = [];\r\n\r\n\t// 3. Loop: For each attribute attr in element's attributes, in the order they are specified in\r\n\t// the element's attribute list:\r\n\tfor (const attr of element.attributes) {\r\n\t\t// 3.1. If the require well-formed flag is set (its value is true), and the localname set\r\n\t\t// contains a tuple whose values match those of a new tuple consisting of attr's\r\n\t\t// namespaceURI attribute and localName attribute, then throw an exception; the\r\n\t\t// serialization of this attr would fail to produce a well-formed element serialization.\r\n\t\tif (\r\n\t\t\trequireWellFormed &&\r\n\t\t\tlocalNameSet.find(\r\n\t\t\t\t(tuple) =>\r\n\t\t\t\t\ttuple.localName === attr.localName && tuple.namespaceURI === attr.namespaceURI\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Can not serialize a duplicate attribute for namespaceURI \"${attr.namespaceURI}\", localName \"${attr.localName}\".`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 3.2. Create a new tuple consisting of attr's namespaceURI attribute and localName\r\n\t\t// attribute, and add it to the localname set.\r\n\t\tlocalNameSet.push({ namespaceURI: attr.namespaceURI, localName: attr.localName });\r\n\r\n\t\t// 3.3. Let attribute namespace be the value of attr's namespaceURI value.\r\n\t\tconst attributeNamespace = attr.namespaceURI;\r\n\r\n\t\t// 3.4. Let candidate prefix be null.\r\n\t\tlet candidatePrefix: string | null = null;\r\n\r\n\t\t// 3.5. If attribute namespace is non-null, then run these sub-steps:\r\n\t\tif (attributeNamespace !== null) {\r\n\t\t\t// 3.5.1. Let candidate prefix be the result of retrieving a preferred prefix string\r\n\t\t\t// from map given namespace attribute namespace with preferred prefix being attr's\r\n\t\t\t// prefix value.\r\n\t\t\tcandidatePrefix = map.retrievePreferredPrefixString(attr.prefix, attributeNamespace);\r\n\r\n\t\t\t// 3.5.2. If the value of attribute namespace is the XMLNS namespace, then run these\r\n\t\t\t// steps:\r\n\t\t\tif (attributeNamespace === XMLNS_NAMESPACE) {\r\n\t\t\t\t// 3.5.2.1. If any of the following are true, then stop running these steps and goto\r\n\t\t\t\t// Loop to visit the next attribute:\r\n\t\t\t\t// - the attr's value is the XML namespace;\r\n\t\t\t\t// NOTE: The XML namespace cannot be redeclared and survive round-tripping (unless\r\n\t\t\t\t// it defines the prefix \"xml\"). To avoid this problem, this algorithm always\r\n\t\t\t\t// prefixes elements in the XML namespace with \"xml\" and drops any related\r\n\t\t\t\t// definitions as seen in the above condition.\r\n\t\t\t\tif (attr.value === XML_NAMESPACE) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// - the attr's prefix is null and the ignore namespace definition attribute flag is\r\n\t\t\t\t// true (the Element's default namespace attribute should be skipped);\r\n\t\t\t\tif (attr.prefix === null && ignoreNamespaceDefinitionAttribute) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// - the attr's prefix is non-null and either\r\n\t\t\t\t//   - the attr's localName is not a key contained in the local prefixes map, or\r\n\t\t\t\t//   - the attr's localName is present in the local prefixes map but the value of\r\n\t\t\t\t//     the key does not match attr's value\r\n\t\t\t\tif (\r\n\t\t\t\t\tattr.prefix !== null &&\r\n\t\t\t\t\t(!(attr.localName in localPrefixesMap) ||\r\n\t\t\t\t\t\tlocalPrefixesMap[attr.localName] !== attr.value)\r\n\t\t\t\t) {\r\n\t\t\t\t\t// and furthermore that the attr's localName (as the prefix to find) is found in\r\n\t\t\t\t\t// the namespace prefix map given the namespace consisting of the attr's value\r\n\t\t\t\t\t// (the current namespace prefix definition was exactly defined previously--on\r\n\t\t\t\t\t// an ancestor element not the current element whose attributes are being\r\n\t\t\t\t\t// processed).\r\n\t\t\t\t\t// (the only ways that this xmlns:* attribute can be omitted from the\r\n\t\t\t\t\t// localPrefixesMap is if it is either the XML namespace (control flow would not\r\n\t\t\t\t\t// reach this point), or if it was defined on an ancestor (and is therefore\r\n\t\t\t\t\t// certainly in the map). This last condition seems to be a duplicate attempt to\r\n\t\t\t\t\t// prevent repeated declarations in the spec, which is already prevented by the\r\n\t\t\t\t\t// check in recordNamespaceInformation.)\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.5.2.2. If the require well-formed flag is set (its value is true), and the\r\n\t\t\t\t// value of attr's value attribute matches the XMLNS namespace, then throw an\r\n\t\t\t\t// exception; the serialization of this attribute would produce invalid XML because\r\n\t\t\t\t// the XMLNS namespace is reserved and cannot be applied as an element's namespace\r\n\t\t\t\t// via XML parsing.\r\n\t\t\t\t// NOTE: DOM APIs do allow creation of elements in the XMLNS namespace but with\r\n\t\t\t\t// strict qualifications.\r\n\t\t\t\tif (requireWellFormed && attr.value === XMLNS_NAMESPACE) {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t'The serialization of this attribute would produce invalid XML because ' +\r\n\t\t\t\t\t\t\t'the XMLNS namespace is reserved and cannot be applied as an ' +\r\n\t\t\t\t\t\t\t\"element's namespace via XML parsing.\"\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.5.2.3. If the require well-formed flag is set (its value is true), and the\r\n\t\t\t\t// value of attr's value attribute is the empty string, then throw an exception;\r\n\t\t\t\t// namespace prefix declarations cannot be used to undeclare a namespace (use a\r\n\t\t\t\t// default namespace declaration instead).\r\n\t\t\t\t// (we deviate from the spec here by only throwing for prefix declarations, the\r\n\t\t\t\t// implementations of this in browsers and the spec text suggest that default\r\n\t\t\t\t// namespace declarations should be allowed to reset the default namespace to null)\r\n\t\t\t\tif (requireWellFormed && attr.prefix !== null && attr.value === '') {\r\n\t\t\t\t\tthrow new Error(\r\n\t\t\t\t\t\t'Namespace prefix declarations cannot be used to undeclare a namespace. ' +\r\n\t\t\t\t\t\t\t'Use a default namespace declaration instead.'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// 3.5.2.4. the attr's prefix matches the string \"xmlns\", then let candidate prefix\r\n\t\t\t\t// be the string \"xmlns\".\r\n\t\t\t\tif (attr.prefix === 'xmlns') {\r\n\t\t\t\t\tcandidatePrefix = 'xmlns';\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\t// 3.5.3. Otherwise, the attribute namespace in not the XMLNS namespace. Run these\r\n\t\t\t\t// steps:\r\n\t\t\t\t// (interpreting this as a typo in the spec: \"in\" should probably have been \"is\")\r\n\r\n\t\t\t\t// (We need to deviate from the spec here, as implementing as specified would always\r\n\t\t\t\t// generate prefixes for all namespaced attributes. Instead, first check if no valid\r\n\t\t\t\t// candidate prefix was found in the steps above.)\r\n\t\t\t\tif (candidatePrefix === null) {\r\n\t\t\t\t\t// (Again, we need to deviate from the spec to make sure we prefer the attr's\r\n\t\t\t\t\t// own prefix over a generated prefix where that would not conflict with\r\n\t\t\t\t\t// existing definitions.)\r\n\t\t\t\t\tif (attr.prefix === null || attr.prefix in localPrefixesMap) {\r\n\t\t\t\t\t\t// 3.5.3.1. Let candidate prefix be the result of generating a prefix\r\n\t\t\t\t\t\t// providing map, attribute namespace, and prefix index as input.\r\n\t\t\t\t\t\tcandidatePrefix = generatePrefix(map, attributeNamespace, prefixIndex);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tcandidatePrefix = attr.prefix;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// Update the local and aggregate prefixes to account for the new declaration.\r\n\t\t\t\t\tmap.add(candidatePrefix, attr.namespaceURI);\r\n\t\t\t\t\tlocalPrefixesMap[candidatePrefix] = attr.namespaceURI;\r\n\r\n\t\t\t\t\t// 3.5.3.2. Append the following to result, in the order listed:\r\n\t\t\t\t\t// 3.5.3.2.1. \" \" (U+0020 SPACE);\r\n\t\t\t\t\t// 3.5.3.2.2. The string \"xmlns:\";\r\n\t\t\t\t\t// 3.5.3.2.3. The value of candidate prefix;\r\n\t\t\t\t\t// 3.5.3.2.4. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\r\n\t\t\t\t\t// 3.5.3.2.5. The result of serializing an attribute value given attribute\r\n\t\t\t\t\t// namespace and the require well-formed flag as input;\r\n\t\t\t\t\t// 3.5.3.2.7. \"\"\" (U+0022 QUOTATION MARK).\r\n\t\t\t\t\tresult.push(\r\n\t\t\t\t\t\t' xmlns:',\r\n\t\t\t\t\t\tcandidatePrefix,\r\n\t\t\t\t\t\t'=\"',\r\n\t\t\t\t\t\tserializeAttributeValue(attributeNamespace, requireWellFormed),\r\n\t\t\t\t\t\t'\"'\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// 3.6. Append a \" \" (U+0020 SPACE) to result.\r\n\t\tresult.push(' ');\r\n\r\n\t\t// 3.7. If candidate prefix is non-null, then append to result the concatenation of\r\n\t\t// candidate prefix with \":\" (U+003A COLON).\r\n\t\tif (candidatePrefix !== null) {\r\n\t\t\tresult.push(candidatePrefix, ':');\r\n\t\t}\r\n\r\n\t\t// 3.8. If the require well-formed flag is set (its value is true), and this attr's\r\n\t\t// localName attribute contains the character \":\" (U+003A COLON) or does not match the XML\r\n\t\t// Name production or equals \"xmlns\" and attribute namespace is null, then throw an\r\n\t\t// exception; the serialization of this attr would not be a well-formed attribute.\r\n\t\tif (\r\n\t\t\trequireWellFormed &&\r\n\t\t\t(attr.localName.indexOf(':') >= 0 ||\r\n\t\t\t\t!matchesNameProduction(attr.localName) ||\r\n\t\t\t\t(attr.localName === 'xmlns' && attributeNamespace === null))\r\n\t\t) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Can not serialize an attribute because the localName \"${attr.localName}\" is not allowed.`\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 3.9. Append the following strings to result, in the order listed:\r\n\t\t// 3.9.1. The value of attr's localName;\r\n\t\t// 3.9.2. \"=\"\" (U+003D EQUALS SIGN, U+0022 QUOTATION MARK);\r\n\t\t// 3.9.3. The result of serializing an attribute value given attr's value attribute and the\r\n\t\t// require well-formed flag as input;\r\n\t\t// 3.9.4. \"\"\" (U+0022 QUOTATION MARK).\r\n\t\tresult.push(\r\n\t\t\tattr.localName,\r\n\t\t\t'=\"',\r\n\t\t\tserializeAttributeValue(attr.value, requireWellFormed),\r\n\t\t\t'\"'\r\n\t\t);\r\n\t}\r\n\r\n\t// 4. Return the value of result.\r\n}\r\n\r\n/**\r\n * When serializing an attribute value given an attribute value and require well-formed flag, the\r\n * user agent must run the following steps:\r\n *\r\n * @param attributeValue    - The attribute value to serialize\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n *\r\n * @returns The serialized attribute value\r\n */\r\nfunction serializeAttributeValue(\r\n\tattributeValue: string | null,\r\n\trequireWellFormed: boolean\r\n): string {\r\n\t// 1. If the require well-formed flag is set (its value is true), and attribute value contains\r\n\t// characters that are not matched by the XML Char production, then throw an exception; the\r\n\t// serialization of this attribute value would fail to produce a well-formed element\r\n\t// serialization.\r\n\tif (\r\n\t\trequireWellFormed &&\r\n\t\tattributeValue !== null &&\r\n\t\t!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(attributeValue)\r\n\t) {\r\n\t\tthrow new Error(\r\n\t\t\t'Can not serialize an attribute value because it contains invalid characters.'\r\n\t\t);\r\n\t}\r\n\r\n\t// 2. If attribute value is null, then return the empty string.\r\n\tif (attributeValue === null) {\r\n\t\treturn '';\r\n\t}\r\n\r\n\t// 3. Otherwise, attribute value is a string. Return the value of attribute value, first\r\n\t// replacing any occurrences of the following:\r\n\treturn (\r\n\t\tattributeValue\r\n\t\t\t// 3.1. \"&\" with \"&amp;\"\r\n\t\t\t.replace(/&/g, '&amp;')\r\n\t\t\t// 3.2. \"\"\" with \"&quot;\"\r\n\t\t\t.replace(/\"/g, '&quot;')\r\n\t\t\t// 3.3. \"<\" with \"&lt;\"\r\n\t\t\t.replace(/</g, '&lt;')\r\n\t\t\t// 3.4. \">\" with \"&gt;\"\r\n\t\t\t.replace(/>/g, '&gt;')\r\n\t\t\t// (we deviate from the spec here to also escape whitespace characters, this matches\r\n\t\t\t// the behavior of Chrome, Firefox and Edge, although the specific encoding varies\r\n\t\t\t// between those browsers)\r\n\t\t\t.replace(/\\t/g, '&#9;')\r\n\t\t\t.replace(/\\n/g, '&#10;')\r\n\t\t\t.replace(/\\r/g, '&#13;')\r\n\t);\r\n\r\n\t// NOTE: This matches behavior present in browsers, and goes above and beyond the grammar\r\n\t// requirement in the XML specification's AttValue production by also replacing \">\" characters.\r\n}\r\n\r\n// 3.2.1.1.4 Generating namespace prefixes\r\n\r\n/**\r\n * To generate a prefix given a namespace prefix map map, a string new namespace, and a reference to\r\n * a generated namespace prefix index prefix index, the user agent must run the following steps:\r\n *\r\n * @param map          - The namespace prefix map\r\n * @param newNamespace - The new namespace to generate a prefix for\r\n * @param prefixIndex  - The reference to the generated namespace prefix index\r\n *\r\n * @returns The generated prefix for the new namespace\r\n */\r\nfunction generatePrefix(\r\n\tmap: NamespacePrefixMap,\r\n\tnewNamespace: string | null,\r\n\tprefixIndex: PrefixIndex\r\n): string {\r\n\t// 1. Let generated prefix be the concatenation of the string \"ns\" and the current numerical\r\n\t// value of prefix index.\r\n\tconst generatedPrefix = 'ns' + prefixIndex.value;\r\n\r\n\t// 2. Let the value of prefix index be incremented by one.\r\n\tprefixIndex.value += 1;\r\n\r\n\t// 3. Add to map the generated prefix given the new namespace namespace.\r\n\tmap.add(generatedPrefix, newNamespace);\r\n\r\n\t// 4. Return the value of generated prefix.\r\n\treturn generatedPrefix;\r\n}\r\n\r\n/**\r\n * 3.2.1.2 XML serializing a Document node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeDocumentNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\tconst document = node as Document;\r\n\t// 1. If the require well-formed flag is set (its value is true), and this node has no\r\n\t// documentElement (the documentElement attribute's value is null), then throw an exception; the\r\n\t// serialization of this node would not be a well-formed document.\r\n\tif (requireWellFormed && document.documentElement === null) {\r\n\t\tthrow new Error('Can not serialize a document with no documentElement.');\r\n\t}\r\n\r\n\t// 2. Otherwise, run the following steps:\r\n\r\n\t// 2.1. Let serialized document be an empty string.\r\n\t// (constructed in-place in result argument)\r\n\r\n\t// 2.2. For each child child of node, in tree order, run the XML serialization algorithm on the\r\n\t// child passing along the provided arguments, and append the result to serialized document.\r\n\t// NOTE: This will serialize any number of ProcessingInstruction and Comment nodes both before\r\n\t// and after the Document's documentElement node, including at most one DocumentType node. (Text\r\n\t// nodes are not allowed as children of the Document.)\r\n\tfor (const child of document.childNodes) {\r\n\t\trunXmlSerializationAlgorithm(\r\n\t\t\tchild,\r\n\t\t\tnamespace,\r\n\t\t\tprefixMap,\r\n\t\t\tprefixIndex,\r\n\t\t\trequireWellFormed,\r\n\t\t\tresult\r\n\t\t);\r\n\t}\r\n\r\n\t// 2.3. Return the value of serialized document.\r\n}\r\n\r\n/**\r\n * 3.2.1.3 XML serializing a Comment node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeCommentNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\tconst comment = node as Comment;\r\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\r\n\t// characters that are not matched by the XML Char production or contains \"--\" (two adjacent\r\n\t// U+002D HYPHEN-MINUS characters) or that ends with a \"-\" (U+002D HYPHEN-MINUS) character, then\r\n\t// throw an exception; the serialization of this node's data would not be well-formed.\r\n\tif (\r\n\t\trequireWellFormed &&\r\n\t\t(!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(comment.data) ||\r\n\t\t\tcomment.data.indexOf('--') >= 0 ||\r\n\t\t\tcomment.data.endsWith('-'))\r\n\t) {\r\n\t\tthrow new Error('Can not serialize a comment because it contains invalid characters.');\r\n\t}\r\n\r\n\t// 2. Otherwise, return the concatenation of \"<!--\", node's data, and \"-->\".\r\n\tresult.push('<!--', comment.data, '-->');\r\n}\r\n\r\n/**\r\n * (not currently in spec) XML serializing a CDATASection node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeCDATASectionNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\tconst cs = node as CDATASection;\r\n\r\n\t// 1. Let markup be the concatenation of \"<![CDATA[\", node's data, and \"]]>\".\r\n\tresult.push('<![CDATA[', cs.data, ']]>');\r\n\r\n\t// 2. Return the value of markup.\r\n}\r\n\r\n/**\r\n * 3.2.1.4 XML serializing a Text node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeTextNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\tconst text = node as Text;\r\n\t// 1. If the require well-formed flag is set (its value is true), and node's data contains\r\n\t// characters that are not matched by the XML Char production, then throw an exception; the\r\n\t// serialization of this node's data would not be well-formed.\r\n\tif (requireWellFormed && !CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(text.data)) {\r\n\t\tthrow new Error('Can not serialize a text node because it contains invalid characters.');\r\n\t}\r\n\r\n\t// 2. Let markup be the value of node's data.\r\n\tlet markup = text.data;\r\n\r\n\t// 3. Replace any occurrences of \"&\" in markup by \"&amp;\".\r\n\tmarkup = markup.replace(/&/g, '&amp;');\r\n\r\n\t// 4. Replace any occurrences of \"<\" in markup by \"&lt;\".\r\n\tmarkup = markup.replace(/</g, '&lt;');\r\n\r\n\t// 5. Replace any occurrences of \">\" in markup by \"&gt;\".\r\n\tmarkup = markup.replace(/>/g, '&gt;');\r\n\r\n\t// 6. Return the value of markup.\r\n\tresult.push(markup);\r\n}\r\n\r\n/**\r\n * 3.2.1.5 XML serializing a DocumentFragment node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeDocumentFragmentNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\t// 1. Let markup the empty string.\r\n\t// (constructed in-place in result argument)\r\n\r\n\t// 2. For each child child of node, in tree order, run the XML serialization algorithm on the\r\n\t// child given namespace, prefix map, a reference to prefix index, and flag require well-formed.\r\n\t// Concatenate the result to markup.\r\n\tfor (const child of node.childNodes) {\r\n\t\trunXmlSerializationAlgorithm(\r\n\t\t\tchild,\r\n\t\t\tnamespace,\r\n\t\t\tprefixMap,\r\n\t\t\tprefixIndex,\r\n\t\t\trequireWellFormed,\r\n\t\t\tresult\r\n\t\t);\r\n\t}\r\n\r\n\t// 3. Return the value of markup.\r\n}\r\n\r\n/**\r\n * 3.2.1.6 XML serializing a DocumentType node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeDocumentTypeNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\tconst dt = node as DocumentType;\r\n\t// 1. If the require well-formed flag is true and the node's publicId attribute contains\r\n\t// characters that are not matched by the XML PubidChar production, then throw an exception; the\r\n\t// serialization of this node would not be a well-formed document type declaration.\r\n\tif (requireWellFormed && !PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.publicId)) {\r\n\t\tthrow new Error(\r\n\t\t\t'Can not serialize a document type because the publicId contains invalid characters.'\r\n\t\t);\r\n\t}\r\n\r\n\t// 2. If the require well-formed flag is true and the node's systemId attribute contains\r\n\t// characters that are not matched by the XML Char production or that contains both a \"\"\"\r\n\t// (U+0022 QUOTATION MARK) and a \"'\" (U+0027 APOSTROPHE), then throw an exception; the\r\n\t// serialization of this node would not be a well-formed document type declaration.\r\n\tif (\r\n\t\trequireWellFormed &&\r\n\t\t(!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(dt.systemId) ||\r\n\t\t\t(dt.systemId.indexOf('\"') >= 0 && dt.systemId.indexOf(\"'\") >= 0))\r\n\t) {\r\n\t\tthrow new Error(\r\n\t\t\t'Can not serialize a document type because the systemId contains invalid characters.'\r\n\t\t);\r\n\t}\r\n\r\n\t// 3. Let markup be an empty string.\r\n\t// (constructed in-place in result argument)\r\n\r\n\t// 4. Append the string \"<!DOCTYPE\" to markup.\r\n\tresult.push('<!DOCTYPE');\r\n\r\n\t// 5. Append \" \" (U+0020 SPACE) to markup.\r\n\tresult.push(' ');\r\n\r\n\t// 6. Append the value of the node's name attribute to markup. For a node belonging to an HTML\r\n\t// document, the value will be all lowercase.\r\n\t// (HTML documents not implemented)\r\n\tresult.push(dt.name);\r\n\r\n\t// 7. If the node's publicId is not the empty string then append the following, in the order\r\n\t// listed, to markup:\r\n\tif (dt.publicId !== '') {\r\n\t\t// 7.1. \" \" (U+0020 SPACE);\r\n\t\t// 7.2. The string \"PUBLIC\";\r\n\t\t// 7.3. \" \" (U+0020 SPACE);\r\n\t\t// 7.4. \"\"\" (U+0022 QUOTATION MARK);\r\n\t\t// 7.5. The value of the node's publicId attribute;\r\n\t\t// 7.6. \"\"\" (U+0022 QUOTATION MARK).\r\n\t\tresult.push(' PUBLIC \"', dt.publicId, '\"');\r\n\t}\r\n\r\n\t// 8. If the node's systemId is not the empty string and the node's publicId is set to the empty\r\n\t// string, then append the following, in the order listed, to markup:\r\n\tif (dt.systemId !== '' && dt.publicId === '') {\r\n\t\t// 8.1. \" \" (U+0020 SPACE);\r\n\t\t// 8.2. The string \"SYSTEM\".\r\n\t\tresult.push(' SYSTEM');\r\n\t}\r\n\r\n\t// 9. If the node's systemId is not the empty string then append the following, in the order\r\n\t// listed, to markup:\r\n\tif (dt.systemId !== '') {\r\n\t\t// 9.1. \" \" (U+0020 SPACE);\r\n\t\t// 9.2. \"\"\" (U+0022 QUOTATION MARK);\r\n\t\t// 9.3. The value of the node's systemId attribute;\r\n\t\t// 9.4. \"\"\" (U+0022 QUOTATION MARK).\r\n\t\tresult.push(' \"', dt.systemId, '\"');\r\n\t}\r\n\r\n\t// 10. Append \">\" (U+003E GREATER-THAN SIGN) to markup.\r\n\tresult.push('>');\r\n\r\n\t// 11. Return the value of markup.\r\n}\r\n\r\n/**\r\n * 3.2.1.7 XML serializing a ProcessingInstruction node\r\n *\r\n * @param node              - The node to serialize\r\n * @param namespace         - The context namespace\r\n * @param prefixMap         - The namespace prefix map\r\n * @param prefixIndex       - A reference to the generated namespace prefix index\r\n * @param requireWellFormed - Determines whether the result needs to be well-formed\r\n * @param result            - Array of strings in which to construct the result\r\n */\r\nfunction serializeProcessingInstructionNode(\r\n\tnode: Node,\r\n\tnamespace: string | null,\r\n\tprefixMap: NamespacePrefixMap,\r\n\tprefixIndex: PrefixIndex,\r\n\trequireWellFormed: boolean,\r\n\tresult: string[]\r\n): void {\r\n\tconst pi = node as ProcessingInstruction;\r\n\t// 1. If the require well-formed flag is set (its value is true), and node's target contains a\r\n\t// \":\" (U+003A COLON) character or is an ASCII case-insensitive match for the string \"xml\", then\r\n\t// throw an exception; the serialization of this node's target would not be well-formed.\r\n\tif (requireWellFormed) {\r\n\t\tif (pi.target.indexOf(':') >= 0) {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t`Can not serialize a processing instruction because the target \"${pi.target}\" may not contain \":\".`\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (pi.target.toLowerCase() === 'xml') {\r\n\t\t\tthrow new Error(\r\n\t\t\t\t'Can not serialize a processing instruction because \"xml\" may not be used as target.'\r\n\t\t\t);\r\n\t\t}\r\n\t}\r\n\r\n\t// 2. If the require well-formed flag is set (its value is true), and node's data contains\r\n\t// characters that are not matched by the XML Char production or contains the string \"?>\"\r\n\t// (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN), then throw an exception; the serialization\r\n\t// of this node's data would not be well-formed.\r\n\tif (\r\n\t\trequireWellFormed &&\r\n\t\t(!CHAR_REGEX_XML_1_0_FIFTH_EDITION.test(pi.data) || pi.data.indexOf('?>') >= 0)\r\n\t) {\r\n\t\tthrow new Error(\r\n\t\t\t'Can not serialize a processing instruction because the data contains invalid characters.'\r\n\t\t);\r\n\t}\r\n\r\n\t// 3. Let markup be the concatenation of the following, in the order listed:\r\n\t// 3.1. \"<?\" (U+003C LESS-THAN SIGN, U+003F QUESTION MARK);\r\n\t// 3.2. The value of node's target;\r\n\t// 3.3. \" \" (U+0020 SPACE);\r\n\t// 3.4. The value of node's data;\r\n\t// 3.5. \"?>\" (U+003F QUESTION MARK, U+003E GREATER-THAN SIGN).\r\n\tresult.push('<?', pi.target, ' ', pi.data, '?>');\r\n\r\n\t// 4. Return the value of markup.\r\n}\r\n","import { ParentNode, NonDocumentTypeChildNode, ChildNode } from './mixins';\r\nimport { getChildren, getPreviousElementSibling, getNextElementSibling } from './mixins';\r\nimport Attr from './Attr';\r\nimport Document from './Document';\r\nimport Node from './Node';\r\nimport { getContext } from './context/Context';\r\nimport { serializeFragment } from './dom-parsing/serializationAlgorithms';\r\nimport {\r\n\tappendNodes,\r\n\tgetDescendantTextContent,\r\n\tinsertNodesAfter,\r\n\tinsertNodesBefore,\r\n\tprependNodes,\r\n\tremoveFromParent,\r\n\treplaceChildren,\r\n\treplaceWithNodes,\r\n\tstringReplaceAll,\r\n} from './util/mutationAlgorithms';\r\nimport {\r\n\tappendAttribute,\r\n\tchangeAttribute,\r\n\tremoveAttribute,\r\n\treplaceAttribute,\r\n} from './util/attrMutations';\r\nimport {\r\n\texpectArity,\r\n\tthrowInUseAttributeError,\r\n\tthrowInvalidCharacterError,\r\n\tthrowNotFoundError,\r\n} from './util/errorHelpers';\r\nimport {\r\n\tmatchesNameProduction,\r\n\tvalidateAndExtract,\r\n\tlocateNamespacePrefix,\r\n\tXMLNS_NAMESPACE,\r\n} from './util/namespaceHelpers';\r\nimport { NodeType } from './util/NodeType';\r\nimport { asNullableString, asObject, ifNullActAsIfEmptyString } from './util/typeHelpers';\r\nimport {\r\n\tgetListOfElementsWithNamespaceAndLocalName,\r\n\tgetListOfElementsWithQualifiedName,\r\n} from './util/treeHelpers';\r\n\r\n/**\r\n * 3.9. Interface Element\r\n *\r\n * @public\r\n */\r\nexport default class Element\r\n\textends Node\r\n\timplements ParentNode, NonDocumentTypeChildNode, ChildNode\r\n{\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.ELEMENT_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn this.tagName;\r\n\t}\r\n\r\n\tpublic get nodeValue(): string | null {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic set nodeValue(newValue: string | null) {\r\n\t\t// Do nothing.\r\n\t}\r\n\r\n\tpublic get textContent(): string | null {\r\n\t\t// Return the descendant text content of this\r\n\t\treturn getDescendantTextContent(this);\r\n\t}\r\n\r\n\tpublic set textContent(newValue: string | null) {\r\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\r\n\t\tstringReplaceAll(this, newValue);\r\n\t}\r\n\r\n\tpublic lookupPrefix(namespace: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnamespace = asNullableString(namespace);\r\n\r\n\t\t// 1. If namespace is null or the empty string, then return null.\r\n\t\tif (namespace === null || namespace === '') {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 2. Switch on this:\r\n\t\t// Element - Return the result of locating a namespace prefix for it using namespace.\r\n\t\treturn locateNamespacePrefix(this, namespace);\r\n\t}\r\n\r\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\t\tprefix = asNullableString(prefix);\r\n\r\n\t\t// 1. If prefix is the empty string, then set it to null.\r\n\t\tif (prefix === '') {\r\n\t\t\tprefix = null;\r\n\t\t}\r\n\r\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\r\n\r\n\t\t// To locate a namespace for a node using prefix, switch on node: Element\r\n\t\t// 1. If its namespace is non-null and its namespace prefix is prefix, then return\r\n\t\t// namespace.\r\n\t\tif (this.namespaceURI !== null && this.prefix === prefix) {\r\n\t\t\treturn this.namespaceURI;\r\n\t\t}\r\n\r\n\t\t// 2. If it has an attribute whose namespace is the XMLNS namespace, namespace prefix is\r\n\t\t// \"xmlns\", and local name is prefix, or if prefix is null and it has an attribute whose\r\n\t\t// namespace is the XMLNS namespace, namespace prefix is null, and local name is \"xmlns\",\r\n\t\t// then return its value if it is not the empty string, and null otherwise.\r\n\t\tlet ns = null;\r\n\t\tif (prefix !== null) {\r\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, prefix);\r\n\t\t\tif (attr && attr.prefix === 'xmlns') {\r\n\t\t\t\tns = attr.value;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tconst attr = this.getAttributeNodeNS(XMLNS_NAMESPACE, 'xmlns');\r\n\t\t\tif (attr && attr.prefix === null) {\r\n\t\t\t\tns = attr.value;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (ns !== null) {\r\n\t\t\treturn ns !== '' ? ns : null;\r\n\t\t}\r\n\r\n\t\t// 3. If its parent element is null, then return null.\r\n\t\tconst parentElement = this.parentElement;\r\n\t\tif (parentElement === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 4. Return the result of running locate a namespace on its parent element using prefix.\r\n\t\treturn parentElement.lookupNamespaceURI(prefix);\r\n\t}\r\n\r\n\t// ChildNode\r\n\r\n\tpublic before(...nodes: (Node | string)[]): void {\r\n\t\tinsertNodesBefore(this, nodes);\r\n\t}\r\n\r\n\tpublic after(...nodes: (Node | string)[]): void {\r\n\t\tinsertNodesAfter(this, nodes);\r\n\t}\r\n\r\n\tpublic replaceWith(...nodes: (Node | string)[]): void {\r\n\t\treplaceWithNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic remove(): void {\r\n\t\tremoveFromParent(this);\r\n\t}\r\n\r\n\t// ParentNode\r\n\r\n\tpublic get children(): Element[] {\r\n\t\treturn getChildren(this);\r\n\t}\r\n\r\n\tpublic firstElementChild: Element | null = null;\r\n\tpublic lastElementChild: Element | null = null;\r\n\tpublic childElementCount: number = 0;\r\n\r\n\tpublic prepend(...nodes: (Node | string)[]): void {\r\n\t\tprependNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic append(...nodes: (Node | string)[]): void {\r\n\t\tappendNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\r\n\t\treplaceChildren(this, nodes);\r\n\t}\r\n\r\n\t// NonDocumentTypeChildNode\r\n\r\n\tpublic get previousElementSibling(): Element | null {\r\n\t\treturn getPreviousElementSibling(this);\r\n\t}\r\n\r\n\tpublic get nextElementSibling(): Element | null {\r\n\t\treturn getNextElementSibling(this);\r\n\t}\r\n\r\n\t// Element\r\n\r\n\tpublic readonly namespaceURI: string | null;\r\n\tpublic readonly prefix: string | null;\r\n\tpublic readonly localName: string;\r\n\tpublic readonly tagName: string;\r\n\r\n\t/**\r\n\t * (non-standard) Use Document#createElement or Document#createElementNS to create an Element.\r\n\t *\r\n\t * @param namespace - Namespace for the element\r\n\t * @param prefix    - Prefix for the element\r\n\t * @param localName - Local name for the element\r\n\t */\r\n\tconstructor(namespace: string | null, prefix: string | null, localName: string) {\r\n\t\tsuper();\r\n\r\n\t\tthis.namespaceURI = namespace;\r\n\t\tthis.prefix = prefix;\r\n\t\tthis.localName = localName;\r\n\t\tthis.tagName = prefix === null ? localName : `${prefix}:${localName}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns whether the element has any attributes.\r\n\t *\r\n\t * @returns True if the element has attributes, otherwise false\r\n\t */\r\n\tpublic hasAttributes(): boolean {\r\n\t\treturn this.attributes.length > 0;\r\n\t}\r\n\r\n\t/**\r\n\t * The attributes for the element.\r\n\t *\r\n\t * Non-standard: the spec defines this as a NamedNodeMap, while this implementation uses an\r\n\t * array.\r\n\t */\r\n\tpublic readonly attributes: Attr[] = [];\r\n\r\n\t/**\r\n\t * Get the value of the specified attribute.\r\n\t *\r\n\t * @param qualifiedName - The qualified name of the attribute\r\n\t *\r\n\t * @returns The value of the attribute, or null if no such attribute exists\r\n\t */\r\n\tpublic getAttribute(qualifiedName: string): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\t// 1. Let attr be the result of getting an attribute given qualifiedName and the context\r\n\t\t// object.\r\n\t\tconst attr = getAttributeByName(qualifiedName, this);\r\n\r\n\t\t// 2. If attr is null, return null.\r\n\t\tif (attr === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 3. Return attr’s value.\r\n\t\treturn attr.value;\r\n\t}\r\n\r\n\t/**\r\n\t * Get the value of the specified attribute.\r\n\t *\r\n\t * @param namespace - The namespace of the attribute\r\n\t * @param localName - The local name of the attribute\r\n\t *\r\n\t * @returns The value of the attribute, or null if no such attribute exists\r\n\t */\r\n\tpublic getAttributeNS(namespace: string | null, localName: string): string | null {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\t// 1. Let attr be the result of getting an attribute given namespace, localName, and the\r\n\t\t// this.\r\n\t\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, this);\r\n\r\n\t\t// 2. If attr is null, return null.\r\n\t\tif (attr === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 3. Return attr’s value.\r\n\t\treturn attr.value;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value of the specified attribute.\r\n\t *\r\n\t * @param qualifiedName - The qualified name of the attribute\r\n\t * @param value         - The new value for the attribute\r\n\t */\r\n\tpublic setAttribute(qualifiedName: string, value: string): void {\r\n\t\texpectArity(arguments, 2);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\t\tvalue = String(value);\r\n\r\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\r\n\t\t// InvalidCharacterError.\r\n\t\tif (!matchesNameProduction(qualifiedName)) {\r\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\r\n\t\t}\r\n\r\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\r\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\r\n\t\t// (html documents not implemented)\r\n\r\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\r\n\t\t// qualified name is qualifiedName, and null otherwise.\r\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\r\n\r\n\t\t// 4. If attribute is null, create an attribute whose local name is qualifiedName, value is\r\n\t\t// value, and node document is this’s node document, then append this attribute to\r\n\t\t// this, and then return.\r\n\t\tif (attribute === null) {\r\n\t\t\tconst context = getContext(this);\r\n\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, value, this);\r\n\t\t\tattribute.ownerDocument = this.ownerDocument;\r\n\t\t\tappendAttribute(attribute, this);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 5. Change attribute to value.\r\n\t\tchangeAttribute(attribute, value);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the value of the specified attribute.\r\n\t *\r\n\t * @param namespace     - The namespace of the attribute\r\n\t * @param qualifiedName - The qualified name of the attribute\r\n\t * @param value         - The value for the attribute\r\n\t */\r\n\tpublic setAttributeNS(namespace: string | null, qualifiedName: string, value: string): void {\r\n\t\texpectArity(arguments, 3);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\t\tvalue = String(value);\r\n\r\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\r\n\t\t// qualifiedName to validate and extract.\r\n\t\tconst {\r\n\t\t\tnamespace: validatedNamespace,\r\n\t\t\tprefix,\r\n\t\t\tlocalName,\r\n\t\t} = validateAndExtract(namespace, qualifiedName);\r\n\r\n\t\t// 2. Set an attribute value for this using localName, value, and also prefix\r\n\t\t// and namespace.\r\n\t\tsetAttributeValue(this, localName, value, prefix, validatedNamespace);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the specified attribute.\r\n\t *\r\n\t * @param qualifiedName - The qualified name of the attribute\r\n\t */\r\n\tpublic removeAttribute(qualifiedName: string): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\tremoveAttributeByName(qualifiedName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the specified attribute.\r\n\t *\r\n\t * @param namespace - The namespace of the attribute\r\n\t * @param localName - The local name of the attribute\r\n\t */\r\n\tpublic removeAttributeNS(namespace: string | null, localName: string): void {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\tremoveAttributeByNamespaceAndLocalName(namespace, localName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * If force is not given, \"toggles\" qualifiedName, removing it if it is present and adding it if\r\n\t * it is not present. If force is true, adds qualifiedName. If force is false, removes\r\n\t * qualifiedName.\r\n\t *\r\n\t * Returns true if qualifiedName is now present, and false otherwise.\r\n\t *\r\n\t * @param qualifiedName - The qualified name of the attribute to toggle\r\n\t * @param force         - If true, adds the attribute, if false removes it\r\n\t */\r\n\tpublic toggleAttribute(qualifiedName: string, force?: boolean): boolean {\r\n\t\t// 1. If qualifiedName does not match the Name production in XML, then throw an\r\n\t\t// \"InvalidCharacterError\" DOMException.\r\n\t\tif (!matchesNameProduction(qualifiedName)) {\r\n\t\t\tthrowInvalidCharacterError('The qualified name does not match the Name production');\r\n\t\t}\r\n\r\n\t\t// 2. If this is in the HTML namespace and its node document is an HTML\r\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\r\n\t\t// (html documents not implemented)\r\n\r\n\t\t// 3. Let attribute be the first attribute in this’s attribute list whose\r\n\t\t// qualified name is qualifiedName, and null otherwise.\r\n\t\tconst attribute = getAttributeByName(qualifiedName, this);\r\n\r\n\t\t// 4. If attribute is null, then:\r\n\t\tif (attribute === null) {\r\n\t\t\t// 4.1. If force is not given or is true,\r\n\t\t\tif (force === undefined || force === true) {\r\n\t\t\t\t// ...create an attribute whose local name is qualifiedName, value is the empty\r\n\t\t\t\t// string, and node document is this’s node document,\r\n\t\t\t\tconst context = getContext(this);\r\n\t\t\t\tconst attribute = new context.Attr(null, null, qualifiedName, '', this);\r\n\t\t\t\tattribute.ownerDocument = this.ownerDocument;\r\n\t\t\t\t// ...then append this attribute to this,\r\n\t\t\t\tappendAttribute(attribute, this);\r\n\t\t\t\t// ...and then return true.\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// 4.2. Return false.\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 5. Otherwise, if force is not given or is false,\r\n\t\tif (force === undefined || force === false) {\r\n\t\t\t// ...remove an attribute given qualifiedName and this,\r\n\t\t\tremoveAttributeByName(qualifiedName, this);\r\n\t\t\t// ...and then return false.\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 6. Return true.\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the specified attribute exists and false otherwise.\r\n\t *\r\n\t * @param qualifiedName - The qualified name of the attribute\r\n\t */\r\n\tpublic hasAttribute(qualifiedName: string): boolean {\r\n\t\texpectArity(arguments, 1);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\t// 1. If this is in the HTML namespace and its node document is an HTML\r\n\t\t// document, then set qualifiedName to qualifiedName in ASCII lowercase.\r\n\t\t// (html documents not implemented)\r\n\r\n\t\t// 2. Return true if this has an attribute whose qualified name is\r\n\t\t// qualifiedName, and false otherwise.\r\n\t\treturn getAttributeByName(qualifiedName, this) !== null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the specified attribute exists and false otherwise.\r\n\t *\r\n\t * @param namespace - The namespace of the attribute\r\n\t * @param localName - The local name of the attribute\r\n\t */\r\n\tpublic hasAttributeNS(namespace: string | null, localName: string): boolean {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\t// 1. If namespace is the empty string, set it to null.\r\n\t\t// (handled by getAttributeByNamespaceAndLocalName, called below)\r\n\t\t// 2. Return true if this has an attribute whose namespace is namespace and\r\n\t\t// local name is localName, and false otherwise.\r\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this) !== null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the specified attribute node, or null if no such attribute exists.\r\n\t *\r\n\t * @param qualifiedName - The qualified name of the attribute\r\n\t *\r\n\t * @returns The attribute, or null if no such attribute exists\r\n\t */\r\n\tpublic getAttributeNode(qualifiedName: string): Attr | null {\r\n\t\texpectArity(arguments, 1);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\treturn getAttributeByName(qualifiedName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the specified attribute node, or null if no such attribute exists.\r\n\t *\r\n\t * @param namespace - The namespace of the attribute\r\n\t * @param localName - The local name of the attribute\r\n\t *\r\n\t * @returns The attribute, or null if no such attribute exists\r\n\t */\r\n\tpublic getAttributeNodeNS(namespace: string | null, localName: string): Attr | null {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\treturn getAttributeByNamespaceAndLocalName(namespace, localName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets an attribute given its node\r\n\t *\r\n\t * @param attr - The attribute node to set\r\n\t *\r\n\t * @returns The previous attribute node for the attribute\r\n\t */\r\n\tpublic setAttributeNode(attr: Attr): Attr | null {\r\n\t\texpectArity(arguments, 1);\r\n\t\tattr = asObject(attr, Attr);\r\n\r\n\t\treturn setAttribute(attr, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets an attribute given its node\r\n\t *\r\n\t * @param attr - The attribute node to set\r\n\t *\r\n\t * @returns The previous attribute node for the attribute\r\n\t */\r\n\tpublic setAttributeNodeNS(attr: Attr): Attr | null {\r\n\t\texpectArity(arguments, 1);\r\n\t\tattr = asObject(attr, Attr);\r\n\r\n\t\treturn setAttribute(attr, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes an attribute given its node\r\n\t *\r\n\t * @param attr - The attribute node to remove\r\n\t *\r\n\t * @returns The removed attribute node\r\n\t */\r\n\tpublic removeAttributeNode(attr: Attr): Attr {\r\n\t\texpectArity(arguments, 1);\r\n\t\tattr = asObject(attr, Attr);\r\n\r\n\t\t// 1. If this’s attribute list does not contain attr, then throw a NotFoundError.\r\n\t\tif (this.attributes.indexOf(attr) < 0) {\r\n\t\t\tthrowNotFoundError('the specified attribute does not exist');\r\n\t\t}\r\n\r\n\t\t// 2. Remove attr.\r\n\t\tremoveAttribute(attr);\r\n\r\n\t\t// 3. Return attr.\r\n\t\treturn attr;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the list of elements with the given qualified name.\r\n\t *\r\n\t * @param qualifiedName - Qualified name of the elements to collect.\r\n\t *\r\n\t * @returns  The list of elements with matching qualified name.\r\n\t */\r\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\r\n\t\texpectArity(arguments, 1);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the list of elements with the given namespace and local name.\r\n\t *\r\n\t * @param namespace - Namespace URI of the elements to collect.\r\n\t * @param localName - Local name of the elements to collect\r\n\t *\r\n\t * @returns  The list of elements with matching namespace and local name.\r\n\t */\r\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of the given node\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t * @param other    - The node to copy\r\n\t *\r\n\t * @returns A shallow copy of the node\r\n\t */\r\n\tpublic _copy(document: Document): Element {\r\n\t\t// 2.1. Let copy be the result of creating an element, given document, node’s local name,\r\n\t\t// node’s namespace, node’s namespace prefix, and the value of node’s is attribute if\r\n\t\t// present (or null if not). The synchronous custom elements flag should be unset.\r\n\t\tconst copyElement = createElement(document, this.localName, this.namespaceURI, this.prefix);\r\n\r\n\t\t// 2.2. For each attribute in node’s attribute list:\r\n\t\tfor (const attr of this.attributes) {\r\n\t\t\t// 2.2.1. Let copyAttribute be a clone of attribute.\r\n\t\t\tconst copyAttribute = attr._copy(document);\r\n\r\n\t\t\t// 2.2.2. Append copyAttribute to copy.\r\n\t\t\tcopyElement.setAttributeNode(copyAttribute);\r\n\t\t}\r\n\r\n\t\treturn copyElement;\r\n\t}\r\n\r\n\t// From the DOM Parsing and Serialization spec\r\n\r\n\t/**\r\n\t * Returns a fragment of HTML or XML that represents the element's contents.\r\n\t */\r\n\tpublic get innerHTML() {\r\n\t\t// Return the result of invoking the fragment serializing algorithm on this\r\n\t\t// providing true for the require well-formed flag (this might throw an exception instead of\r\n\t\t// returning a string).\r\n\t\treturn serializeFragment(this, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a fragment of HTML or XML that represents the element and its contents.\r\n\t */\r\n\tpublic get outerHTML() {\r\n\t\t// Return the result of invoking the fragment serializing algorithm on a fictional node\r\n\t\t// whose only child is this providing true for the require well-formed flag\r\n\t\t// (this might throw an exception instead of returning a string).\r\n\t\treturn serializeFragment(this, true, true);\r\n\t}\r\n}\r\n\r\n/**\r\n * To create an element, given a document, localName, namespace, and optional prefix, is, and\r\n * synchronous custom elements flag, run these steps:\r\n *\r\n * @param document  - The node document for the new element\r\n * @param localName - The local name for the new element\r\n * @param namespace - The namespace URI for the new element, or null for the null namespace\r\n * @param prefix    - The prefix for the new element, or null for no prefix\r\n *\r\n * @returns The new element\r\n */\r\nexport function createElement(\r\n\tdocument: Document,\r\n\tlocalName: string,\r\n\tnamespace: string | null,\r\n\tprefix: string | null = null\r\n): Element {\r\n\t// 1. If prefix was not given, let prefix be null.\r\n\t// (handled by default)\r\n\r\n\t// 2. If is was not given, let is be null.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 3. Let result be null.\r\n\tlet result = null;\r\n\r\n\t// 4. Let definition be the result of looking up a custom element definition given document,\r\n\t// namespace, localName, and is.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 5. If definition is non-null, and definition’s name is not equal to its local name (i.e.,\r\n\t// definition represents a customized built-in element), then:\r\n\t// 5.1. Let interface be the element interface for localName and the HTML namespace.\r\n\t// 5.2. Set result to a new element that implements interface, with no attributes, namespace set\r\n\t// to the HTML namespace, namespace prefix set to prefix, local name set to localName, custom\r\n\t// element state set to \"undefined\", custom element definition set to null, is value set to is,\r\n\t// and node document set to document.\r\n\t// 5.3. If the synchronous custom elements flag is set, then run this step while catching any\r\n\t// exceptions:\r\n\t// 5.3.1. Upgrade element using definition.\r\n\t// 5.3.catch. If this step threw an exception, then:\r\n\t// 5.3.catch.1. Report the exception.\r\n\t// 5.3.catch.2. Set result's custom element state to \"failed\".\r\n\t// 5.4. Otherwise, enqueue a custom element upgrade reaction given result and definition.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 6. Otherwise, if definition is non-null, then:\r\n\t// 6.1. If the synchronous custom elements flag is set, then run these steps while catching any\r\n\t// exceptions:\r\n\t// 6.1.1. Let C be definition’s constructor.\r\n\t// 6.1.2. Set result to the result of constructing C, with no arguments.\r\n\t// 6.1.3. Assert: result’s custom element state and custom element definition are initialized.\r\n\t// 6.1.4. Assert: result’s namespace is the HTML namespace.\r\n\t// IDL enforces that result is an HTMLElement object, which all use the HTML namespace.\r\n\t// 6.1.5. If result’s attribute list is not empty, then throw a NotSupportedError.\r\n\t// 6.1.6. If result has children, then throw a NotSupportedError.\r\n\t// 6.1.7. If result’s parent is non-null, then throw a NotSupportedError.\r\n\t// 6.1.8. If result’s node document is not document, then throw a NotSupportedError.\r\n\t// 6.1.9. If result’s local name is not equal to localName, then throw a NotSupportedError.\r\n\t// 6.1.10. Set result’s namespace prefix to prefix.\r\n\t// 6.1.11. Set result’s is value to null.\r\n\t// If any of these steps threw an exception, then:\r\n\t// 6.1.catch.1. Report the exception.\r\n\t// 6.1.catch.2. Set result to a new element that implements the HTMLUnknownElement interface,\r\n\t// with no attributes, namespace set to the HTML namespace, namespace prefix set to prefix,\r\n\t// local name set to localName, custom element state set to \"failed\", custom element definition\r\n\t// set to null, is value set to null, and node document set to document.\r\n\t// 6.2. Otherwise:\r\n\t// 6.2.1. Set result to a new element that implements the HTMLElement interface, with no\r\n\t// attributes, namespace set to the HTML namespace, namespace prefix set to prefix, local name\r\n\t// set to localName, custom element state set to \"undefined\", custom element definition set to\r\n\t// null, is value set to null, and node document set to document.\r\n\t// 6.2.2. Enqueue a custom element upgrade reaction given result and definition.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 7. Otherwise:\r\n\t// 7.1. Let interface be the element interface for localName and namespace.\r\n\t// (interfaces other than Element not implemented)\r\n\r\n\t// 7.2. Set result to a new element that implements interface, with no attributes, namespace set\r\n\t// to namespace, namespace prefix set to prefix, local name set to localName, custom element\r\n\t// state set to \"uncustomized\", custom element definition set to null, is value set to is, and\r\n\t// node document set to document.\r\n\tconst context = getContext(document);\r\n\tresult = new context.Element(namespace, prefix, localName);\r\n\tresult.ownerDocument = document;\r\n\r\n\t// If namespace is the HTML namespace, and either localName is a valid custom element name or is\r\n\t// is non-null, then set result’s custom element state to \"undefined\".\r\n\t// (custom elements not implemented)\r\n\r\n\t// Return result.\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * To get an attribute by name given a qualifiedName and element element, run these steps:\r\n *\r\n * @param qualifiedName - The qualified name of the attribute to get\r\n * @param element       - The element to get the attribute on\r\n *\r\n * @returns The first matching attribute, or null otherwise\r\n */\r\nfunction getAttributeByName(qualifiedName: string, element: Element): Attr | null {\r\n\t// 1. If element is in the HTML namespace and its node document is an HTML document, then set\r\n\t// qualifiedName to qualifiedName in ASCII lowercase.\r\n\t// (html documents not implemented)\r\n\r\n\t// 2. Return the first attribute in element’s attribute list whose qualified name is\r\n\t// qualifiedName, and null otherwise.\r\n\treturn element.attributes.find((attr) => attr.name === qualifiedName) || null;\r\n}\r\n\r\n/**\r\n * To get an attribute by namespace and local name given a namespace, localName, and element\r\n * element, run these steps:\r\n *\r\n * @param namespace - Namespace for the attribute\r\n * @param localName - Local name for the attribute\r\n * @param element   - The element to get the attribute on\r\n *\r\n * @returns The first matching attribute, or null otherwise\r\n */\r\nfunction getAttributeByNamespaceAndLocalName(\r\n\tnamespace: string | null,\r\n\tlocalName: string,\r\n\telement: Element\r\n): Attr | null {\r\n\t// 1. If namespace is the empty string, set it to null.\r\n\tif (namespace === '') {\r\n\t\tnamespace = null;\r\n\t}\r\n\r\n\t// 2. Return the attribute in element’s attribute list whose namespace is namespace and local\r\n\t// name is localName, if any, and null otherwise.\r\n\treturn (\r\n\t\telement.attributes.find(\r\n\t\t\t(attr) => attr.namespaceURI === namespace && attr.localName === localName\r\n\t\t) || null\r\n\t);\r\n}\r\n\r\n/**\r\n * To set an attribute given an attr and element, run these steps:\r\n *\r\n * @param attr    - The new attribute to set\r\n * @param element - The element to set attr on\r\n *\r\n * @returns The previous attribute with attr's namespace and local name, or null if there was no such\r\n *         attribute\r\n */\r\nfunction setAttribute(attr: Attr, element: Element): Attr | null {\r\n\t// 1. If attr’s element is neither null nor element, throw an InUseAttributeError.\r\n\tif (attr.ownerElement !== null && attr.ownerElement !== element) {\r\n\t\tthrowInUseAttributeError('attribute is in use by another element');\r\n\t}\r\n\r\n\t// 2. Let oldAttr be the result of getting an attribute given attr’s namespace, attr’s local\r\n\t// name, and element.\r\n\tconst oldAttr = getAttributeByNamespaceAndLocalName(attr.namespaceURI, attr.localName, element);\r\n\r\n\t// 3. If oldAttr is attr, return attr.\r\n\tif (oldAttr === attr) {\r\n\t\treturn attr;\r\n\t}\r\n\r\n\t// 4. If oldAttr is non-null, then replace oldAttr with attr.\r\n\tif (oldAttr !== null) {\r\n\t\treplaceAttribute(oldAttr, attr);\r\n\t} else {\r\n\t\t// 5. Otherwise, append attr to element.\r\n\t\tappendAttribute(attr, element);\r\n\t}\r\n\r\n\t// 6. Return oldAttr.\r\n\treturn oldAttr;\r\n}\r\n\r\n/**\r\n * To set an attribute value for an element element using a localName and value, and an optional\r\n * prefix, and namespace, run these steps:\r\n *\r\n * @param element   - Element to set the attribute value on\r\n * @param localName - Local name of the attribute\r\n * @param value     - New value of the attribute\r\n * @param prefix    - Prefix of the attribute\r\n * @param namespace - Namespace of the attribute\r\n */\r\nfunction setAttributeValue(\r\n\telement: Element,\r\n\tlocalName: string,\r\n\tvalue: string,\r\n\tprefix: string | null,\r\n\tnamespace: string | null\r\n): void {\r\n\t// 1. If prefix is not given, set it to null.\r\n\t// 2. If namespace is not given, set it to null.\r\n\t// (handled by default values)\r\n\r\n\t// 3. Let attribute be the result of getting an attribute given namespace, localName, and\r\n\t// element.\r\n\tconst attribute = getAttributeByNamespaceAndLocalName(namespace, localName, element);\r\n\r\n\t// 4. If attribute is null, create an attribute whose namespace is namespace, namespace prefix\r\n\t// is prefix, local name is localName, value is value, and node document is element’s node\r\n\t// document, then append this attribute to element, and then return.\r\n\tif (attribute === null) {\r\n\t\tconst context = getContext(element);\r\n\t\tconst attribute = new context.Attr(namespace, prefix, localName, value, element);\r\n\t\tattribute.ownerDocument = element.ownerDocument;\r\n\t\tappendAttribute(attribute, element);\r\n\t\treturn;\r\n\t}\r\n\r\n\t// 5. Change attribute to value.\r\n\tchangeAttribute(attribute, value);\r\n}\r\n\r\n/**\r\n * To remove an attribute by name given a qualifiedName and element element, run these steps:\r\n *\r\n * @param qualifiedName - Qualified name of the attribute\r\n * @param element       - The element to remove the attribute from\r\n *\r\n * @returns The removed attribute, or null if no matching attribute exists\r\n */\r\nfunction removeAttributeByName(qualifiedName: string, element: Element): Attr | null {\r\n\t// 1. Let attr be the result of getting an attribute given qualifiedName and element.\r\n\tconst attr = getAttributeByName(qualifiedName, element);\r\n\r\n\t// 2. If attr is non-null, then remove attr.\r\n\tif (attr !== null) {\r\n\t\tremoveAttribute(attr);\r\n\t}\r\n\r\n\t// 3. Return attr.\r\n\treturn attr;\r\n}\r\n\r\n/**\r\n * To remove an attribute by namespace and local name given a namespace, localName, and element\r\n * element, run these steps:\r\n *\r\n * @param namespace - The namespace of the attribute\r\n * @param localName - The local name of the attribute\r\n * @param element   - The element to remove the attribute from\r\n *\r\n * @returns The removed attribute, or null if no matching attribute exists\r\n */\r\nfunction removeAttributeByNamespaceAndLocalName(\r\n\tnamespace: string | null,\r\n\tlocalName: string,\r\n\telement: Element\r\n): Attr | null {\r\n\t// 1. Let attr be the result of getting an attribute given namespace, localName, and element.\r\n\tconst attr = getAttributeByNamespaceAndLocalName(namespace, localName, element);\r\n\r\n\t// 2. If attr is non-null, then remove attr.\r\n\tif (attr !== null) {\r\n\t\tremoveAttribute(attr);\r\n\t}\r\n\r\n\t// 3. Return attr.\r\n\treturn attr;\r\n}\r\n","import Document from '../Document';\r\nimport { createElement, default as Element } from '../Element';\r\nimport { validateAndExtract } from './namespaceHelpers';\r\n\r\n// 3.5. Interface Document\r\n\r\n/**\r\n * The internal createElementNS steps, given document, namespace, qualifiedName, and options, are as\r\n * follows:\r\n *\r\n * @param document      - The node document for the new element\r\n * @param namespace     - The namespace for the new element\r\n * @param qualifiedName - The qualified name for the new element\r\n *\r\n * @returns The new element\r\n */\r\nexport default function createElementNS(\r\n\tdocument: Document,\r\n\tnamespace: string | null,\r\n\tqualifiedName: string\r\n): Element {\r\n\t// 1. Let namespace, prefix, and localName be the result of passing namespace and qualifiedName\r\n\t// to validate and extract.\r\n\tconst {\r\n\t\tnamespace: validatedNamespace,\r\n\t\tprefix,\r\n\t\tlocalName,\r\n\t} = validateAndExtract(namespace, qualifiedName);\r\n\r\n\t// 2. Let is be the value of is member of options, or null if no such member exists.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 3. Let element be the result of creating an element given document, localName, namespace,\r\n\t// prefix, is, and with the synchronous custom elements flag set.\r\n\tconst element = createElement(document, localName, validatedNamespace, prefix);\r\n\r\n\t// 4. If is is non-null, then set an attribute value for element using \"is\" and is.\r\n\t// (custom elements not implemented)\r\n\r\n\t// 5. Return element.\r\n\treturn element;\r\n}\r\n","import Document from './Document';\r\nimport DocumentType from './DocumentType';\r\nimport { createElement } from './Element';\r\nimport XMLDocument from './XMLDocument';\r\nimport { getContext } from './context/Context';\r\nimport createElementNS from './util/createElementNS';\r\nimport { expectArity } from './util/errorHelpers';\r\nimport { HTML_NAMESPACE, validateQualifiedName } from './util/namespaceHelpers';\r\nimport { asNullableObject, asNullableString, legacyNullToEmptyString } from './util/typeHelpers';\r\n\r\n/**\r\n * @public\r\n */\r\nexport default class DOMImplementation {\r\n\tprivate _document: Document;\r\n\r\n\t/**\r\n\t * (non-standard) Use Document#implementation to access instances of this class\r\n\t *\r\n\t * @param document - The document to associate with this instance\r\n\t */\r\n\tconstructor(document: Document) {\r\n\t\tthis._document = document;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a doctype, with the given qualifiedName, publicId, and systemId.\r\n\t *\r\n\t * @param qualifiedName - Qualified name for the doctype\r\n\t * @param publicId      - Public ID for the doctype\r\n\t * @param systemId      - System ID for the doctype\r\n\t *\r\n\t * @returns The new doctype node\r\n\t */\r\n\tcreateDocumentType(qualifiedName: string, publicId: string, systemId: string): DocumentType {\r\n\t\texpectArity(arguments, 3);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\t\tpublicId = String(publicId);\r\n\t\tsystemId = String(systemId);\r\n\r\n\t\t// 1. Validate qualifiedName.\r\n\t\tvalidateQualifiedName(qualifiedName);\r\n\r\n\t\t// 2. Return a new doctype, with qualifiedName as its name, publicId as its public ID, and\r\n\t\t// systemId as its system ID, and with its node document set to the associated document of\r\n\t\t// this.\r\n\t\tconst context = getContext(this._document);\r\n\t\tconst doctype = new context.DocumentType(qualifiedName, publicId, systemId);\r\n\t\tdoctype.ownerDocument = this._document;\r\n\t\treturn doctype;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an XMLDocument, with a document element whose local name is qualifiedName and whose\r\n\t * namespace is namespace (unless qualifiedName is the empty string), and with doctype, if it is\r\n\t * given, as its doctype.\r\n\t *\r\n\t * @param namespace     - The namespace for the root element\r\n\t * @param qualifiedName - The qualified name for the root element, or empty string to not create\r\n\t *                        a root element\r\n\t * @param doctype       - The doctype for the new document, or null to not add a doctype\r\n\t *\r\n\t * @returns The new XMLDocument\r\n\t */\r\n\tcreateDocument(\r\n\t\tnamespace: string | null,\r\n\t\tqualifiedName: string | null,\r\n\t\tdoctype: DocumentType | null = null\r\n\t): XMLDocument {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\t// [LegacyNullToEmptyString] for qualifiedName\r\n\t\tqualifiedName = legacyNullToEmptyString(qualifiedName);\r\n\t\tdoctype = asNullableObject(doctype, DocumentType);\r\n\r\n\t\t// 1. Let document be a new XMLDocument.\r\n\t\tconst context = getContext(this._document);\r\n\t\tconst document = new context.XMLDocument();\r\n\r\n\t\t// 2. Let element be null.\r\n\t\tlet element = null;\r\n\r\n\t\t// 3. If qualifiedName is not the empty string, then set element to the result of running\r\n\t\t// the internal createElementNS steps, given document, namespace, qualifiedName, and an\r\n\t\t// empty dictionary.\r\n\t\tif (qualifiedName !== '') {\r\n\t\t\telement = createElementNS(document, namespace, qualifiedName);\r\n\t\t}\r\n\r\n\t\t// 4. If doctype is non-null, append doctype to document.\r\n\t\tif (doctype) {\r\n\t\t\tdocument.appendChild(doctype);\r\n\t\t}\r\n\r\n\t\t// 5. If element is non-null, append element to document.\r\n\t\tif (element) {\r\n\t\t\tdocument.appendChild(element);\r\n\t\t}\r\n\r\n\t\t// 6. document’s origin is this’s associated document’s origin.\r\n\t\t// (origin not implemented)\r\n\r\n\t\t// 7. document’s content type is determined by namespace:\r\n\t\t// HTML namespace: application/xhtml+xml\r\n\t\t// SVG namespace: image/svg+xml\r\n\t\t// Any other namespace: application/xml\r\n\t\t// (content type not implemented)\r\n\r\n\t\t// 8. Return document.\r\n\t\treturn document;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a HTML document with a basic tree already constructed.\r\n\t *\r\n\t * @param title - Optional title for the new HTML document\r\n\t *\r\n\t * @returns The new document\r\n\t */\r\n\tcreateHTMLDocument(title?: string | null): Document {\r\n\t\ttitle = asNullableString(title);\r\n\r\n\t\t// 1. Let doc be a new document that is an HTML document.\r\n\t\tconst context = getContext(this._document);\r\n\t\tconst doc = new context.Document();\r\n\r\n\t\t// 2. Set doc’s content type to \"text/html\".\r\n\t\t// (content type not implemented)\r\n\r\n\t\t// 3. Append a new doctype, with \"html\" as its name and with its node document set to doc,\r\n\t\t// to doc.\r\n\t\tconst doctype = new context.DocumentType('html');\r\n\t\tdoctype.ownerDocument = doc;\r\n\t\tdoc.appendChild(doctype);\r\n\r\n\t\t// 4. Append the result of creating an element given doc, html, and the HTML namespace, to\r\n\t\t// doc.\r\n\t\tconst htmlElement = createElement(doc, 'html', HTML_NAMESPACE);\r\n\t\tdoc.appendChild(htmlElement);\r\n\r\n\t\t// 5. Append the result of creating an element given doc, head, and the HTML namespace, to\r\n\t\t// the html element created earlier.\r\n\t\tconst headElement = createElement(doc, 'head', HTML_NAMESPACE);\r\n\t\thtmlElement.appendChild(headElement);\r\n\r\n\t\t// 6. If title is given:\r\n\t\tif (title !== null) {\r\n\t\t\t// 6.1. Append the result of creating an element given doc, title, and the HTML\r\n\t\t\t// namespace, to the head element created earlier.\r\n\t\t\tconst titleElement = createElement(doc, 'title', HTML_NAMESPACE);\r\n\t\t\theadElement.appendChild(titleElement);\r\n\r\n\t\t\t// 6.2. Append a new Text node, with its data set to title (which could be the empty\r\n\t\t\t// string) and its node document set to doc, to the title element created earlier.\r\n\t\t\ttitleElement.appendChild(doc.createTextNode(title));\r\n\t\t}\r\n\r\n\t\t// 7. Append the result of creating an element given doc, body, and the HTML namespace, to\r\n\t\t// the html element created earlier.\r\n\t\thtmlElement.appendChild(createElement(doc, 'body', HTML_NAMESPACE));\r\n\r\n\t\t// 8. doc’s origin is this’s associated document’s origin.\r\n\t\t// (origin not implemented)\r\n\r\n\t\t// 9. Return doc.\r\n\t\treturn doc;\r\n\t}\r\n}\r\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\r\nimport Attr from './Attr';\r\nimport CDATASection from './CDATASection';\r\nimport Comment from './Comment';\r\nimport DocumentFragment from './DocumentFragment';\r\nimport DocumentType from './DocumentType';\r\nimport DOMImplementation from './DOMImplementation';\r\nimport { createElement, default as Element } from './Element';\r\nimport Node from './Node';\r\nimport ProcessingInstruction from './ProcessingInstruction';\r\nimport Text from './Text';\r\nimport Range from './Range';\r\nimport { getContext } from './context/Context';\r\nimport cloneNode from './util/cloneNode';\r\nimport createElementNS from './util/createElementNS';\r\nimport {\r\n\texpectArity,\r\n\tthrowInvalidCharacterError,\r\n\tthrowNotSupportedError,\r\n} from './util/errorHelpers';\r\nimport { adoptNode, appendNodes, prependNodes, replaceChildren } from './util/mutationAlgorithms';\r\nimport { NodeType, isNodeOfType } from './util/NodeType';\r\nimport { matchesNameProduction, validateAndExtract } from './util/namespaceHelpers';\r\nimport { asNullableString, asObject } from './util/typeHelpers';\r\nimport {\r\n\tgetListOfElementsWithNamespaceAndLocalName,\r\n\tgetListOfElementsWithQualifiedName,\r\n} from './util/treeHelpers';\r\n\r\n/**\r\n * 3.5. Interface Document\r\n *\r\n * @public\r\n */\r\nexport default class Document extends Node implements NonElementParentNode, ParentNode {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.DOCUMENT_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn '#document';\r\n\t}\r\n\r\n\tpublic get nodeValue(): string | null {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic set nodeValue(_newValue: string | null) {\r\n\t\t// Do nothing.\r\n\t}\r\n\r\n\tpublic get textContent(): string | null {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic set textContent(_newValue: string | null) {\r\n\t\t// Do nothing.\r\n\t}\r\n\r\n\tpublic lookupPrefix(namespace: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If namespace is null or the empty string, then return null.\r\n\t\t// (not necessary due to recursion)\r\n\r\n\t\t// 2. Switch on this:\r\n\t\t// Document - Return the result of locating a namespace prefix for its document element, if\r\n\t\t// its document element is non-null, and null otherwise.\r\n\t\tif (this.documentElement !== null) {\r\n\t\t\treturn this.documentElement.lookupPrefix(namespace);\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If prefix is the empty string, then set it to null.\r\n\t\t// (not necessary due to recursion)\r\n\r\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\r\n\r\n\t\t// To locate a namespace for a node using prefix, switch on node: Document\r\n\t\t// 1. If its document element is null, then return null.\r\n\t\tif (this.documentElement === null) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\r\n\t\t// 2. Return the result of running locate a namespace on its document element using prefix.\r\n\t\treturn this.documentElement.lookupNamespaceURI(prefix);\r\n\t}\r\n\r\n\t// ParentNode\r\n\r\n\tpublic get children(): Element[] {\r\n\t\treturn getChildren(this);\r\n\t}\r\n\r\n\tpublic firstElementChild: Element | null = null;\r\n\tpublic lastElementChild: Element | null = null;\r\n\tpublic childElementCount: number = 0;\r\n\r\n\tpublic prepend(...nodes: (Node | string)[]): void {\r\n\t\tprependNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic append(...nodes: (Node | string)[]): void {\r\n\t\tappendNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\r\n\t\treplaceChildren(this, nodes);\r\n\t}\r\n\r\n\t// Document\r\n\r\n\t/**\r\n\t * Returns a reference to the DOMImplementation object associated with the document.\r\n\t */\r\n\tpublic readonly implementation: DOMImplementation = new DOMImplementation(this);\r\n\r\n\t/**\r\n\t * The doctype, or null if there is none.\r\n\t */\r\n\tpublic doctype: DocumentType | null = null;\r\n\r\n\t/**\r\n\t * The document element, or null if there is none.\r\n\t */\r\n\tpublic documentElement: Element | null = null;\r\n\r\n\t/**\r\n\t * Creates a new Document.\r\n\t *\r\n\t * Note: Unlike DOMImplementation#createDocument(), this constructor does not return an\r\n\t * XMLDocument object, but a document (Document object).\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the list of elements with the given qualified name.\r\n\t *\r\n\t * @param qualifiedName - Qualified name of the elements to collect.\r\n\t *\r\n\t * @returns  The list of elements with matching qualified name.\r\n\t */\r\n\tpublic getElementsByTagName(qualifiedName: string): Element[] {\r\n\t\texpectArity(arguments, 1);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\treturn getListOfElementsWithQualifiedName(qualifiedName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the list of elements with the given namespace and local name.\r\n\t *\r\n\t * @param namespace - Namespace URI of the elements to collect.\r\n\t * @param localName - Local name of the elements to collect\r\n\t *\r\n\t * @returns  The list of elements with matching namespace and local name.\r\n\t */\r\n\tpublic getElementsByTagNameNS(namespace: string | null, localName: string): Element[] {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\treturn getListOfElementsWithNamespaceAndLocalName(namespace, localName, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new element in the null namespace.\r\n\t *\r\n\t * @param localName - Local name of the element\r\n\t *\r\n\t * @returns The new element\r\n\t */\r\n\tpublic createElement(localName: string): Element {\r\n\t\texpectArity(arguments, 1);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\t// 1. If localName does not match the Name production, then throw an InvalidCharacterError.\r\n\t\tif (!matchesNameProduction(localName)) {\r\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\r\n\t\t}\r\n\r\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\r\n\t\t// lowercase.\r\n\t\t// (html documents not implemented)\r\n\r\n\t\t// 3. Let is be the value of is member of options, or null if no such member exists.\r\n\t\t// (custom elements not implemented)\r\n\r\n\t\t// 4. Let namespace be the HTML namespace, if this is an HTML document or\r\n\t\t// this’s content type is \"application/xhtml+xml\", and null otherwise.\r\n\t\t// (html documents not implemented)\r\n\t\tconst namespace: string | null = null;\r\n\r\n\t\t// 5. Let element be the result of creating an element given this, localName,\r\n\t\t// namespace, null, is, and with the synchronous custom elements flag set.\r\n\t\tconst element = createElement(this, localName, namespace, null);\r\n\r\n\t\t// 6. If is is non-null, then set an attribute value for element using \"is\" and is.\r\n\t\t// (custom elements not implemented)\r\n\r\n\t\t// 7. Return element.\r\n\t\treturn element;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new element in the given namespace.\r\n\t *\r\n\t * @param namespace     - Namespace URI for the new element\r\n\t * @param qualifiedName - Qualified name for the new element\r\n\t *\r\n\t * @returns The new element\r\n\t */\r\n\tpublic createElementNS(namespace: string | null, qualifiedName: string): Element {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\t// return the result of running the internal createElementNS steps, given this,\r\n\t\t// namespace, qualifiedName, and options.\r\n\t\treturn createElementNS(this, namespace, qualifiedName);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new DocumentFragment node with its node document set to this.\r\n\t *\r\n\t * @returns The new document fragment\r\n\t */\r\n\tpublic createDocumentFragment(): DocumentFragment {\r\n\t\tconst context = getContext(this);\r\n\t\tconst documentFragment = new context.DocumentFragment();\r\n\t\tdocumentFragment.ownerDocument = this;\r\n\t\treturn documentFragment;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Text node with its data set to data and node document set to this.\r\n\t *\r\n\t * @param data - Data for the new text node\r\n\t *\r\n\t * @returns The new text node\r\n\t */\r\n\tpublic createTextNode(data: string): Text {\r\n\t\texpectArity(arguments, 1);\r\n\t\tdata = String(data);\r\n\r\n\t\tconst context = getContext(this);\r\n\t\tconst text = new context.Text(data);\r\n\t\ttext.ownerDocument = this;\r\n\t\treturn text;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new CDATA section with the given data and node document set to this.\r\n\t *\r\n\t * @param data - Data for the new CDATA section\r\n\t *\r\n\t * @returns The new CDATA section\r\n\t */\r\n\tpublic createCDATASection(data: string): CDATASection {\r\n\t\texpectArity(arguments, 1);\r\n\t\tdata = String(data);\r\n\r\n\t\t// 1. If this is an HTML document, then throw a NotSupportedError.\r\n\t\t// (html documents not implemented)\r\n\r\n\t\t// 2. If data contains the string \"]]>\", then throw an InvalidCharacterError.\r\n\t\tif (data.indexOf(']]>') >= 0) {\r\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"]]>\"');\r\n\t\t}\r\n\r\n\t\t// 3. Return a new CDATASection node with its data set to data and node document set to the\r\n\t\t// this.\r\n\t\tconst context = getContext(this);\r\n\t\tconst cdataSection = new context.CDATASection(data);\r\n\t\tcdataSection.ownerDocument = this;\r\n\t\treturn cdataSection;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a new Comment node with its data set to data and node document set to this.\r\n\t *\r\n\t * @param data - Data for the new comment\r\n\t *\r\n\t * @returns The new comment node\r\n\t */\r\n\tpublic createComment(data: string): Comment {\r\n\t\texpectArity(arguments, 1);\r\n\t\tdata = String(data);\r\n\r\n\t\tconst context = getContext(this);\r\n\t\tconst comment = new context.Comment(data);\r\n\t\tcomment.ownerDocument = this;\r\n\t\treturn comment;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new processing instruction node, with target set to target, data set to data, and\r\n\t * node document set to this.\r\n\t *\r\n\t * @param target - Target for the new processing instruction\r\n\t * @param data   - Data for the new processing instruction\r\n\t *\r\n\t * @returns The new processing instruction\r\n\t */\r\n\tpublic createProcessingInstruction(target: string, data: string): ProcessingInstruction {\r\n\t\texpectArity(arguments, 2);\r\n\t\ttarget = String(target);\r\n\t\tdata = String(data);\r\n\r\n\t\t// 1. If target does not match the Name production, then throw an InvalidCharacterError.\r\n\t\tif (!matchesNameProduction(target)) {\r\n\t\t\tthrowInvalidCharacterError('The target is not a valid Name');\r\n\t\t}\r\n\r\n\t\t// 2. If data contains the string \"?>\", then throw an InvalidCharacterError.\r\n\t\tif (data.indexOf('?>') >= 0) {\r\n\t\t\tthrowInvalidCharacterError('Data must not contain the string \"?>\"');\r\n\t\t}\r\n\r\n\t\t// 3. Return a new ProcessingInstruction node, with target set to target, data set to data,\r\n\t\t// and node document set to this.\r\n\t\tconst context = getContext(this);\r\n\t\tconst pi = new context.ProcessingInstruction(target, data);\r\n\t\tpi.ownerDocument = this;\r\n\t\treturn pi;\r\n\r\n\t\t// Note: No check is performed that target contains \"xml\" or \":\", or that data contains\r\n\t\t// characters that match the Char production.\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a copy of a node from an external document that can be inserted into the current\r\n\t * document.\r\n\t *\r\n\t * @param node - The node to import\r\n\t * @param deep - Whether to also import node's children\r\n\t */\r\n\tpublic importNode<TNode extends Node>(node: TNode, deep: boolean = false): TNode {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. If node is a document or shadow root, then throw a NotSupportedError.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\r\n\t\t\tthrowNotSupportedError('importing a Document node is not supported');\r\n\t\t}\r\n\r\n\t\t// 2. Return a clone of node, with this and the clone children flag set if deep is\r\n\t\t// true.\r\n\t\treturn cloneNode(node, deep, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Adopts a node. The node and its subtree is removed from the document it's in (if any), and\r\n\t * its ownerDocument is changed to the current document. The node can then be inserted into the\r\n\t * current document.\r\n\t *\r\n\t * @param node - The node to adopt\r\n\t */\r\n\tpublic adoptNode<TNode extends Node>(node: TNode): TNode {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. If node is a document, then throw a NotSupportedError.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_NODE)) {\r\n\t\t\tthrowNotSupportedError('adopting a Document node is not supported');\r\n\t\t}\r\n\r\n\t\t// 2. If node is a shadow root, then throw a HierarchyRequestError.\r\n\t\t// 3. If node is a DocumentFragment node and its host is non-null, then return node.\r\n\t\t// Note: unfortunately this does not throw for web compatibility.\r\n\t\t// (shadow dom and HTML templates not implemented)\r\n\r\n\t\t// 4. Adopt node into this.\r\n\t\tadoptNode(node, this);\r\n\r\n\t\t// 5. Return node.\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new attribute node with the null namespace and given local name.\r\n\t *\r\n\t * @param localName - The local name of the attribute\r\n\t *\r\n\t * @returns The new attribute node\r\n\t */\r\n\tpublic createAttribute(localName: string): Attr {\r\n\t\texpectArity(arguments, 1);\r\n\t\tlocalName = String(localName);\r\n\r\n\t\t// 1. If localName does not match the Name production in XML, then throw an\r\n\t\t// InvalidCharacterError.\r\n\t\tif (!matchesNameProduction(localName)) {\r\n\t\t\tthrowInvalidCharacterError('The local name is not a valid Name');\r\n\t\t}\r\n\r\n\t\t// 2. If this is an HTML document, then set localName to localName in ASCII\r\n\t\t// lowercase.\r\n\t\t// (html documents not implemented)\r\n\r\n\t\t// 3. Return a new attribute whose local name is localName and node document is context\r\n\t\t// object.\r\n\t\tconst context = getContext(this);\r\n\t\tconst attr = new context.Attr(null, null, localName, '', null);\r\n\t\tattr.ownerDocument = this;\r\n\t\treturn attr;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new attribute node with the given namespace and qualified name.\r\n\t *\r\n\t * @param namespace     - Namespace URI for the new attribute, or null for the null namespace\r\n\t * @param qualifiedName - Qualified name for the new attribute\r\n\t *\r\n\t * @returns The new attribute node\r\n\t */\r\n\tpublic createAttributeNS(namespace: string | null, qualifiedName: string): Attr {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnamespace = asNullableString(namespace);\r\n\t\tqualifiedName = String(qualifiedName);\r\n\r\n\t\t// 1. Let namespace, prefix, and localName be the result of passing namespace and\r\n\t\t// qualifiedName to validate and extract.\r\n\t\tconst {\r\n\t\t\tnamespace: validatedNamespace,\r\n\t\t\tprefix,\r\n\t\t\tlocalName,\r\n\t\t} = validateAndExtract(namespace, qualifiedName);\r\n\r\n\t\t// 2. Return a new attribute whose namespace is namespace, namespace prefix is prefix, local\r\n\t\t// name is localName, and node document is this.\r\n\t\tconst context = getContext(this);\r\n\t\tconst attr = new context.Attr(validatedNamespace, prefix, localName, '', null);\r\n\t\tattr.ownerDocument = this;\r\n\t\treturn attr;\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new live Range, initially positioned at the root of this document.\r\n\t *\r\n\t * @returns The new Range\r\n\t */\r\n\tpublic createRange(): Range {\r\n\t\tconst context = getContext(this);\r\n\t\tconst range = new context.Range();\r\n\t\trange.startContainer = this;\r\n\t\trange.startOffset = 0;\r\n\t\trange.endContainer = this;\r\n\t\trange.endOffset = 0;\r\n\t\treturn range;\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): Document {\r\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\r\n\t\t// (properties not implemented)\r\n\r\n\t\tconst context = getContext(document);\r\n\t\treturn new context.Document();\r\n\t}\r\n}\r\n","import { NonElementParentNode, ParentNode, getChildren } from './mixins';\r\nimport Document from './Document';\r\nimport Element from './Element';\r\nimport Node from './Node';\r\nimport { getContext } from './context/Context';\r\nimport { expectArity } from './util/errorHelpers';\r\nimport {\r\n\tappendNodes,\r\n\tprependNodes,\r\n\tgetDescendantTextContent,\r\n\tstringReplaceAll,\r\n\treplaceChildren,\r\n} from './util/mutationAlgorithms';\r\nimport { NodeType } from './util/NodeType';\r\nimport { ifNullActAsIfEmptyString } from './util/typeHelpers';\r\n\r\n/**\r\n * @public\r\n */\r\nexport default class DocumentFragment extends Node implements NonElementParentNode, ParentNode {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.DOCUMENT_FRAGMENT_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn '#document-fragment';\r\n\t}\r\n\r\n\tpublic get nodeValue(): string | null {\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic set nodeValue(newValue: string | null) {\r\n\t\t// Do nothing.\r\n\t}\r\n\r\n\tpublic get textContent(): string | null {\r\n\t\t// Return the descendant text content of this\r\n\t\treturn getDescendantTextContent(this);\r\n\t}\r\n\r\n\tpublic set textContent(newValue: string | null) {\r\n\t\tnewValue = ifNullActAsIfEmptyString(newValue);\r\n\t\tstringReplaceAll(this, newValue);\r\n\t}\r\n\r\n\tpublic lookupPrefix(namespace: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If namespace is null or the empty string, then return null.\r\n\t\t// (not necessary due to return value)\r\n\r\n\t\t// 2. Switch on this:\r\n\t\t// DocumentFragment - Return null\r\n\t\treturn null;\r\n\t}\r\n\r\n\tpublic lookupNamespaceURI(prefix: string | null): string | null {\r\n\t\texpectArity(arguments, 1);\r\n\r\n\t\t// 1. If prefix is the empty string, then set it to null.\r\n\t\t// (not necessary due to return value)\r\n\r\n\t\t// 2. Return the result of running locate a namespace for this using prefix.\r\n\r\n\t\t// To locate a namespace for a node using prefix, switch on node: DocumentFragment\r\n\t\t// Return null.\r\n\t\treturn null;\r\n\t}\r\n\r\n\t// ParentNode\r\n\r\n\tpublic get children(): Element[] {\r\n\t\treturn getChildren(this);\r\n\t}\r\n\r\n\tpublic firstElementChild: Element | null = null;\r\n\tpublic lastElementChild: Element | null = null;\r\n\tpublic childElementCount: number = 0;\r\n\r\n\tpublic prepend(...nodes: (Node | string)[]): void {\r\n\t\tprependNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic append(...nodes: (Node | string)[]): void {\r\n\t\tappendNodes(this, nodes);\r\n\t}\r\n\r\n\tpublic replaceChildren(...nodes: (Node | string)[]): void {\r\n\t\treplaceChildren(this, nodes);\r\n\t}\r\n\r\n\t/**\r\n\t * Return a new DocumentFragment node whose node document is current global object’s associated\r\n\t * Document.\r\n\t */\r\n\tconstructor() {\r\n\t\tsuper();\r\n\r\n\t\tconst context = getContext(this);\r\n\t\tthis.ownerDocument = context.document;\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): DocumentFragment {\r\n\t\tconst context = getContext(document);\r\n\t\tconst copy = new context.DocumentFragment();\r\n\t\tcopy.ownerDocument = document;\r\n\t\treturn copy;\r\n\t}\r\n}\r\n","import CharacterData from './CharacterData';\r\nimport Document from './Document';\r\nimport { getContext } from './context/Context';\r\nimport { NodeType } from './util/NodeType';\r\n\r\n/**\r\n * 3.13. Interface ProcessingInstruction\r\n *\r\n * @public\r\n */\r\nexport default class ProcessingInstruction extends CharacterData {\r\n\t// Node\r\n\r\n\tpublic get nodeType(): number {\r\n\t\treturn NodeType.PROCESSING_INSTRUCTION_NODE;\r\n\t}\r\n\r\n\tpublic get nodeName(): string {\r\n\t\treturn this.target;\r\n\t}\r\n\r\n\t// ProcessingInstruction\r\n\r\n\tpublic target: string;\r\n\r\n\t/**\r\n\t * (non-standard) Use Document#createProcessingInstruction to create a processing instruction.\r\n\t *\r\n\t * @param target - The target of the processing instruction\r\n\t * @param data   - The data of the processing instruction\r\n\t */\r\n\tconstructor(target: string, data: string) {\r\n\t\tsuper(data);\r\n\r\n\t\tthis.target = target;\r\n\t}\r\n\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): ProcessingInstruction {\r\n\t\t// Set copy’s target and data to those of node.\r\n\t\tconst context = getContext(document);\r\n\t\tconst copy = new context.ProcessingInstruction(this.target, this.data);\r\n\t\tcopy.ownerDocument = document;\r\n\t\treturn copy;\r\n\t}\r\n}\r\n","import DocumentFragment from './DocumentFragment';\r\nimport Node from './Node';\r\nimport { getContext } from './context/Context';\r\nimport {\r\n\texpectArity,\r\n\tthrowHierarchyRequestError,\r\n\tthrowIndexSizeError,\r\n\tthrowInvalidNodeTypeError,\r\n\tthrowInvalidStateError,\r\n\tthrowNotSupportedError,\r\n\tthrowWrongDocumentError,\r\n} from './util/errorHelpers';\r\nimport { NodeType, isNodeOfType, isTextNode, isCharacterDataNode } from './util/NodeType';\r\nimport {\r\n\tdetermineLengthOfNode,\r\n\tforEachInclusiveDescendant,\r\n\tgetInclusiveAncestors,\r\n\tgetNodeDocument,\r\n\tgetNodeIndex,\r\n\tgetRootOfNode,\r\n} from './util/treeHelpers';\r\nimport { asObject, asUnsignedLong } from './util/typeHelpers';\r\nimport {\r\n\tappendNode,\r\n\tinsertNodeIntoRange,\r\n\tremoveNode,\r\n\treplaceAllWithNode,\r\n} from './util/mutationAlgorithms';\r\n\r\n/**\r\n * Interface AbstractRange\r\n *\r\n * Objects implementing the AbstractRange interface are known as ranges.\r\n *\r\n * @public\r\n */\r\nexport interface AbstractRange {\r\n\treadonly startContainer: Node;\r\n\treadonly startOffset: number;\r\n\treadonly endContainer: Node;\r\n\treadonly endOffset: number;\r\n\treadonly collapsed: boolean;\r\n}\r\n\r\ninterface StaticRangeInit {\r\n\tstartContainer: Node;\r\n\tstartOffset: number;\r\n\tendContainer: Node;\r\n\tendOffset: number;\r\n}\r\n\r\n/**\r\n * Interface StaticRange\r\n *\r\n * Updating live ranges in response to node tree mutations can be expensive. For every node tree\r\n * change, all affected Range objects need to be updated. Even if the application is uninterested in\r\n * some live ranges, it still has to pay the cost of keeping them up-to-date when a mutation occurs.\r\n *\r\n * A StaticRange object is a lightweight range that does not update when the node tree mutates. It\r\n * is therefore not subject to the same maintenance cost as live ranges.\r\n *\r\n * @public\r\n */\r\nexport class StaticRange implements AbstractRange {\r\n\tpublic readonly startContainer: Node;\r\n\tpublic readonly startOffset: number;\r\n\tpublic readonly endContainer: Node;\r\n\tpublic readonly endOffset: number;\r\n\tpublic readonly collapsed: boolean;\r\n\r\n\t/**\r\n\t * The StaticRange(init) constructor, when invoked, must run these steps:\r\n\t *\r\n\t * @param init - Dictionary representing the properties to set on the StaticRange\r\n\t */\r\n\tconstructor(init: StaticRangeInit) {\r\n\t\t// 1. If init’s startContainer or endContainer is a DocumentType or Attr node, then throw an\r\n\t\t// \"InvalidNodeTypeError\" DOMException.\r\n\t\tif (\r\n\t\t\tisNodeOfType(init.startContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)\r\n\t\t) {\r\n\t\t\tthrowInvalidNodeTypeError(\r\n\t\t\t\t'StaticRange startContainer must not be a doctype or attribute node'\r\n\t\t\t);\r\n\t\t}\r\n\t\tif (isNodeOfType(init.endContainer, NodeType.DOCUMENT_TYPE_NODE, NodeType.ATTRIBUTE_NODE)) {\r\n\t\t\tthrowInvalidNodeTypeError(\r\n\t\t\t\t'StaticRange endContainer must not be a doctype or attribute node'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 2. Let staticRange be a new StaticRange object.\r\n\t\t// 3. Set staticRange’s start to (init’s startContainer, init’s startOffset) and end to\r\n\t\t// (init’s endContainer, init’s endOffset).\r\n\t\tthis.startContainer = init.startContainer;\r\n\t\tthis.startOffset = init.startOffset;\r\n\t\tthis.endContainer = init.endContainer;\r\n\t\tthis.endOffset = init.endOffset;\r\n\t\tthis.collapsed =\r\n\t\t\tthis.startContainer === this.endContainer && this.startOffset === this.endOffset;\r\n\r\n\t\t// 4. Return staticRange.\r\n\t}\r\n}\r\n\r\n/**\r\n * A range is collapsed if its start node is its end node and its start offset is its end offset.\r\n *\r\n * @param range - The range to check\r\n */\r\nfunction isCollapsed(range: AbstractRange): boolean {\r\n\treturn range.startContainer === range.endContainer && range.startOffset === range.endOffset;\r\n}\r\n\r\n/**\r\n * Invokes callback on each node contained in range, in tree order, omitting any node whose parent\r\n * is also contained in range.\r\n *\r\n * @param range    - Range to traverse\r\n * @param callback - Callback to invoke for each contained node, should not modify node's position\r\n *                   in the tree\r\n */\r\nfunction forEachNodeContainedInRange(range: AbstractRange, callback: (node: Node) => void): void {\r\n\tif (range.collapsed) {\r\n\t\treturn;\r\n\t}\r\n\t// Determine common ancestors\r\n\tconst ancestors1 = getInclusiveAncestors(range.startContainer);\r\n\tconst ancestors2 = getInclusiveAncestors(range.endContainer);\r\n\tlet firstDistinctAncestorIndex = 0;\r\n\twhile (\r\n\t\tfirstDistinctAncestorIndex < ancestors1.length &&\r\n\t\tfirstDistinctAncestorIndex < ancestors2.length\r\n\t) {\r\n\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t++firstDistinctAncestorIndex;\r\n\t}\r\n\tconst firstChildOutside = range.endContainer.childNodes[range.endOffset] || null;\r\n\t// Walk along children of startContainer\r\n\tfor (\r\n\t\tlet child: Node | null = range.startContainer.childNodes[range.startOffset] || null;\r\n\t\tchild && child !== firstChildOutside && child !== ancestors2[ancestors1.length];\r\n\t\tchild = child.nextSibling\r\n\t) {\r\n\t\tcallback(child);\r\n\t}\r\n\t// Walk along siblings from startContainer to common ancestor\r\n\tfor (let i = ancestors1.length - 1; i >= firstDistinctAncestorIndex; --i) {\r\n\t\tfor (\r\n\t\t\tlet sibling = ancestors1[i].nextSibling;\r\n\t\t\tsibling && sibling !== firstChildOutside && sibling !== ancestors2[i];\r\n\t\t\tsibling = sibling.nextSibling\r\n\t\t) {\r\n\t\t\tcallback(sibling);\r\n\t\t}\r\n\t}\r\n\t// Walk back down to the endContainer, including its children\r\n\tfor (let i = firstDistinctAncestorIndex; i < ancestors2.length; ++i) {\r\n\t\tfor (\r\n\t\t\tlet child = ancestors2[i].firstChild;\r\n\t\t\tchild && child !== firstChildOutside && child !== ancestors2[i + 1];\r\n\t\t\tchild = child.nextSibling\r\n\t\t) {\r\n\t\t\tcallback(child);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n/**\r\n * To extract a live range range, run these steps:\r\n * To clone the contents of a live range range, run these steps:\r\n * (algorithms merged as they are very similar)\r\n *\r\n * @param range   - the live range to extract (or clone) contents of\r\n * @param isClone - whether to clone the contents of the range or extract them\r\n *\r\n * @returns a DocumentFragment with the extracted or cloned contents\r\n */\r\nfunction extractRange(range: Range, isClone: boolean): DocumentFragment {\r\n\t// 1. Let fragment be a new DocumentFragment node whose node document is range's start node's\r\n\t// node document.\r\n\tconst document = getNodeDocument(range.startContainer);\r\n\tconst fragment = document.createDocumentFragment();\r\n\r\n\t// 2. If range is collapsed, then return fragment.\r\n\tif (range.collapsed) {\r\n\t\treturn fragment;\r\n\t}\r\n\r\n\t// 3. Let original start node, original start offset, original end node, and original end offset\r\n\t// be range's start node, start offset, end node, and end offset, respectively.\r\n\tconst originalStartNode = range.startContainer;\r\n\tconst originalStartOffset = range.startOffset;\r\n\tconst originalEndNode = range.endContainer;\r\n\tconst originalEndOffset = range.endOffset;\r\n\r\n\t// 4. If original start node is original end node and it is a CharacterData node, then:\r\n\tif (originalStartNode === originalEndNode && isCharacterDataNode(originalStartNode)) {\r\n\t\t// 4.1. Let clone be a clone of original start node.\r\n\t\tconst clone = originalStartNode.cloneNode();\r\n\r\n\t\t// 4.2. Set the data of clone to the result of substringing data with node original start\r\n\t\t// node, offset original start offset, and count original end offset minus original start\r\n\t\t// offset.\r\n\t\tclone.data = originalStartNode.substringData(\r\n\t\t\toriginalStartOffset,\r\n\t\t\toriginalEndOffset - originalStartOffset\r\n\t\t);\r\n\r\n\t\t// 4.3. Append clone to fragment.\r\n\t\tappendNode(clone, fragment);\r\n\r\n\t\tif (!isClone) {\r\n\t\t\t// 4.4. Replace data with node original start node, offset original start offset, count\r\n\t\t\t// original end offset minus original start offset, and data the empty string.\r\n\t\t\t// (step not used when cloning contents)\r\n\t\t\toriginalStartNode.replaceData(\r\n\t\t\t\toriginalStartOffset,\r\n\t\t\t\toriginalEndOffset - originalStartOffset,\r\n\t\t\t\t''\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 4.5. Return fragment.\r\n\t\treturn fragment;\r\n\t}\r\n\r\n\t// 5. Let common ancestor be original start node.\r\n\t// 6. While common ancestor is not an inclusive ancestor of original end node, set common\r\n\t// ancestor to its own parent.\r\n\t// (implemented differently for performance reasons)\r\n\tconst ancestors1 = getInclusiveAncestors(range.startContainer);\r\n\tconst ancestors2 = getInclusiveAncestors(range.endContainer);\r\n\tlet firstDistinctAncestorIndex = 0;\r\n\twhile (\r\n\t\tfirstDistinctAncestorIndex < ancestors1.length &&\r\n\t\tfirstDistinctAncestorIndex < ancestors2.length\r\n\t) {\r\n\t\tif (ancestors1[firstDistinctAncestorIndex] !== ancestors2[firstDistinctAncestorIndex]) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\t++firstDistinctAncestorIndex;\r\n\t}\r\n\tconst startContainsEnd = firstDistinctAncestorIndex === ancestors1.length;\r\n\tconst endContainsStart = firstDistinctAncestorIndex === ancestors2.length;\r\n\r\n\t// 7. Let first partially contained child be null.\r\n\tlet firstPartiallyContainedChild: Node | null = null;\r\n\r\n\t// 8. If original start node is not an inclusive ancestor of original end node, set first\r\n\t// partially contained child to the first child of common ancestor that is partially contained\r\n\t// in range.\r\n\tif (!startContainsEnd) {\r\n\t\tfirstPartiallyContainedChild = ancestors1[firstDistinctAncestorIndex];\r\n\t}\r\n\r\n\t// 9. Let last partially contained child be null.\r\n\tlet lastPartiallyContainedChild: Node | null = null;\r\n\r\n\t// 10. If original end node is not an inclusive ancestor of original start node, set last\r\n\t// partially contained child to the last child of common ancestor that is partially contained in\r\n\t// range.\r\n\tif (!endContainsStart) {\r\n\t\tlastPartiallyContainedChild = ancestors2[firstDistinctAncestorIndex];\r\n\t}\r\n\r\n\t// Note: These variable assignments do actually always make sense. For instance, if original\r\n\t// start node is not an inclusive ancestor of original end node, original start node is itself\r\n\t// partially contained in range, and so are all its ancestors up until a child of common\r\n\t// ancestor. common ancestor cannot be original start node, because it has to be an inclusive\r\n\t// ancestor of original end node. The other case is similar. Also, notice that the two children\r\n\t// will never be equal if both are defined.\r\n\r\n\t// 11. Let contained children be a list of all children of common ancestor that are contained in\r\n\t// range, in tree order.\r\n\t// (if firstPartiallyContainedChild is null, originalStartNode contains originalEndNode, so\r\n\t// there has to be a child at originalStartOffset)\r\n\tconst containedChildren: Node[] = [];\r\n\tconst firstChildAfterStart = firstPartiallyContainedChild\r\n\t\t? firstPartiallyContainedChild.nextSibling\r\n\t\t: originalStartNode.childNodes[originalStartOffset];\r\n\tconst firstChildAfterEnd =\r\n\t\tlastPartiallyContainedChild || originalEndNode.childNodes[originalEndOffset] || null;\r\n\tfor (\r\n\t\tvar child = firstChildAfterStart;\r\n\t\tchild && child !== firstChildAfterEnd;\r\n\t\tchild = child!.nextSibling\r\n\t) {\r\n\t\t// 12. If any member of contained children is a doctype, then throw a \"HierarchyRequestError\"\r\n\t\t// DOMException.\r\n\t\t// Note: We do not have to worry about the first or last partially contained node, because a\r\n\t\t// doctype can never be partially contained. It cannot be a boundary point of a range, and\r\n\t\t// it cannot be the ancestor of anything.\r\n\t\tif (isNodeOfType(child, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tthrowHierarchyRequestError(\r\n\t\t\t\tisClone\r\n\t\t\t\t\t? 'Can not clone a doctype using cloneContents'\r\n\t\t\t\t\t: 'Can not extract a doctype using extractContents'\r\n\t\t\t);\r\n\t\t}\r\n\t\tcontainedChildren.push(child);\r\n\t}\r\n\r\n\t// 13. If original start node is an inclusive ancestor of original end node, set new node to\r\n\t// original start node and new offset to original start offset.\r\n\t// (variables not used when cloning contents, as the range does not move)\r\n\tlet newNode: Node;\r\n\tlet newOffset: number;\r\n\tif (startContainsEnd || isClone) {\r\n\t\tnewNode = originalStartNode;\r\n\t\tnewOffset = originalStartOffset;\r\n\t} else {\r\n\t\t// 14. Otherwise:\r\n\t\t// (steps not used when cloning contents)\r\n\r\n\t\t// 14.1. Let reference node equal original start node.\r\n\t\t// 14.2. While reference node's parent is not null and is not an inclusive ancestor of\r\n\t\t// original end node, set reference node to its parent.\r\n\t\tconst referenceNode = ancestors1[firstDistinctAncestorIndex];\r\n\r\n\t\t// 14.3. Set new node to the parent of reference node, and new offset to one plus reference\r\n\t\t// node’s index.\r\n\t\t// Note: If reference node's parent is null, it would be the root of range, so would be an\r\n\t\t// inclusive ancestor of original end node, and we could not reach this point.\r\n\t\tnewNode = referenceNode.parentNode!;\r\n\t\tnewOffset = 1 + getNodeIndex(referenceNode);\r\n\t}\r\n\r\n\t// 15. If first partially contained child is a CharacterData node, then:\r\n\tif (\r\n\t\tfirstPartiallyContainedChild !== null &&\r\n\t\tisCharacterDataNode(firstPartiallyContainedChild)\r\n\t) {\r\n\t\t// Note: In this case, first partially contained child is original start node.\r\n\t\t// 15.1. Let clone be a clone of original start node.\r\n\t\tconst clone = firstPartiallyContainedChild.cloneNode();\r\n\r\n\t\t// 15.2. Set the data of clone to the result of substringing data with node original start\r\n\t\t// node, offset original start offset, and count original start node’s length minus original\r\n\t\t// start offset.\r\n\t\tclone.data = firstPartiallyContainedChild.substringData(\r\n\t\t\toriginalStartOffset,\r\n\t\t\tfirstPartiallyContainedChild.length - originalStartOffset\r\n\t\t);\r\n\r\n\t\t// 15.3. Append clone to fragment.\r\n\t\tappendNode(clone, fragment);\r\n\r\n\t\tif (!isClone) {\r\n\t\t\t// 15.4 Replace data with node original start node, offset original start offset, count\r\n\t\t\t// original start node's length minus original start offset, and data the empty string.\r\n\t\t\t// (step not used when cloning contents)\r\n\t\t\tfirstPartiallyContainedChild.replaceData(\r\n\t\t\t\toriginalStartOffset,\r\n\t\t\t\tfirstPartiallyContainedChild.length - originalStartOffset,\r\n\t\t\t\t''\r\n\t\t\t);\r\n\t\t}\r\n\t} else if (firstPartiallyContainedChild !== null) {\r\n\t\t// 16. Otherwise, if first partially contained child is not null:\r\n\r\n\t\t// 16.1. Let clone be a clone of first partially contained child.\r\n\t\tconst clone = firstPartiallyContainedChild.cloneNode();\r\n\r\n\t\t// 16.2. Append clone to fragment.\r\n\t\tappendNode(clone, fragment);\r\n\r\n\t\t// 16.3. Let subrange be a new live range whose start is (original start node, original\r\n\t\t// start offset) and whose end is (first partially contained child, first partially\r\n\t\t// contained child’s length).\r\n\t\tconst subrange = document.createRange();\r\n\t\tsubrange.setStart(originalStartNode, originalStartOffset);\r\n\t\tsubrange.setEnd(\r\n\t\t\tfirstPartiallyContainedChild,\r\n\t\t\tdetermineLengthOfNode(firstPartiallyContainedChild)\r\n\t\t);\r\n\r\n\t\t// 16.4. Let subfragment be the result of extracting / cloning the contents of subrange.\r\n\t\tconst subfragment = extractRange(subrange, isClone);\r\n\t\tsubrange.detach();\r\n\r\n\t\t// 16.5. Append subfragment to clone.\r\n\t\tappendNode(subfragment, clone);\r\n\t}\r\n\r\n\t// 17. For each contained child in contained children\r\n\tcontainedChildren.forEach((containedChild) => {\r\n\t\tif (isClone) {\r\n\t\t\t// 17.1. Let clone be a clone of contained child with the clone children flag set.\r\n\t\t\tconst clone = containedChild.cloneNode(true);\r\n\r\n\t\t\t// 17.2. Append clone to fragment.\r\n\t\t\tappendNode(clone, fragment);\r\n\t\t} else {\r\n\t\t\t// append contained child to fragment.\r\n\t\t\tappendNode(containedChild, fragment);\r\n\t\t}\r\n\t});\r\n\r\n\t// 18. If last partially contained child is a CharacterData node, then:\r\n\tif (lastPartiallyContainedChild && isCharacterDataNode(lastPartiallyContainedChild)) {\r\n\t\t// Note: In this case, last partially contained child is original end node.\r\n\r\n\t\t// 18.1 Let clone be a clone of original end node.\r\n\t\tconst clone = lastPartiallyContainedChild.cloneNode();\r\n\r\n\t\t// 18.2. Set the data of clone to the result of substringing data with node original end\r\n\t\t// node, offset 0, and count original end offset.\r\n\t\tclone.data = lastPartiallyContainedChild.substringData(0, originalEndOffset);\r\n\r\n\t\t// 18.3. Append clone to fragment.\r\n\t\tappendNode(clone, fragment);\r\n\r\n\t\tif (!isClone) {\r\n\t\t\t// 18.4. Replace data with node original end node, offset 0, count original end offset,\r\n\t\t\t// and data the empty string.\r\n\t\t\t// (step not used when cloning contents)\r\n\t\t\tlastPartiallyContainedChild.replaceData(0, originalEndOffset, '');\r\n\t\t}\r\n\t} else if (lastPartiallyContainedChild !== null) {\r\n\t\t// 19. Otherwise, if last partially contained child is not null:\r\n\r\n\t\t// 19.1. Let clone be a clone of last partially contained child.\r\n\t\tconst clone = lastPartiallyContainedChild.cloneNode();\r\n\r\n\t\t// 19.2. Append clone to fragment.\r\n\t\tappendNode(clone, fragment);\r\n\r\n\t\t// 19.3. Let subrange be a new live range whose start is (last partially contained child, 0)\r\n\t\t// and whose end is (original end node, original end offset).\r\n\t\tconst subrange = document.createRange();\r\n\t\tsubrange.setStart(lastPartiallyContainedChild, 0);\r\n\t\tsubrange.setEnd(originalEndNode, originalEndOffset);\r\n\r\n\t\t// 19.4. Let subfragment be the result of extracting / cloning the contents of subrange.\r\n\t\tconst subfragment = extractRange(subrange, isClone);\r\n\t\tsubrange.detach();\r\n\r\n\t\t// 19.5. Append subfragment to clone.\r\n\t\tappendNode(subfragment, clone);\r\n\t}\r\n\r\n\tif (!isClone) {\r\n\t\t// 20. Set range’s start and end to (new node, new offset).\r\n\t\t// (step not used when cloning contents)\r\n\t\trange.setStart(newNode, newOffset);\r\n\t\trange.collapse(true);\r\n\t}\r\n\r\n\t// 21. Return fragment.\r\n\treturn fragment;\r\n}\r\n\r\n/**\r\n * Interface Range\r\n *\r\n * Objects implementing the Range interface are known as live ranges.\r\n *\r\n * @public\r\n */\r\nexport default class Range implements AbstractRange {\r\n\tpublic startContainer: Node;\r\n\tpublic startOffset: number;\r\n\tpublic endContainer: Node;\r\n\tpublic endOffset: number;\r\n\r\n\tpublic get collapsed(): boolean {\r\n\t\treturn isCollapsed(this);\r\n\t}\r\n\r\n\t/**\r\n\t * The Range() constructor, when invoked, must return a new live range with (current global\r\n\t * object’s associated Document, 0) as its start and end.\r\n\t */\r\n\tconstructor() {\r\n\t\tconst context = getContext(this);\r\n\t\tthis.startContainer = context.document;\r\n\t\tthis.startOffset = 0;\r\n\t\tthis.endContainer = context.document;\r\n\t\tthis.endOffset = 0;\r\n\t\tcontext.addRange(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Get the common ancestor of the range's boundary position nodes.\r\n\t *\r\n\t * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\r\n\t */\r\n\tpublic get commonAncestorContainer(): Node {\r\n\t\tconst ancestors1 = getInclusiveAncestors(this.startContainer);\r\n\t\tconst ancestors2 = getInclusiveAncestors(this.endContainer);\r\n\t\tlet commonAncestorContainer = ancestors1[0];\r\n\t\tlet i = 0;\r\n\t\twhile (i < ancestors1.length && i < ancestors2.length) {\r\n\t\t\tif (ancestors1[i] !== ancestors2[i]) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\r\n\t\t\tcommonAncestorContainer = ancestors1[i];\r\n\t\t\t++i;\r\n\t\t}\r\n\r\n\t\treturn commonAncestorContainer;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the start boundary point of the range.\r\n\t *\r\n\t * @param node   - The new start container\r\n\t * @param offset - The new start offset\r\n\t */\r\n\tsetStart(node: Node, offset: number): void {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnode = asObject(node, Node);\r\n\t\toffset = asUnsignedLong(offset);\r\n\r\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\r\n\t\t}\r\n\r\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\r\n\t\tif (offset > determineLengthOfNode(node)) {\r\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\r\n\t\t}\r\n\r\n\t\t// 3. Let bp be the boundary point (node, offset).\r\n\t\t// 4.a. If these steps were invoked as \"set the start\"\r\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\r\n\t\t// set range’s end to bp.\r\n\t\tconst rootOfRange = getRootOfRange(this);\r\n\t\tconst rootOfNode = getRootOfNode(node);\r\n\t\tif (\r\n\t\t\trootOfRange !== rootOfNode ||\r\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\r\n\t\t\t\tPOSITION_AFTER\r\n\t\t) {\r\n\t\t\tthis.endContainer = node;\r\n\t\t\tthis.endOffset = offset;\r\n\t\t}\r\n\t\t// 4.a.2. Set range’s start to bp.\r\n\t\tthis.startContainer = node;\r\n\t\tthis.startOffset = offset;\r\n\r\n\t\t// 4.b. If these steps were invoked as \"set the end\"\r\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\r\n\t\t// set range’s start to bp.\r\n\t\t// 4.b.2. Set range’s end to bp.\r\n\t\t// (see Range#setEnd for this branch)\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the end boundary point of the range.\r\n\t *\r\n\t * @param node   - The new end container\r\n\t * @param offset - The new end offset\r\n\t */\r\n\tsetEnd(node: Node, offset: number): void {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnode = asObject(node, Node);\r\n\t\toffset = asUnsignedLong(offset);\r\n\r\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tthrowInvalidNodeTypeError('Can not set a range under a doctype node');\r\n\t\t}\r\n\r\n\t\t// 2. If offset is greater than node’s length, then throw an IndexSizeError.\r\n\t\tif (offset > determineLengthOfNode(node)) {\r\n\t\t\tthrowIndexSizeError('Can not set a range past the end of the node');\r\n\t\t}\r\n\r\n\t\t// 3. Let bp be the boundary point (node, offset).\r\n\t\t// 4.a. If these steps were invoked as \"set the start\"\r\n\t\t// 4.a.1. If range’s root is not equal to node’s root, or if bp is after the range’s end,\r\n\t\t// set range’s end to bp.\r\n\t\t// 4.a.2. Set range’s start to bp.\r\n\t\t// (see Range#setStart for this branch)\r\n\r\n\t\t// 4.b. If these steps were invoked as \"set the end\"\r\n\t\t// 4.b.1. If range’s root is not equal to node’s root, or if bp is before the range’s start,\r\n\t\t// set range’s start to bp.\r\n\t\tconst rootOfRange = getRootOfRange(this);\r\n\t\tconst rootOfNode = getRootOfNode(node);\r\n\t\tif (\r\n\t\t\trootOfRange !== rootOfNode ||\r\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\r\n\t\t\t\tPOSITION_BEFORE\r\n\t\t) {\r\n\t\t\tthis.startContainer = node;\r\n\t\t\tthis.startOffset = offset;\r\n\t\t}\r\n\t\t// 4.b.2. Set range’s end to bp.\r\n\t\tthis.endContainer = node;\r\n\t\tthis.endOffset = offset;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the start boundary point of the range to the position just before the given node.\r\n\t *\r\n\t * @param node - The node to set the range's start before\r\n\t */\r\n\tsetStartBefore(node: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. Let parent be node’s parent.\r\n\t\tconst parent = node.parentNode;\r\n\r\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\r\n\t\tif (parent === null) {\r\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\r\n\t\t}\r\n\r\n\t\t// 3. Set the start of this to boundary point (parent, node’s index).\r\n\t\tthis.setStart(parent, getNodeIndex(node));\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the start boundary point of the range to the position just after the given node.\r\n\t *\r\n\t * @param node - The node to set the range's start before\r\n\t */\r\n\tsetStartAfter(node: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. Let parent be node’s parent.\r\n\t\tconst parent = node.parentNode;\r\n\r\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\r\n\t\tif (parent === null) {\r\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\r\n\t\t}\r\n\r\n\t\t// 3. Set the start of this to boundary point (parent, node’s index plus one).\r\n\t\tthis.setStart(parent, getNodeIndex(node) + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the end boundary point of the range to the position just before the given node.\r\n\t *\r\n\t * @param node - The node to set the range's end before\r\n\t */\r\n\tsetEndBefore(node: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. Let parent be node’s parent.\r\n\t\tconst parent = node.parentNode;\r\n\r\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\r\n\t\tif (parent === null) {\r\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\r\n\t\t}\r\n\r\n\t\t// 3. Set the end of this to boundary point (parent, node’s index).\r\n\t\tthis.setEnd(parent, getNodeIndex(node));\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the end boundary point of the range to the position just after the given node.\r\n\t *\r\n\t * @param node - The node to set the range's end before\r\n\t */\r\n\tsetEndAfter(node: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. Let parent be node’s parent.\r\n\t\tconst parent = node.parentNode;\r\n\r\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\r\n\t\tif (parent === null) {\r\n\t\t\treturn throwInvalidNodeTypeError('Can not set range before node without a parent');\r\n\t\t}\r\n\r\n\t\t// 3. Set the end of this to boundary point (parent, node’s index plus one).\r\n\t\tthis.setEnd(parent, getNodeIndex(node) + 1);\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the range's boundary points to the same position.\r\n\t *\r\n\t * @param toStart - If true, set both points to the start of the range, otherwise set them to\r\n\t *                  the end\r\n\t */\r\n\tcollapse(toStart: boolean = false): void {\r\n\t\tif (toStart) {\r\n\t\t\tthis.endContainer = this.startContainer;\r\n\t\t\tthis.endOffset = this.startOffset;\r\n\t\t} else {\r\n\t\t\tthis.startContainer = this.endContainer;\r\n\t\t\tthis.startOffset = this.endOffset;\r\n\t\t}\r\n\t}\r\n\r\n\tselectNode(node: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. Let parent be node’s parent.\r\n\t\tlet parent = node.parentNode;\r\n\r\n\t\t// 2. If parent is null, then throw an InvalidNodeTypeError.\r\n\t\tif (parent === null) {\r\n\t\t\treturn throwInvalidNodeTypeError('Can not select node with null parent');\r\n\t\t}\r\n\r\n\t\t// 3. Let index be node’s index.\r\n\t\tconst index = getNodeIndex(node);\r\n\r\n\t\t// 4. Set range’s start to boundary point (parent, index).\r\n\t\tthis.startContainer = parent;\r\n\t\tthis.startOffset = index;\r\n\r\n\t\t// 5. Set range’s end to boundary point (parent, index plus one).\r\n\t\tthis.endContainer = parent;\r\n\t\tthis.endOffset = index + 1;\r\n\t}\r\n\r\n\tselectNodeContents(node: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. If node is a doctype, then throw an InvalidNodeTypeError.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tthrowInvalidNodeTypeError('Can not place range inside a doctype node');\r\n\t\t}\r\n\r\n\t\t// 2. Let length be the length of node.\r\n\t\tconst length = determineLengthOfNode(node);\r\n\r\n\t\t// 3. Set start to the boundary point (node, 0).\r\n\t\tthis.startContainer = node;\r\n\t\tthis.startOffset = 0;\r\n\r\n\t\t// 4. Set end to the boundary point (node, length).\r\n\t\tthis.endContainer = node;\r\n\t\tthis.endOffset = length;\r\n\t}\r\n\r\n\tstatic START_TO_START = 0;\r\n\tstatic START_TO_END = 1;\r\n\tstatic END_TO_END = 2;\r\n\tstatic END_TO_START = 3;\r\n\r\n\tcompareBoundaryPoints(how: number, sourceRange: Range): number {\r\n\t\texpectArity(arguments, 2);\r\n\t\tsourceRange = asObject(sourceRange, Range);\r\n\r\n\t\t// 1. If how is not one of START_TO_START, START_TO_END, END_TO_END, and END_TO_START, then\r\n\t\t// throw a NotSupportedError.\r\n\t\tif (\r\n\t\t\thow !== Range.START_TO_START &&\r\n\t\t\thow !== Range.START_TO_END &&\r\n\t\t\thow !== Range.END_TO_END &&\r\n\t\t\thow !== Range.END_TO_START\r\n\t\t) {\r\n\t\t\tthrowNotSupportedError('Unsupported comparison type');\r\n\t\t}\r\n\r\n\t\t// 2. If this’s root is not the same as sourceRange’s root, then throw a\r\n\t\t// WrongDocumentError.\r\n\t\tif (getRootOfRange(this) !== getRootOfRange(sourceRange)) {\r\n\t\t\tthrowWrongDocumentError('Can not compare positions of ranges in different trees');\r\n\t\t}\r\n\r\n\t\t// 3. If how is:\r\n\t\tswitch (how) {\r\n\t\t\t// START_TO_START:\r\n\t\t\tcase Range.START_TO_START:\r\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\r\n\t\t\t\t// start.\r\n\t\t\t\treturn compareBoundaryPointPositions(\r\n\t\t\t\t\t// this point\r\n\t\t\t\t\tthis.startContainer,\r\n\t\t\t\t\tthis.startOffset,\r\n\t\t\t\t\t// other point\r\n\t\t\t\t\tsourceRange.startContainer,\r\n\t\t\t\t\tsourceRange.startOffset\r\n\t\t\t\t);\r\n\r\n\t\t\t// START_TO_END:\r\n\t\t\tcase Range.START_TO_END:\r\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s\r\n\t\t\t\t// start.\r\n\t\t\t\treturn compareBoundaryPointPositions(\r\n\t\t\t\t\t// this point\r\n\t\t\t\t\tthis.endContainer,\r\n\t\t\t\t\tthis.endOffset,\r\n\t\t\t\t\t// other point\r\n\t\t\t\t\tsourceRange.startContainer,\r\n\t\t\t\t\tsourceRange.startOffset\r\n\t\t\t\t);\r\n\r\n\t\t\t// END_TO_END:\r\n\t\t\tcase Range.END_TO_END:\r\n\t\t\t\t// Let this point be this’s end. Let other point be sourceRange’s end.\r\n\t\t\t\treturn compareBoundaryPointPositions(\r\n\t\t\t\t\t// this point\r\n\t\t\t\t\tthis.endContainer,\r\n\t\t\t\t\tthis.endOffset,\r\n\t\t\t\t\t// other point\r\n\t\t\t\t\tsourceRange.endContainer,\r\n\t\t\t\t\tsourceRange.endOffset\r\n\t\t\t\t);\r\n\r\n\t\t\t// END_TO_START:\r\n\t\t\tdefault:\r\n\t\t\t\t// Let this point be this’s start. Let other point be sourceRange’s\r\n\t\t\t\t// end.\r\n\t\t\t\treturn compareBoundaryPointPositions(\r\n\t\t\t\t\t// this point\r\n\t\t\t\t\tthis.startContainer,\r\n\t\t\t\t\tthis.startOffset,\r\n\t\t\t\t\t// other point,\r\n\t\t\t\t\tsourceRange.endContainer,\r\n\t\t\t\t\tsourceRange.endOffset\r\n\t\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 4. If the position of this point relative to other point is\r\n\t\t// before: Return −1.\r\n\t\t// equal: Return 0.\r\n\t\t// after: Return 1.\r\n\t\t// (handled in switch above)\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the contents of the range\r\n\t */\r\n\tdeleteContents(): void {\r\n\t\t// 1.  If this is collapsed, then return.\r\n\t\tif (this.collapsed) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 2. Let original start node, original start offset, original end node, and original end\r\n\t\t// offset be this's start node, start offset, end node, and end offset, respectively.\r\n\t\tconst originalStartNode = this.startContainer;\r\n\t\tconst originalStartOffset = this.startOffset;\r\n\t\tconst originalEndNode = this.endContainer;\r\n\t\tconst originalEndOffset = this.endOffset;\r\n\r\n\t\t// 3. If original start node is original end node and it is a CharacterData node, then\r\n\t\t// replace data with node original start node, offset original start offset, count original\r\n\t\t// end offset minus original start offset, and data the empty string, and then return.\r\n\t\tif (originalStartNode === originalEndNode && isCharacterDataNode(originalStartNode)) {\r\n\t\t\toriginalStartNode.replaceData(\r\n\t\t\t\toriginalStartOffset,\r\n\t\t\t\toriginalEndOffset - originalStartOffset,\r\n\t\t\t\t''\r\n\t\t\t);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// 4. Let nodes to remove be a list of all the nodes that are contained in this, in tree\r\n\t\t// order, omitting any node whose parent is also contained in this.\r\n\t\tconst nodesToRemove: Node[] = [];\r\n\t\tforEachNodeContainedInRange(this, (node) => {\r\n\t\t\tnodesToRemove.push(node);\r\n\t\t});\r\n\r\n\t\t// 5. If original start node is an inclusive ancestor of original end node, set new node to\r\n\t\t// original start node and new offset to original start offset.\r\n\t\tlet newNode: Node;\r\n\t\tlet newOffset: number;\r\n\t\tif (originalStartNode.contains(originalEndNode)) {\r\n\t\t\tnewNode = originalStartNode;\r\n\t\t\tnewOffset = originalStartOffset;\r\n\t\t} else {\r\n\t\t\t// 6. Otherwise:\r\n\t\t\t// 6.1. Let reference node equal original start node.\r\n\t\t\tlet referenceNode = originalStartNode;\r\n\r\n\t\t\t// 6.2. While reference node's parent is not null and is not an inclusive ancestor of\r\n\t\t\t// original end node, set reference node to its parent.\r\n\t\t\twhile (\r\n\t\t\t\treferenceNode.parentNode !== null &&\r\n\t\t\t\t!referenceNode.parentNode.contains(originalEndNode)\r\n\t\t\t) {\r\n\t\t\t\treferenceNode = referenceNode.parentNode;\r\n\t\t\t}\r\n\r\n\t\t\t// 6.3. Set new node to the parent of reference node, and new offset to one plus the\r\n\t\t\t// index of reference node.\r\n\t\t\t// Note: If reference node’s parent were null, it would be the root of this, so would be\r\n\t\t\t// an inclusive ancestor of original end node, and we could not reach this point.\r\n\t\t\tnewNode = referenceNode.parentNode!;\r\n\t\t\tnewOffset = 1 + getNodeIndex(referenceNode);\r\n\t\t}\r\n\r\n\t\t// 7. If original start node is a CharacterData node, then replace data with node original\r\n\t\t// start node, offset original start offset, count original start node's length minus\r\n\t\t// original start offset, data the empty string.\r\n\t\tif (isCharacterDataNode(originalStartNode)) {\r\n\t\t\toriginalStartNode.replaceData(\r\n\t\t\t\toriginalStartOffset,\r\n\t\t\t\toriginalStartNode.length - originalStartOffset,\r\n\t\t\t\t''\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 8. For each node in nodes to remove, in tree order, remove node.\r\n\t\tnodesToRemove.forEach((node) => {\r\n\t\t\tremoveNode(node);\r\n\t\t});\r\n\r\n\t\t// 9. If original end node is a CharacterData node, then replace data with node original end\r\n\t\t// node, offset 0, count original end offset and data the empty string.\r\n\t\tif (isCharacterDataNode(originalEndNode)) {\r\n\t\t\toriginalEndNode.replaceData(0, originalEndOffset, '');\r\n\t\t}\r\n\r\n\t\t// 10. Set start and end to (new node, new offset).\r\n\t\tthis.setStart(newNode, newOffset);\r\n\t\tthis.collapse(true);\r\n\t}\r\n\r\n\t/**\r\n\t * Move the contents of this range into a new DocumentFragment\r\n\t *\r\n\t * @returns DocumentFragment containing the Range's previous contents\r\n\t */\r\n\textractContents(): DocumentFragment {\r\n\t\treturn extractRange(this, false);\r\n\t}\r\n\r\n\t/**\r\n\t * Clone the contents of this range into a new DocumentFragment\r\n\t *\r\n\t * @returns DocumentFragment containing a copy of the Range's contents\r\n\t */\r\n\tcloneContents(): DocumentFragment {\r\n\t\treturn extractRange(this, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Insert node at the start of this range\r\n\t *\r\n\t * @param node - Node to insert\r\n\t */\r\n\tinsertNode(node: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\tinsertNodeIntoRange(node, this);\r\n\t}\r\n\r\n\t/**\r\n\t * Wraps the contents of this range in the given new parent\r\n\t *\r\n\t * This only works if the only partially contained nodes are text nodes. Any existing children\r\n\t * of newParent will be removed.\r\n\t *\r\n\t * @param newParent - Node to insert\r\n\t */\r\n\tsurroundContents(newParent: Node): void {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnewParent = asObject(newParent, Node);\r\n\r\n\t\t// 1. If a non-Text node is partially contained in this, then throw an \"InvalidStateError\"\r\n\t\t// DOMException.\r\n\t\tconst startNonTextNode = isTextNode(this.startContainer)\r\n\t\t\t? this.startContainer.parentNode\r\n\t\t\t: this.startContainer;\r\n\t\tconst endNonTextNode = isTextNode(this.endContainer)\r\n\t\t\t? this.endContainer.parentNode\r\n\t\t\t: this.endContainer;\r\n\t\tif (startNonTextNode !== endNonTextNode) {\r\n\t\t\tthrowInvalidStateError(\r\n\t\t\t\t'Can not use surroundContents on a range that has partially selected a non-Text node'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 2. If newParent is a Document, DocumentType, or DocumentFragment node, then throw an\r\n\t\t// \"InvalidNodeTypeError\" DOMException.\r\n\t\t// Note: For historical reasons CharacterData nodes are not checked here and end up throwing\r\n\t\t// later on as a side effect.\r\n\t\tif (\r\n\t\t\tisNodeOfType(\r\n\t\t\t\tnewParent,\r\n\t\t\t\tNodeType.DOCUMENT_NODE,\r\n\t\t\t\tNodeType.DOCUMENT_TYPE_NODE,\r\n\t\t\t\tNodeType.DOCUMENT_FRAGMENT_NODE\r\n\t\t\t)\r\n\t\t) {\r\n\t\t\tthrowInvalidNodeTypeError(\r\n\t\t\t\t'Can not use Document, DocumentType, or DocumentFragment as a parent node in surroundContents'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 3. Let fragment be the result of extracting this.\r\n\t\tconst fragment = extractRange(this, false);\r\n\r\n\t\t// 4. If newParent has children, then replace all with null within newParent.\r\n\t\tif (newParent.firstChild) {\r\n\t\t\treplaceAllWithNode(null, newParent);\r\n\t\t}\r\n\r\n\t\t// 5. Insert newParent into this.\r\n\t\tinsertNodeIntoRange(newParent, this);\r\n\r\n\t\t// 6. Append fragment to newParent.\r\n\t\tappendNode(fragment, newParent);\r\n\r\n\t\t// 7. Select newParent within this.\r\n\t\tthis.selectNode(newParent);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a range with the same start and end as this.\r\n\t *\r\n\t * @returns A copy of this\r\n\t */\r\n\tcloneRange(): Range {\r\n\t\tconst context = getContext(this);\r\n\t\tconst range = new context.Range();\r\n\t\trange.startContainer = this.startContainer;\r\n\t\trange.startOffset = this.startOffset;\r\n\t\trange.endContainer = this.endContainer;\r\n\t\trange.endOffset = this.endOffset;\r\n\t\treturn range;\r\n\t}\r\n\r\n\t/**\r\n\t * Stops tracking the range.\r\n\t *\r\n\t * (non-standard) According to the spec, this method must do nothing. However, it is not yet\r\n\t * possible in all browsers to allow garbage collection while keeping track of active ranges to\r\n\t * be updated by mutations. Therefore, unless your code will only run in environments that\r\n\t * implement the WeakRef proposal (https://github.com/tc39/proposal-weakrefs), make sure to call\r\n\t * this method to stop updating the range and free up its resources.\r\n\t */\r\n\tdetach(): void {\r\n\t\tconst context = getContext(this);\r\n\t\tcontext.removeRange(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if the given point is after or equal to the start point and before or equal to\r\n\t * the end point of this.\r\n\t *\r\n\t * @param node   - Node of point to check\r\n\t * @param offset - Offset of point to check\r\n\t *\r\n\t * @returns Whether the point is in the range\r\n\t */\r\n\tisPointInRange(node: Node, offset: number): boolean {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnode = asObject(node, Node);\r\n\t\toffset = asUnsignedLong(offset);\r\n\r\n\t\t// 1. If node’s root is different from this’s root, return false.\r\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\r\n\t\t}\r\n\r\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\r\n\t\tif (offset > determineLengthOfNode(node)) {\r\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\r\n\t\t}\r\n\r\n\t\t// 4. If (node, offset) is before start or after end, return false.\r\n\t\tif (\r\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\r\n\t\t\t\tPOSITION_BEFORE ||\r\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\r\n\t\t\t\tPOSITION_AFTER\r\n\t\t) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 5. Return true.\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Compares the given point to the range's boundary points.\r\n\t *\r\n\t * @param node   - Node of point to check\r\n\t * @param offset - Offset of point to check\r\n\t *\r\n\t * @returns -1, 0 or 1 depending on whether the point is before, inside or after the range,\r\n\t *         respectively\r\n\t */\r\n\tcomparePoint(node: Node, offset: number): number {\r\n\t\texpectArity(arguments, 2);\r\n\t\tnode = asObject(node, Node);\r\n\t\toffset = asUnsignedLong(offset);\r\n\r\n\t\t// 1. If node’s root is different from this’s root, then throw a\r\n\t\t// WrongDocumentError.\r\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\r\n\t\t\tthrowWrongDocumentError('Can not compare point to range in different trees');\r\n\t\t}\r\n\r\n\t\t// 2. If node is a doctype, then throw an InvalidNodeTypeError.\r\n\t\tif (isNodeOfType(node, NodeType.DOCUMENT_TYPE_NODE)) {\r\n\t\t\tthrowInvalidNodeTypeError('Point can not be under a doctype');\r\n\t\t}\r\n\r\n\t\t// 3. If offset is greater than node’s length, then throw an IndexSizeError.\r\n\t\tif (offset > determineLengthOfNode(node)) {\r\n\t\t\tthrowIndexSizeError('Offset should not be past the end of node');\r\n\t\t}\r\n\r\n\t\t// 4. If (node, offset) is before start, return −1.\r\n\t\tif (\r\n\t\t\tcompareBoundaryPointPositions(node, offset, this.startContainer, this.startOffset) ===\r\n\t\t\tPOSITION_BEFORE\r\n\t\t) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\r\n\t\t// 5. If (node, offset) is after end, return 1.\r\n\t\tif (\r\n\t\t\tcompareBoundaryPointPositions(node, offset, this.endContainer, this.endOffset) ===\r\n\t\t\tPOSITION_AFTER\r\n\t\t) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\r\n\t\t// 6. Return 0.\r\n\t\treturn 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns true if range overlaps the range from before node to after node.\r\n\t *\r\n\t * @param node - The node to check\r\n\t *\r\n\t * @returns Whether the range intersects node\r\n\t */\r\n\tintersectsNode(node: Node): boolean {\r\n\t\texpectArity(arguments, 1);\r\n\t\tnode = asObject(node, Node);\r\n\r\n\t\t// 1. If node’s root is different from this’s root, return false.\r\n\t\tif (getRootOfNode(node) !== getRootOfRange(this)) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// 2. Let parent be node’s parent.\r\n\t\tconst parent = node.parentNode;\r\n\r\n\t\t// 3. If parent is null, return true.\r\n\t\tif (parent === null) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// 4. Let offset be node’s index.\r\n\t\tconst offset = getNodeIndex(node);\r\n\r\n\t\t// 5. If (parent, offset) is before end and (parent, offset + 1) is after start, return\r\n\t\t// true.\r\n\t\t// 6. Return false.\r\n\t\treturn (\r\n\t\t\tcompareBoundaryPointPositions(parent, offset, this.endContainer, this.endOffset) ===\r\n\t\t\t\tPOSITION_BEFORE &&\r\n\t\t\tcompareBoundaryPointPositions(\r\n\t\t\t\tparent,\r\n\t\t\t\toffset + 1,\r\n\t\t\t\tthis.startContainer,\r\n\t\t\t\tthis.startOffset\r\n\t\t\t) === POSITION_AFTER\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * The stringification behavior must run these steps:\r\n\t */\r\n\ttoString(): string {\r\n\t\t// 1. Let s be the empty string.\r\n\t\tlet s: string[] = [];\r\n\r\n\t\t// 2. If this's start node is this's end node and it is a Text node, then return the\r\n\t\t// substring of that Text node's data beginning at this's start offset and ending at this's\r\n\t\t// end offset.\r\n\t\tconst startContainer = this.startContainer;\r\n\t\tif (isTextNode(startContainer)) {\r\n\t\t\tif (this.startContainer === this.endContainer) {\r\n\t\t\t\treturn startContainer.substringData(\r\n\t\t\t\t\tthis.startOffset,\r\n\t\t\t\t\tthis.endOffset - this.startOffset\r\n\t\t\t\t);\r\n\t\t\t}\r\n\r\n\t\t\t// 3. If this's start node is a Text node, then append the substring of that node's data\r\n\t\t\t// from this's start offset until the end to s.\r\n\t\t\ts.push(\r\n\t\t\t\tstartContainer.substringData(\r\n\t\t\t\t\tthis.startOffset,\r\n\t\t\t\t\tstartContainer.length - this.startOffset\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 4. Append the concatenation of the data of all Text nodes that are contained in this, in\r\n\t\t// tree order, to s.\r\n\t\tforEachNodeContainedInRange(this, (node) => {\r\n\t\t\tforEachInclusiveDescendant(node, (node) => {\r\n\t\t\t\tif (isTextNode(node)) {\r\n\t\t\t\t\ts.push(node.data);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\t// 5. If this's end node is a Text node, then append the substring of that node's data from\r\n\t\t// its start until this’s end offset to s.\r\n\t\tconst endContainer = this.endContainer;\r\n\t\tif (isTextNode(endContainer)) {\r\n\t\t\ts.push(endContainer.substringData(0, this.endOffset));\r\n\t\t}\r\n\r\n\t\t// 6. Return s.\r\n\t\treturn s.join('');\r\n\t}\r\n}\r\n\r\nconst POSITION_BEFORE = -1;\r\nconst POSITION_EQUAL = 0;\r\nconst POSITION_AFTER = 1;\r\n\r\n/**\r\n * If the two nodes of boundary points (node A, offset A) and (node B, offset B) have the same root,\r\n * the position of the first relative to the second is either before, equal, or after.\r\n *\r\n * Note: for efficiency reasons, this implementation deviates from the algorithm given in 4.2.\r\n *\r\n * This implementation assumes it is called on nodes under the same root.\r\n *\r\n * @param nodeA   - First boundary point's node\r\n * @param offsetA - First boundary point's offset\r\n * @param nodeB   - Second boundary point's node\r\n * @param offsetB - Second boundary point's offset\r\n *\r\n * @returns -1, 0 or 1, depending on the boundary points' relative positions\r\n */\r\nfunction compareBoundaryPointPositions(\r\n\tnodeA: Node,\r\n\toffsetA: number,\r\n\tnodeB: Node,\r\n\toffsetB: number\r\n): number {\r\n\tif (nodeA !== nodeB) {\r\n\t\tconst ancestors1 = getInclusiveAncestors(nodeA);\r\n\t\tconst ancestors2 = getInclusiveAncestors(nodeB);\r\n\r\n\t\t// Skip common parents\r\n\t\twhile (ancestors1[0] && ancestors2[0] && ancestors1[0] === ancestors2[0]) {\r\n\t\t\tancestors1.shift();\r\n\t\t\tancestors2.shift();\r\n\t\t}\r\n\r\n\t\t// Compute offsets at the level under the last common parent. Add 0.5 to bias positions\r\n\t\t// inside the parent vs. those before or after.\r\n\t\tif (ancestors1.length) {\r\n\t\t\toffsetA = getNodeIndex(ancestors1[0]) + 0.5;\r\n\t\t}\r\n\t\tif (ancestors2.length) {\r\n\t\t\toffsetB = getNodeIndex(ancestors2[0]) + 0.5;\r\n\t\t}\r\n\t}\r\n\r\n\t// Compare positions at this level\r\n\tif (offsetA === offsetB) {\r\n\t\treturn POSITION_EQUAL;\r\n\t}\r\n\treturn offsetA < offsetB ? POSITION_BEFORE : POSITION_AFTER;\r\n}\r\n\r\n/**\r\n * The root of a range is the root of its start node.\r\n *\r\n * @param range - The range to get the root of\r\n *\r\n * @returns The root of range\r\n */\r\nfunction getRootOfRange(range: Range): Node {\r\n\treturn getRootOfNode(range.startContainer);\r\n}\r\n","import Document from './Document';\r\nimport { getContext } from './context/Context';\r\n\r\n/**\r\n * @public\r\n */\r\nexport default class XMLDocument extends Document {\r\n\t/**\r\n\t * (non-standard) Creates a copy of this, not including its children.\r\n\t *\r\n\t * @param document - The node document to associate with the copy\r\n\t *\r\n\t * @returns A shallow copy of this\r\n\t */\r\n\tpublic _copy(document: Document): XMLDocument {\r\n\t\t// Set copy’s encoding, content type, URL, origin, type, and mode, to those of node.\r\n\t\t// (properties not implemented)\r\n\r\n\t\tconst context = getContext(document);\r\n\t\treturn new context.XMLDocument();\r\n\t}\r\n}\r\n","import Node from '../Node';\r\nimport { asObject } from '../util/typeHelpers';\r\nimport { produceXmlSerialization } from './serializationAlgorithms';\r\n\r\n/**\r\n * 2.2 The XMLSerializer interface\r\n *\r\n * @public\r\n */\r\nexport default class XMLSerializer {\r\n\t/**\r\n\t * Constructs a new XMLSerializer object.\r\n\t */\r\n\tpublic constructor() {}\r\n\r\n\t/**\r\n\t * Serializes root into a string using an XML serialization. Throws a TypeError exception if\r\n\t * root is not a Node.\r\n\t *\r\n\t * @param root - The node to serialize\r\n\t *\r\n\t * @returns The XML resulting from serialization\r\n\t */\r\n\tpublic serializeToString(root: Node): string {\r\n\t\troot = asObject(root, Node);\r\n\r\n\t\t// Produce an XML serialization of root passing a value of false for the require well-formed\r\n\t\t// parameter, and return the result.\r\n\t\tconst result: string[] = [];\r\n\t\tproduceXmlSerialization(root, false, result);\r\n\t\treturn result.join('');\r\n\t}\r\n}\r\n\r\n/**\r\n * Serializes root into a string using an XML serialization. Throws if the result would not be\r\n * well-formed XML.\r\n *\r\n * Non-standard: the dom-parsing spec does not provide a way to serialize arbitrary nodes while\r\n * enforcing well-formedness.\r\n *\r\n * @public\r\n *\r\n * @param root - The node to serialize\r\n *\r\n * @returns The XML resulting from serialization\r\n */\r\nexport function serializeToWellFormedString(root: Node): string {\r\n\troot = asObject(root, Node);\r\n\r\n\t// Produce an XML serialization of root passing a value of true for the require well-formed\r\n\t// parameter, and return the result.\r\n\tconst result: string[] = [];\r\n\tproduceXmlSerialization(root, true, result);\r\n\treturn result.join('');\r\n}\r\n","import MutationRecord from './MutationRecord';\r\nimport NotifySet from './NotifyList';\r\nimport RegisteredObserver from './RegisteredObserver';\r\nimport Node from '../Node';\r\nimport { expectArity } from '../util/errorHelpers';\r\nimport { asObject } from '../util/typeHelpers';\r\n\r\n/**\r\n * @public\r\n */\r\nexport interface MutationObserverInit {\r\n\t/**\r\n\t * Whether to observe childList mutations.\r\n\t */\r\n\tchildList?: boolean;\r\n\r\n\t/**\r\n\t * Whether to observe attribute mutations.\r\n\t */\r\n\tattributes?: boolean;\r\n\r\n\t/**\r\n\t * Whether to observe character data mutations.\r\n\t */\r\n\tcharacterData?: boolean;\r\n\r\n\t/**\r\n\t * Whether to observe mutations on any descendant in addition to those on the target.\r\n\t */\r\n\tsubtree?: boolean;\r\n\r\n\t/**\r\n\t * Whether to record the previous value of attributes.\r\n\t */\r\n\tattributeOldValue?: boolean;\r\n\r\n\t/**\r\n\t * Whether to record the previous value of character data nodes.\r\n\t */\r\n\tcharacterDataOldValue?: boolean;\r\n}\r\n\r\nexport type MutationCallback = (records: MutationRecord[], observer: MutationObserver) => void;\r\n\r\n/**\r\n * 3.3.1. Interface MutationObserver\r\n *\r\n * A MutationObserver object can be used to observe mutations to the tree of nodes.\r\n *\r\n * @public\r\n */\r\nexport default class MutationObserver {\r\n\t/**\r\n\t * The function that will be called when control returns to the event loop, if there are any\r\n\t * queued records. The function is passed the MutationRecords and the observer instance that\r\n\t * collected them.\r\n\t */\r\n\tpublic _callback: MutationCallback;\r\n\r\n\t/**\r\n\t * The list of nodes on which this observer is a RegisteredObserver's observer.\r\n\t */\r\n\tpublic _nodes: Node[] = [];\r\n\r\n\t/**\r\n\t * The list of MutationRecord objects collected so far.\r\n\t */\r\n\tpublic _recordQueue: MutationRecord[] = [];\r\n\r\n\t/**\r\n\t * Tracks transient registered observers created for this observer, to simplify their removal.\r\n\t */\r\n\tpublic _transients: RegisteredObserver[] = [];\r\n\r\n\t/**\r\n\t * Constructs a MutationObserver object and sets its callback to callback. The callback is\r\n\t * invoked with a list of MutationRecord objects as first argument and the constructed\r\n\t * MutationObserver object as second argument. It is invoked after nodes registered with the\r\n\t * observe() method, are mutated.\r\n\t *\r\n\t * @param callback - Function called after mutations have been observed.\r\n\t */\r\n\tconstructor(callback: MutationCallback) {\r\n\t\texpectArity(arguments, 1);\r\n\t\tcallback = asObject(callback, Function);\r\n\r\n\t\t// 1. Let mo be a new MutationObserver object whose callback is callback.\r\n\t\tthis._callback = callback;\r\n\r\n\t\t// 2. Append mo to mo's relevant agent's mutation observers.\r\n\t\t// (for efficiency, this implementation only tracks MutationObserver objects that have\r\n\t\t// records queued)\r\n\r\n\t\t// 3. Return mo.\r\n\t}\r\n\r\n\t/**\r\n\t * Instructs the user agent to observe a given target (a node) and report any mutations based on\r\n\t * the criteria given by options (an object).\r\n\t *\r\n\t * NOTE: Adding an observer to an element is just like addEventListener, if you observe the\r\n\t * element multiple times it does not make a difference. Meaning if you observe element twice,\r\n\t * the observe callback does not fire twice, nor will you have to run disconnect() twice. In\r\n\t * other words, once an element is observed, observing it again with the same will do nothing.\r\n\t * However if the callback object is different it will of course add another observer to it.\r\n\t *\r\n\t * @param target  - Node (or root of subtree) to observe\r\n\t * @param options - Determines which types of mutations to observe\r\n\t */\r\n\tobserve(target: Node, options: MutationObserverInit) {\r\n\t\texpectArity(arguments, 2);\r\n\t\ttarget = asObject(target, Node);\r\n\r\n\t\t// Defaults from IDL\r\n\t\toptions.childList = !!options.childList;\r\n\t\toptions.subtree = !!options.subtree;\r\n\r\n\t\t// 1. If either options[\"attributeOldValue\"] or options[\"attributeFilter\"] exists, and\r\n\t\t// options[\"attributes\"] does not exist, then set options[\"attributes\"] to true.\r\n\t\tif (options.attributeOldValue !== undefined && options.attributes === undefined) {\r\n\t\t\toptions.attributes = true;\r\n\t\t}\r\n\r\n\t\t// 2. If options[\"characterDataOldValue\"] exists and options[\"characterData\"] does not\r\n\t\t// exist, then set options[\"characterData\"] to true.\r\n\t\tif (options.characterDataOldValue !== undefined && options.characterData === undefined) {\r\n\t\t\toptions.characterData = true;\r\n\t\t}\r\n\t\t// 3. If none of options[\"childList\"], options[\"attributes\"], and options[\"characterData\"]\r\n\t\t// is true, then throw a TypeError.\r\n\t\tif (!(options.childList || options.attributes || options.characterData)) {\r\n\t\t\tthrow new TypeError(\r\n\t\t\t\t'The options object must set at least one of \"attributes\", \"characterData\", or ' +\r\n\t\t\t\t\t'\"childList\" to true.'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 4. If options[\"attributeOldValue\"] is true and options[\"attributes\"] is false, then throw\r\n\t\t// a TypeError.\r\n\t\tif (options.attributeOldValue && !options.attributes) {\r\n\t\t\tthrow new TypeError(\r\n\t\t\t\t'The options object may only set \"attributeOldValue\" to true when \"attributes\" ' +\r\n\t\t\t\t\t'is true or not present.'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 5. If options[\"attributeFilter\"] exists and options[\"attributes\"] is false, then throw a\r\n\t\t// TypeError. (attributeFilter not yet implemented)\r\n\r\n\t\t// 6. If options[\"characterDataOldValue\"] is true and options[\"characterData\"] is false,\r\n\t\t// then throw a TypeError.\r\n\t\tif (options.characterDataOldValue && !options.characterData) {\r\n\t\t\tthrow new TypeError(\r\n\t\t\t\t'The options object may only set \"characterDataOldValue\" to true when ' +\r\n\t\t\t\t\t'\"characterData\" is true or not present.'\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\t// 7. For each registered registered of target’s registered observer list, if registered's\r\n\t\t// observer is this:\r\n\t\t// 7.1. For each node of this's node list, remove all transient registered\r\n\t\t// observers whose source is registered from node's registered observer list.\r\n\t\t// 7.2. Set registered’s options to options.\r\n\t\t// 8. Otherwise:\r\n\t\t// 8.1. Append a new registered observer whose observer is this and options is\r\n\t\t// options to target's registered observer list.\r\n\t\t// 8.2. Append target to this's node list.\r\n\t\ttarget._registeredObservers.register(this, options);\r\n\t}\r\n\r\n\t/**\r\n\t * Stops the MutationObserver instance from receiving notifications of DOM mutations. Until the\r\n\t * observe() method is used again, observer's callback will not be invoked.\r\n\t */\r\n\tdisconnect() {\r\n\t\t// 1. For each node of this’s node list, remove any registered observer from\r\n\t\t// node's registered observer list for which this is the observer.\r\n\t\tthis._nodes.forEach((node) => node._registeredObservers.removeForObserver(this));\r\n\t\tthis._nodes.length = 0;\r\n\r\n\t\t// 2. Empty this’s record queue.\r\n\t\tthis._recordQueue.length = 0;\r\n\t}\r\n\r\n\t/**\r\n\t * Empties the MutationObserver instance's record queue and returns what was in there.\r\n\t *\r\n\t * @returns An Array of MutationRecord objects that were recorded.\r\n\t */\r\n\ttakeRecords(): MutationRecord[] {\r\n\t\t// 1. Let records be a clone of this's record queue.\r\n\t\tconst records = this._recordQueue.concat();\r\n\t\t// 2. Empty this's record queue\r\n\t\tthis._recordQueue.length = 0;\r\n\t\t// 3. Return records\r\n\t\treturn records;\r\n\t}\r\n}\r\n","import Attr from './Attr';\r\nimport Document from './Document';\r\nimport { createElement, default as Element } from './Element';\r\nimport { appendAttribute } from './util/attrMutations';\r\n\r\n/**\r\n * Create an Attr node without the usual validation of the given names.\r\n *\r\n * @public\r\n *\r\n * @param namespace - The namespace URI for the new node\r\n * @param prefix    - The prefix for the new node\r\n * @param localName - The local name for the new node\r\n * @param value     - The value for the new node\r\n * @param element   - The owner element for the new node\r\n *\r\n * @returns A new Attr node with the given values\r\n */\r\nexport function unsafeCreateAttribute(\r\n\tnamespace: string | null,\r\n\tprefix: string | null,\r\n\tlocalName: string,\r\n\tvalue: string,\r\n\townerElement: Element | null\r\n): Attr {\r\n\treturn new Attr(namespace, prefix, localName, value, ownerElement);\r\n}\r\n\r\n/**\r\n * Create an Element node without the usual validation of the given names.\r\n *\r\n * @public\r\n *\r\n * @param document  - The node document for the new element\r\n * @param localName - The local name for the new element\r\n * @param namespace - The namespace URI for the new element, or null for the null namespace\r\n * @param prefix    - The prefix for the new element, or null for no prefix\r\n *\r\n * @returns The new element\r\n */\r\nexport function unsafeCreateElement(\r\n\tdocument: Document,\r\n\tlocalName: string,\r\n\tnamespace: string | null,\r\n\tprefix: string | null = null\r\n): Element {\r\n\treturn createElement(document, localName, namespace, prefix);\r\n}\r\n\r\n/**\r\n * Append an attribute attribute to an element without the usual checks.\r\n *\r\n * @public\r\n *\r\n * @param attribute - The attribute to append\r\n * @param element   - The element to append attribute to\r\n */\r\nexport function unsafeAppendAttribute(attribute: Attr, element: Element): void {\r\n\tappendAttribute(attribute, element);\r\n}\r\n","export { default as Attr } from './Attr';\r\nexport { default as CDATASection } from './CDATASection';\r\nexport { default as CharacterData } from './CharacterData';\r\nexport { default as Comment } from './Comment';\r\nexport { default as Document } from './Document';\r\nexport { default as DocumentFragment } from './DocumentFragment';\r\nexport { default as DocumentType } from './DocumentType';\r\nexport { default as DOMImplementation } from './DOMImplementation';\r\nexport { default as Element } from './Element';\r\nexport { default as Node } from './Node';\r\nexport { default as ProcessingInstruction } from './ProcessingInstruction';\r\nexport { default as Range } from './Range';\r\nexport { StaticRange } from './Range';\r\nexport { default as Text } from './Text';\r\nexport { default as XMLDocument } from './XMLDocument';\r\nexport { default as XMLSerializer } from './dom-parsing/XMLSerializer';\r\nexport { default as MutationObserver } from './mutation-observer/MutationObserver';\r\nexport { default as MutationRecord } from './mutation-observer/MutationRecord';\r\nexport { DOMException } from './util/errorHelpers';\r\n\r\n// Standard DOM does not expose a way to serialize arbitrary nodes as well-formed XML\r\nexport { serializeToWellFormedString } from './dom-parsing/XMLSerializer';\r\n\r\n// Unsafe exports, required for connecting a HTML parser\r\nexport { unsafeCreateAttribute, unsafeCreateElement, unsafeAppendAttribute } from './unsafe';\r\n\r\n// To avoid cyclic dependencies and enable multiple contexts with their own constructors later,\r\n// inject all constructors as well as the global document into the default context (i.e., global\r\n// object) here.\r\nimport { defaultContext } from './context/Context';\r\n\r\nimport Attr from './Attr';\r\nimport CDATASection from './CDATASection';\r\nimport Comment from './Comment';\r\nimport Document from './Document';\r\nimport DocumentFragment from './DocumentFragment';\r\nimport DocumentType from './DocumentType';\r\nimport DOMImplementation from './DOMImplementation';\r\nimport Element from './Element';\r\nimport ProcessingInstruction from './ProcessingInstruction';\r\nimport Range from './Range';\r\nimport Text from './Text';\r\nimport XMLDocument from './XMLDocument';\r\n\r\n/**\r\n * The document associated with the global object. Used when calling constructors directly.\r\n *\r\n * Do not mutate this instance. When possible, it is recommended to use `new slimdom.Document` to\r\n * create a new document, and then use the factory methods on that instance to create other nodes.\r\n *\r\n * @public\r\n */\r\nexport const document = new Document();\r\ndefaultContext.document = document;\r\n\r\ndefaultContext.Attr = Attr;\r\ndefaultContext.CDATASection = CDATASection;\r\ndefaultContext.Comment = Comment;\r\ndefaultContext.Document = Document;\r\ndefaultContext.DocumentFragment = DocumentFragment;\r\ndefaultContext.DocumentType = DocumentType;\r\ndefaultContext.DOMImplementation = DOMImplementation;\r\ndefaultContext.Element = Element;\r\ndefaultContext.ProcessingInstruction = ProcessingInstruction;\r\ndefaultContext.Range = Range;\r\ndefaultContext.Text = Text;\r\ndefaultContext.XMLDocument = XMLDocument;\r\n"],"names":["RegisteredObserver","[object Object]","observer","node","options","source","this","_transients","push","type","target","data","interestedObservers","pairedStrings","subtree","attributes","characterData","childList","index","indexOf","length","undefined","attributeOldValue","characterDataOldValue","oldValue","RegisteredObservers","_registeredObservers","_node","registeredObservers","hasRegisteredObserverForObserver","forEach","registered","i","transientRegisteredObserver","removeTransientRegisteredObserver","splice","removeTransientRegisteredObserversForSource","_nodes","write","read","l","registeredObserver","collectInterestedObservers","registerTransient","queueMicrotaskWithAppropriateApi","callback","thisArg","args","queueMicrotask","Promise","resolve","then","apply","NotifySet","_notifySet","Set","_mutationObserverMicrotaskQueued","record","_recordQueue","add","_notifyMutationObservers","notifySet","Array","from","clear","mo","records","takeRecords","_callback","FakeWeakRef","_target","defaultContext","_ranges","cb","numRanges","r","deref","pop","range","WeakRef","getContext","instance","isNodeOfType","types","some","t","nodeType","isAttrNode","isCharacterDataNode","isTextNode","determineLengthOfNode","childNodes","getInclusiveAncestors","ancestor","ancestors","unshift","parentNode","getNodeDocument","ownerDocument","getNodeIndex","getRootOfNode","forEachInclusiveDescendant","child","firstChild","nextSibling","getListOfElementsWithQualifiedName","qualifiedName","root","elements","element","nodeName","getListOfElementsWithNamespaceAndLocalName","namespace","localName","namespaceURI","cloneNode","cloneChildren","document","copy","_copy","appendChild","expectArity","minArity","TypeError","codeByName","IndexSizeError","HierarchyRequestError","WrongDocumentError","InvalidCharacterError","NotFoundError","NotSupportedError","InUseAttributeError","InvalidStateError","NamespaceError","InvalidNodeTypeError","DOMException","Error","message","name","super","code","stack","createDOMException","throwHierarchyRequestError","throwIndexSizeError","throwInvalidCharacterError","throwInvalidNodeTypeError","throwInvalidStateError","throwNamespaceError","throwNotFoundError","throwNotSupportedError","throwWrongDocumentError","MutationRecord","addedNodes","removedNodes","previousSibling","attributeName","attributeNamespace","queueMutationRecord","context","mappedOldValue","appendRecord","queueMutationObserverMicrotask","asParentNode","getChildren","firstElementChild","nextElementSibling","asNonDocumentTypeChildNode","getPreviousElementSibling","sibling","getNextElementSibling","ensurePreInsertionValidity","parent","contains","parentDocument","fragment","lastElementChild","documentElement","doctype","preInsertNode","referenceChild","adoptNode","insertNode","suppressObservers","isDocumentFragment","nodes","count","n","removeNode","childIndex","forEachRange","startContainer","startOffset","endContainer","endOffset","lastChild","previousElementSibling","siblingNonDocumentTypeChildNode","childElementCount","insertIntoChildren","appendNode","replaceChildWithNode","replaceAllWithNode","oldPreviousSibling","oldNextSibling","isElement","removeFromChildren","inclusiveAncestor","appendTransientRegisteredObservers","oldDocument","inclusiveDescendant","attr","getDescendantTextContent","descendant","join","stringReplaceAll","newValue","Text","convertNodesIntoNode","actualNodes","map","nodeOrString","Node","createTextNode","String","createDocumentFragment","prependNodes","thisObject","appendNodes","replaceChildren","insertNodesBefore","viablePreviousSibling","insertNodesAfter","viableNextSibling","replaceWithNodes","removeFromParent","insertNodeIntoRange","referenceNode","splitText","newOffset","collapsed","setEnd","asUnsignedLong","number","legacyNullToEmptyString","value","ifNullActAsIfEmptyString","asObject","Constructor","expectObject","asNullableObject","asNullableString","orderKeyByNode","WeakMap","getOrderKey","orderKey","get","Math","random","set","parentElement","nextNode","normalize","textNode","siblingsToRemove","replaceData","currentNode","currentNodeIndex","shift","deep","other","arguments","node1","node2","attr1","attr2","ownerElement","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_DISCONNECTED","ancestors1","ancestors2","firstDistinctAncestorIndex","node1ContainsNode2","node2ContainsNode1","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_CONTAINED_BY","lookupNamespaceURI","preRemoveChild","handleAttributeChanges","attribute","changeAttribute","_value","appendAttribute","removeAttribute","attributeElement","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","prototype","Attr","prefix","nodeValue","setExistingAttributeValue","textContent","lookupPrefix","CharacterData","_data","offset","substringData","nodeData","newData","substring","newNode","indexOfNodePlusOne","wholeText","allData","CDATASection","Comment","DocumentType","publicId","systemId","_newValue","HTML_NAMESPACE","XML_NAMESPACE","XMLNS_NAMESPACE","NAME_REGEX_XML_1_0_FIFTH_EDITION","matchesNameProduction","test","validateQualifiedName","parts","split","every","part","isValidQName","validateAndExtract","locateNamespacePrefix","find","NamespacePrefixMap","_map","Map","prefixes","entries","concat","preferredPrefix","ns","candidatesList","CHAR_REGEX_XML_1_0_FIFTH_EDITION","PUBIDCHAR_REGEX_XML_1_0_FIFTH_EDITION","HTML_VOID_ELEMENTS","serializeFragment","requireWellFormed","withFictionalParent","result","produceXmlSerialization","prefixMap","prefixIndex","runXmlSerializationAlgorithm","error","skipEndTag","ignoreNamespaceDefinitionAttribute","localPrefixesMap","localDefaultNamespace","defaultNamespaceAttrValue","attributePrefix","prefixDefinition","namespaceDefinition","checkIfFound","recordNamespaceInformation","inheritedNs","candidatePrefix","retrievePreferredPrefixString","generatePrefix","serializeAttributeValue","localNameSet","tuple","serializeAttributes","hasChildNodes","serializeElementNode","serializeDocumentNode","comment","endsWith","serializeCommentNode","cs","serializeCDATASectionNode","text","markup","replace","serializeTextNode","serializeDocumentFragmentNode","dt","serializeDocumentTypeNode","pi","toLowerCase","serializeProcessingInstructionNode","attributeValue","newNamespace","generatedPrefix","Element","tagName","getAttributeNodeNS","children","getAttributeByName","getAttributeByNamespaceAndLocalName","validatedNamespace","setAttributeValue","removeAttributeByName","removeAttributeByNamespaceAndLocalName","force","setAttribute","copyElement","createElement","copyAttribute","setAttributeNode","innerHTML","outerHTML","throwInUseAttributeError","oldAttr","newAttr","oldAttrElement","replaceAttribute","createElementNS","DOMImplementation","_document","XMLDocument","title","doc","Document","htmlElement","headElement","titleElement","implementation","documentFragment","DocumentFragment","cdataSection","ProcessingInstruction","Range","StaticRange","init","forEachNodeContainedInRange","firstChildOutside","extractRange","isClone","originalStartNode","originalStartOffset","originalEndNode","originalEndOffset","clone","startContainsEnd","endContainsStart","firstPartiallyContainedChild","lastPartiallyContainedChild","containedChildren","firstChildAfterStart","firstChildAfterEnd","subrange","createRange","setStart","subfragment","detach","containedChild","collapse","addRange","commonAncestorContainer","getRootOfRange","compareBoundaryPointPositions","POSITION_AFTER","POSITION_BEFORE","toStart","how","sourceRange","START_TO_START","START_TO_END","END_TO_END","END_TO_START","nodesToRemove","newParent","selectNode","removeRange","s","nodeA","offsetA","nodeB","offsetB","XMLSerializer","serializeToWellFormedString","MutationObserver","Function","register","removeForObserver","unsafeCreateAttribute","unsafeCreateElement","unsafeAppendAttribute"],"mappings":"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"}